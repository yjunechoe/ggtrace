---
title: "ggtrace"
output:
  md_document:
    toc: true
    toc_depth: 2
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
ragg_png = function(...) {
  ragg::agg_png(..., res = 150, units = "in")
}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "ragg_png",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# **{ggtrace}**

<!-- badges: start -->
[![](https://img.shields.io/badge/devel%20version-0.4.8-gogreen.svg)](https://github.com/yjunechoe/ggtrace)
[![](https://img.shields.io/badge/lifecycle-stable-gogreen.svg)](https://lifecycle.r-lib.org/articles/stages.html#maturing)
<!-- badges: end -->

#### **Programmatically inspect, debug, and manipulate ggplot internals**

- **Lightweight** ‚ö°
    - The only dependency is `{rlang}` - not even `{ggplot2}`!
    - Not a lot of code - most of the heavy lifting is done by `base::trace()`
    
- **User-friendly** ‚ù§
    - Everything happens in your local session - no need to fork a repo to inspect the internals!
    - The output is available for inspection outside of the debugging context with `last_ggtrace()` and `global_ggtrace()`
    - Untraces on exit by default, like `debugonce()` 
  
- **Flexible** üõ†
    - Works on any functions and object methods, not just ggproto!
    - You can _programmatically_ debug with `ggtrace()` or _interactively_ debug with `ggedit()`
    - Since `ggtrace()` doesn't rely on interactivity, it can be used in `{reprex}`-es
    - Plays nice with existing debugging tools (ex: you can insert `browser()` calls deep inside the body with `ggedit()`)

- **Powerful** üí™
    - Return the execution environment with `ggtrace()` for further inspection
    - Modify the execution environment by passing assignment expressions to `ggtrace()`
    - Change the source code with `ggedit()`, which is restored upon `gguntrace()`


More on the üì¶ package website: [https://yjunechoe.github.io/ggtrace](https://yjunechoe.github.io/ggtrace)

## **Installation**

You can install the development version from [GitHub](https://github.com/yjunechoe/ggtrace/) with:

``` r
# install.packages("remotes")
remotes::install_github("yjunechoe/ggtrace")
```

```{r setup}
library(ggtrace) # v0.4.8
```

## **Example 1 - `compute_layer` method from `PositionJitter`**

### **Step 1. Make plot**

```{r ex-1-setup}
library(ggplot2) # v3.3.5

jitter_plot <- ggplot(diamonds[1:1000,], aes(cut, depth)) +
  geom_point(position = position_jitter(width = 0.2, seed = 2021))
jitter_plot
```

### **Step 2. Inspect body of the ggproto method**

```{r ex-1-ggbody}
ggbody(PositionJitter$compute_layer)
```

### **Step 3. `ggtrace()` - including the last line with keyword `~step`**

```{r ex-1-ggtrace, fig.show='hide'}
ggtrace(
  method = PositionJitter$compute_layer,
  trace_steps = c(1, 1, 9, 12),
  trace_exprs = rlang::exprs(
    data,            # What does the data passed in look like?
    params,          # What do the initial parameters look like?
    dummy_data,      # What is `dummy_data` defined at Step 8?
    ~step            # What does the last line evaluate to?
                     # - i.e., what is returned by the method?
  ),
  print_output = FALSE   # Don't print evaluated expressions to console
)

# plot not printed to save space
jitter_plot
```

### **Step 4. Inspect trace dump**

```{r ex-1-last}
jitter_tracedump <- last_ggtrace()

jitter_tracedump[[2]]

lapply(jitter_tracedump[-2], nrow)

lapply(jitter_tracedump[-2], head, 3)
```

## **Example 2 - `draw_group` method from `GeomSmooth`**

### **Step 1. Make plot**

```{r ex-2-setup}
smooth_plot <- ggplot(mtcars, aes(mpg, hp)) +
  geom_point() +
  stat_smooth(method = "loess", formula = y ~ x)
smooth_plot
```

### **Step 2. Inspect body of the ggproto method**

```{r ex-2-ggbody}
ggbody(GeomSmooth$draw_group)
```

### **Step 3. `ggtrace()` - get the `gList()`**

```{r ex-2-ggtrace, fig.show='hide'}
ggtrace(
  method = GeomSmooth$draw_group,
  trace_steps = -1,           # Trace the last line
  trace_exprs = quote(~step), # Grab the gList() object it returns
  print_output = FALSE
)

# plot not printed to save space
smooth_plot
```

### **Step 4. Inspect trace dump**

Get grobs in the gList and do some weird stuff with it.

This is nice because you don't have to navigate the whole list of `ggplotGrob(smooth_plot)[["grobs"]]`.

```{r ex-2-last-a, out.width="20%", fig.width=1.5, fig.height=1}
smooth_tracedump <- last_ggtrace()

smooth_gList <- smooth_tracedump[[1]]

smooth_gList

library(grid)

grid.ls(smooth_gList)

grid.newpage()
grid.draw(gTree(children = smooth_gList, vp = viewport()))

# The weird stuff

smooth_ribbon_polygon <- editGrob(
  smooth_gList[1][[1]],
  "polygon",
  grep = TRUE,
  gp = gpar(fill = "#b742ce", alpha = 0.7, lwd = 3, col = "black")
)
smooth_ribbon_gTree <- gTree(
  children = gList(
    smooth_ribbon_polygon,
    textGrob("Weee", x = .7, gp = gpar(col = "red", fontsize = unit(10, "pt")))
  ),
  vp = viewport(width = 1, height = 1, default.units = "in", angle = 30)
)

grid.newpage()
grid.draw(smooth_ribbon_gTree)
```

You might use this for some fancy _data-driven legends_ or something, though it's meant to be exploratory not practical.

```{r ex-2-last-b}
library(patchwork)
smooth_plot +
  inset_element(
    wrap_elements(full = smooth_ribbon_gTree) +
      theme(plot.background = element_rect(fill = NA, color = NA)),
    left = 0.5, bottom = 0.5, right = 0.8, top = 0.8
  )
```

## **Example 3 - `compute_panel` method from `StatBoxplot`**

### **Step 1. Make plot**

```{r ex-3-setup}
boxplot_plot <- ggplot(diamonds[1:500,], aes(cut, depth)) +
  geom_boxplot()
boxplot_plot
```

### **Step 2. Inspect body of the ggproto method**

Actually, `"compute_panel"` method is not defined for `StatBoxplot`. `ggbody()` gives you a hint that it may be inherited. 

```{r ex-3-ggbody-a, error = TRUE}
ggbody(StatBoxplot$compute_panel)
```

`StatBoxplot` is a child of the parent ggproto `Stat`, and the `"compute_panel"` method is inherited from `Stat` as well, so that's what we want to trace instead:

```{r ex-3-ggbody-b}
class(StatBoxplot)
```

With `inherit = TRUE`, `ggbody()` returns the method as defined in the closest parent, and the corresponding code to get it. We confirm that we should be passing `Stat$compute_panel` to the `method` argument for `ggtrace()`.

```{r ex-3-ggbody-c}
ggbody(StatBoxplot$compute_panel, inherit = TRUE)
```

### **Step 3. `ggtrace()` - retrieve the parent environment**

`Stat$compute_panel` does split-apply-combine (Steps 3, 4-5, 6).

Let's return the split and the combine:

```{r ex-3-ggtrace, fig.show='hide'}
ggtrace(
  Stat$compute_panel,
  trace_steps = c(3, 6, 6),
  trace_exprs = rlang::exprs(
    splits      = ~step,         # What are the splits?
    combined    = ~step,         # What does the combined result look like?
    runtime_env = environment()  # Grab the method's execution environment
  ),
  use_names = TRUE,       # Use names of `trace_exprs` for names of the tracedump (default)
  verbose = FALSE         # Suppress all printing (except `message()`s)
                          # This entails the effects of `print_output = FALSE`
)

# plot not printed to save space
boxplot_plot
```

### **Step 4. Inspect trace dump**

```{r ex-3-last}
boxplot_tracedump <- last_ggtrace()

# Trace dump is named after `trace_exprs`
names(boxplot_tracedump)

# Inspect the splits
sapply(boxplot_tracedump[["splits"]], nrow)
lapply(boxplot_tracedump$splits, head, 3)

# Manually calculating some boxplot parameters
lapply(boxplot_tracedump[["splits"]], function(group) {
  quantile(group$y, c(0, 0.25, 0.5, 0.75, 1))
})

# The combined result
boxplot_tracedump[["combined"]]
```

Using the returned environment opens up more powerful manipulations:

```{r ex-3-last-2}
# What was inside the method environment?
ls(envir = boxplot_tracedump[["runtime_env"]])

# Evaluate the expression in Step 6 with the method's runtime environment
eval(
  ggbody(Stat$compute_panel)[[6]],
  envir = boxplot_tracedump[["runtime_env"]]
)

# Manually call the compute_group method from StatBoxplot to apply
# transformation to the third group using the method environment
eval(
  quote(StatBoxplot$compute_group(groups[[3]], scales, ...)),
  envir = boxplot_tracedump[["runtime_env"]]
)
```


## **Example 4 - `compute_group` method from `StatSina` {ggforce}**

### **Step 1. Make plot**

```{r ex-4-setup}
library(ggforce) # v.0.3.3

sina_plot <- ggplot(diamonds[diamonds$cut == "Ideal",][1:50,], aes(cut, depth)) +
  geom_violin() +
  geom_sina(seed = 2021) +
  ggtitle("Original")
sina_plot
```

### **Step 2. Inspect body of the ggproto method**

```{r ex-4-ggbody}
ggbody(StatSina$compute_group)
```

### **Step 3. `ggtrace()` - inject code that modifies method env**

```{r ex-4-ggtrace}
ggtrace(
  method = StatSina$compute_group,
  trace_steps = c(1, 1, 8),
  trace_exprs = rlang::exprs(
    data,                      # 1. What does the data passed in look like at the start?
    data <- dplyr::mutate(     # 2. Modify data in-place in the method environment
      data,         
      y = y + 1,                 # Shift the points up
      x = x - .2                 # Shift the points left
    ),
    data                       # 3. What do the stat transformations on the
                               #    manipulated data look like at the end?
  ),
  verbose = FALSE
)

sina_plot_modified <- ggplotGrob(sina_plot + ggtitle("Modified"))
grid.draw(sina_plot_modified)
```

This effect is ephemeral with the `once = TRUE` default in `ggtrace()`, meaning that only this last plot saved to `sina_plot_modified` is rendered with the modifications.

Here we confirm that the method is restored on exit:

```{r ex-4-ggtrace-restored}
sina_plot

sina_plot + patchwork::wrap_ggplot_grob(sina_plot_modified)
```


### **Step 4. Inspect trace dump**

```{r ex-4-last}
sina_tracedump <- last_ggtrace()

# StatSina did calculations on the modified data in the last `ggtrace()`
lapply(sina_tracedump, head, 3)
```
