---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "jpeg",
  dev.args = list(quality = 150),
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# **{ggtrace}**

<!-- badges: start -->
<!-- badges: end -->

An experimental package for programmatically debugging ggproto methods.

## **Why {ggtrace}?**

- **Lightweight** ‚ö°
    - The only dependency is `{rlang}` (not even `{ggplot2}`!)
    - There isn't a lot of code in the package - most of the heavy lifting is done by `base::trace()`
    
- **User-friendly** ‚ù§
    - Everything happens in your local session - no need to fork a repo to inspect/edit the internals!
    - Multiple expressions can be passed in for evaluation inside method body at specified steps
    - Output of evaluated expressions are available for inspection outside of the debugging environment
    - Calls `untrace()`/`gguntrace()` on itself on exit by default, for extra safety.
  
- **Flexible** üõ†
    - You can  _programmatically_ debug with `ggtrace()` or _interactively_ debug with `ggedit()`
    - Plays nice with existing debugging tools (e.g., `browser()`).
    - Since `ggtrace()` doesn't rely on interactivity or side effects, it's ideal for making targeted `{reprex}`-es
    - Works with other object oriented systems in R (e.g., R6), not just ggproto!
    
- **Powerful** üí™
    - You can return the method's whole environment with `ggtrace()` for further inspection
    - You can test changes to the source code with `ggedit()`, which is restored upon `gguntrace()`
    - You can insert` browser()` calls inside deep parts of the method body with `ggedit()`


More on the üì¶ pkgdown website: [https://yjunechoe.github.io/ggtrace](https://yjunechoe.github.io/ggtrace)

## **Installation**

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("yjunechoe/ggtrace")
```

## **Usage**

```{r setup}
library(ggtrace) # v0.1.1
```

## **Example 1 - `compute_layer` method from `PositionJitter`**

### **Step 1. Make plot**

```{r ex-1-setup}
library(ggplot2) # v3.3.5

jitter_plot <- ggplot(diamonds[1:1000,], aes(cut, depth)) +
  geom_point(position = position_jitter(width = 0.2, seed = 2021))
jitter_plot
```

### **Step 2. Inspect callstack of the ggproto method**

```{r ex-1-ggbody}
ggbody(PositionJitter$compute_layer)
```

### **Step 3. `ggtrace()` - with expressions wrapped in `head()`**

```{r ex-1-ggtrace, fig.show='hide'}
ggtrace(
  method = PositionJitter$compute_layer,
  trace_steps = c(1, 1, 9, 12),
  trace_exprs = rlang::exprs(
    head(data),        # What does the data passed in look like?
    params,            # What do the initial parameters look like?
    head(dummy_data),  # What is `dummy_data` defined at Step 8?
    head(~line)        # What does the last line evaluate to?
                       # - i.e., what is returned by the method?
  ),
  .print = FALSE       # Don't print output of evaluated expressions
)

# plot not printed to save space
jitter_plot
```

### **Step 4. Inspect trace dump**

```{r ex-1-last}
jitter_tracedump <- last_ggtrace()

lapply(jitter_tracedump, nrow)

lapply(jitter_tracedump, head)
```

## **Example 2 - `draw_group` method from `GeomSmooth`**

### **Step 1. Make plot**

```{r ex-2-setup}
smooth_plot <- ggplot(mtcars, aes(mpg, hp)) +
  geom_point() +
  stat_smooth(method = "lm")
smooth_plot
```

### **Step 2. Inspect callstack of the ggproto method**

```{r ex-2-ggbody}
ggbody(GeomSmooth$draw_group)
```

### **Step 3. `ggtrace()` - get `gList()`**

```{r ex-2-ggtrace, fig.show='hide'}
ggtrace(
  method = GeomSmooth$draw_group,
  trace_steps = 7,
  trace_exprs = quote(~line), # Grab the gList() object it returns
  .print = FALSE
)

# plot not printed to save space
smooth_plot
```

### **Step 4. Inspect trace dump**

```{r ex-2-last}
smooth_tracedump <- last_ggtrace()

smooth_tracedump

str(smooth_tracedump[[1]])
```

## **Example 3 - `compute_group` method from `StatBoxplot`**

### **Step 1. Make plot**

```{r ex-3-setup}
boxplot_plot <- ggplot(diamonds[1:500,], aes(cut, depth)) +
  geom_boxplot()
boxplot_plot
```

### **Step 2. Inspect callstack of the ggproto method**

```{r ex-3-ggbody-a, error = TRUE}
ggbody(StatBoxplot$compute_panel)
```

`"compute_panel"` method is not defined for `StatBoxplot`, which means it's being inherited. 

```{r ex-3-ggbody-b}
class(StatBoxplot)
```

`StatBoxplot` is a child of the parent ggproto `Stat`, and the `"compute_panel"` method is inherited from `Stat` as well, so that's what we want to trace:

```{r ex-3-ggbody-c}
ggbody(Stat$compute_panel)
```

### **Step 3. `ggtrace()` - retrieve the parent environment**

`Stat$compute_panel` does split-apply-combine (Steps 3, 4-5, 6).

Let's return the split and the combine:

```{r ex-3-ggtrace, fig.show='hide'}
ggtrace(
  Stat$compute_panel,
  trace_steps = c(3, 6, 6),
  trace_exprs = list(
    quote(~line),         # What are the splits?
    quote(~line),         # What does the combined result look like?
    quote(environment())  # Grab the method environment
  ),
  .print = FALSE
)

# plot not printed to save space
boxplot_plot
```

### **Step 4. Inspect trace dump**

```{r ex-3-last}
boxplot_tracedump <- last_ggtrace()

# The splits
lapply(boxplot_tracedump[[1]], head)

# Manually calculating some boxplot parameters
lapply(boxplot_tracedump[[1]], function(group) {
  quantile(group$y, c(0, 0.25, 0.5, 0.75, 1))
})

# The combined result
boxplot_tracedump[[2]]

# Evaluating Step 6 with the cached method environment
eval(
  ggbody(Stat$compute_panel)[[6]],
  envir = boxplot_tracedump[[3]]
)

# What is inside the environment?
ls(envir = boxplot_tracedump[[3]])

# Use compute_group method from StatBoxplot to apply
# transformation to the first group using the method environment
eval(
  quote(StatBoxplot$compute_group(groups[[1]], scales, ...)),
  envir = boxplot_tracedump[[3]]
)
```


## **Example 4 - `compute_group` method from `StatSina` {ggforce}**

### **Step 1. Make plot**

```{r ex-4-setup}
library(ggforce) # v.0.3.3

sina_plot <- ggplot(diamonds[diamonds$cut == "Ideal",][1:50,], aes(cut, depth)) +
  geom_violin() +
  geom_sina(seed = 2021)
sina_plot
```

### **Step 2. Inspect callstack of the ggproto method**

```{r ex-4-ggbody}
ggbody(StatSina$compute_group)
```

### **Step 3. `ggtrace()` - with one expression evaluated at multiple steps**

```{r ex-4-ggtrace, fig.show='hide'}
ggtrace(
  method = StatSina$compute_group,
  trace_steps = c(1, 8),
  trace_exprs = quote(data), # What does the data look like at start and end?
  .print = FALSE
)

# plot not printed to save space
sina_plot
```

### **Step 4. Inspect trace dump**

```{r ex-4-last}
sina_tracedump <- last_ggtrace()

# The returned data has some new columns
waldo::compare(sina_tracedump[[1]], sina_tracedump[[2]])
```
