---
title: "ggtrace"
output:
  md_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
ragg_png = function(...) {
  ragg::agg_png(..., res = 300, units = "in")
}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  dev = "ragg_png",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# **{ggtrace}** <img class="logo" src="man/figures/logo.png" align="right" style="width:120px;" />

#### **Programmatically explore, debug, and manipulate ggplot internals**

<!-- badges: start -->
[![](https://img.shields.io/badge/devel%20version-0.6.1-gogreen.svg)](https://github.com/yjunechoe/ggtrace)
<!-- badges: end -->

![](https://i.imgur.com/kpTffyw.jpg)

### **Installation**

You can install the development version from [GitHub](https://github.com/yjunechoe/ggtrace/) with:

``` r
# install.packages("remotes")
remotes::install_github("yjunechoe/ggtrace")
```

```{r setup}
library(ggtrace)
```

More on the ðŸ“¦ package website: [https://yjunechoe.github.io/ggtrace](https://yjunechoe.github.io/ggtrace)

### **Description**

`{ggtrace}` embodies an opinionated approach to learning about ggplot internals. The internals is a difficult topic, so I recommend watching the following presentations on `{ggtrace}` before getting started on any kind of code:

- [Presentation at rstudio::conf(2022)](https://www.rstudio.com/conference/2022/talks/cracking-open-ggplot-internals-ggtrace/)

- [Presentation at useR! 2022](https://www.youtube.com/watch?v=2JX8zu4QxMg&t=2959s)

Read more about the philosophy behind `{ggtrace}` in the [Getting Started](https://yjunechoe.github.io/ggtrace/articles/getting-started.html) vignette, and see examples in the [Overview](https://yjunechoe.github.io/ggtrace/articles/overview.html) vignette.

`{ggtrace}` now also has a paper! [Sub-layer modularity in the Grammar of Graphics](https://yjunechoe.github.io/static/papers/Choe_2022_SublayerGG.pdf)

## **Example usage**

```{r ggplot}
library(ggplot2)
packageVersion("ggplot2")
```

### 1) **Inspect sub-layer data**

A bar plot of counts with `geom_bar()` with `stat = "count"` default:

```{r sub-layer-data-bar}
bar_plot <- ggplot(mpg, aes(class, fill = class)) +
  geom_bar() +
  theme(legend.position = "none")
```

State of bar layer's data after the statistical transformation step:

```{r sub-layer-data-after-stat}
ggtrace::layer_after_stat(bar_plot)
```

We can map aesthetics to variables from the after-stat data using `after_stat()`:

```{r sub-layer-data-after-stat-aes}
bar_plot +
  geom_text(
    aes(label = after_stat(count)),
    stat = "count",
    position = position_nudge(y = 1), vjust = 0
  )
```

Same idea with `after_scale()`:

```{r sub-layer-data-scatter}
scatter_plot <- ggplot(mpg, aes(displ, hwy, fill = class)) +
  scale_fill_viridis_d(option = "magma")
scatter_plot +
  geom_point(shape = 21, size = 4, stroke = 1)
```

```{r sub-layer-data-after-scale}
# `fill` column available for `after_scale(fill)`
ggtrace::layer_after_scale(scatter_plot)
```

```{r sub-layer-data-after-scale-aes}
scatter_plot +
  geom_point(
    aes(color = after_scale(prismatic::best_contrast(fill))),
    shape = 21, size = 4, stroke = 1
  )
```

### 2) **Highjack ggproto (remove boxplot outliers)**

You can hide outliers in `geom_boxplot()`, but they'll still be in the layer's underlying dataframe representation. This makes the plot look stretched:

```{r boxplot-hide-outliers, warning = TRUE}
boxplot_plot <- ggplot(mpg, aes(hwy, class)) +
  geom_boxplot(outlier.shape = NA)
boxplot_plot
```

This is because the scales are re-trained after the calculation of the boxplot statistics. In other words, the "final" min/max value of the x-scale are derived from the calculated outliers, even if they're not drawn.

```{r boxplot-layer-data}
layer_data(boxplot_plot)[, c("xmin", "xmax", "outliers", "xmin_final", "xmax_final")]
```

One solution is to highjack the calculation of the boxplot layer's statistics such that values of the `outliers` column is set to `NULL`. In `ggtrace_highjack_return()`, we pass an expression that modifies `returnValue()` to the `value` argument, which evaluates to the value about to be returned by the method.

```{r boxplot-remove-outliers}
ggtrace_highjack_return(
  x = boxplot_plot,
  method = Stat$compute_layer,
  cond = 1L,
  value = quote({
    transform(returnValue(), outliers = NULL)
  })
)
```

Problem inspired by [https://github.com/tidyverse/ggplot2/issues/4892](https://github.com/tidyverse/ggplot2/issues/4892).

Note that this is also possible in "vanilla" ggplot. Following our earlier discussion of `after_stat()`:

```{r boxplot-remove-outliers-after-stat}
# Suppress warning from mapping to `outliers` aesthetic
update_geom_defaults("boxplot", list(outliers = NULL))

ggplot(mpg, aes(hwy, class)) +
  geom_boxplot(
    # Equivalent effect of modifying the after-stat data
    aes(outliers = after_stat(list(NULL)))
  )
```

### 3) **Not just ggproto**

The `method` argument of `ggtrace_*()` workflow functions can be (almost) any function-like object called during the rendering of a ggplot.

```{r not-just-ggproto}
set.seed(2023)
# Example from `?stat_summary`
summary_plot <- ggplot(mtcars, aes(mpg, factor(cyl))) +
  geom_point() +
  stat_summary(fun.data = "mean_cl_boot", colour = "red", linewidth = 2, size = 3)
summary_plot
```

```{r not-just-ggproto-inspect}
ggtrace_inspect_args(x = summary_plot, method = mean_cl_boot)
ggtrace_inspect_return(x = summary_plot, method = mean_cl_boot)
```

```{r not-just-ggproto-highjack}
ggtrace_highjack_return(
  x = summary_plot, method = mean_cl_boot,
  value = quote({
    data.frame(y = 50, ymin = 25, ymax = 75)
  })
)
```

### 4) **Visually crop polar coordinate plots**

Here's a plot in polar coordinates:

```{r polar-plot}
polar_plot <- ggplot(mtcars, aes(hp, mpg)) +
  geom_point() +
  geom_smooth(method = "lm", formula = y ~ x) +
  expand_limits(y = c(0, 60)) +
  coord_polar(start = 0, theta = "y")

polar_plot
```

We can clip the plot panel by highjacking the `Layout$render()` method using the generic workflow function `with_ggtrace()`:

```{r polar-plot-clipped}
with_ggtrace(
  x = polar_plot + theme(aspect.ratio = 1/.48),
  method = Layout$render,
  trace_steps = 5L,
  trace_expr = quote({
    panels[[1]] <- editGrob(panels[[1]], vp = viewport(xscale = c(.48, 1)))
  }),
  out = "g"
)
```

Inspired by a [twitter thread](https://twitter.com/mattansb/status/1506620436771229715?s=20). See implementation in [`MSBMisc::crop_coord_polar()`](https://mattansb.github.io/MSBMisc/reference/crop_coord_polar.html).

### 5) **Highjack the drawing context**

Flashy example adopted from my [UseR! talk](https://yjunechoe.github.io/ggtrace-user2022/#/for-grid-power-users):

```{r flashy-plot}
library(palmerpenguins)
flashy_plot <- na.omit(palmerpenguins::penguins) |> 
  ggplot(aes(x = species, y = flipper_length_mm)) +
  geom_boxplot(aes(fill = species), width = .7) +
  facet_wrap(~ year)
flashy_plot
```

```{r flashy-highjack}
ggtrace_highjack_return(
  flashy_plot, Geom$draw_panel, cond = TRUE,
  value = quote({
    circ <- circleGrob(y = .25 * ._counter_)
    grobTree( editGrob(circ, gp = gpar(fill = linearGradient())),
              editGrob(returnValue(), vp = viewport(clip = circ)) )
  }))
```

Note the use of the special variable `._counter_`, which increments every time a function/method has been called. See the reference section on [tracing context](https://yjunechoe.github.io/ggtrace/reference/ggtrace_highjack_args.html#tracing-context) for more details.

<!-- ### **Extract legends** -->

<!-- ```{r legend-plot} -->
<!-- p_legend <- ggplot(mtcars, aes(hp, mpg, color = factor(cyl))) + -->
<!--   geom_point() + -->
<!--   geom_smooth(method = "lm", formula = y ~ x) -->

<!-- p_legend -->
<!-- ``` -->

<!-- For more control over legends, we can use `ggplot2::guide_*(override.aes = ...)`: -->

<!-- ```{r legends-make} -->
<!-- p_legend1 <- p_legend + -->
<!--   scale_color_discrete( -->
<!--     name = "cyl", -->
<!--     guide = guide_legend(override.aes = list(shape = NA, fill = NA)) -->
<!--   ) + -->
<!--   theme(legend.key = element_rect(fill = "white")) -->

<!-- p_legend2 <- p_legend + -->
<!--   scale_color_discrete( -->
<!--     name = NULL, labels = c("observation", "linear fit", "95% interval"), -->
<!--     guide = guide_legend( -->
<!--       override.aes = list( -->
<!--         shape = c(16, NA, NA), color = c("black", "black", NA), -->
<!--         linetype = c(NA, 1, NA), fill = c(NA, NA, "grey60") -->
<!--       ) -->
<!--     ) -->
<!--   ) + -->
<!--   theme(legend.key = element_rect(fill = "white")) -->

<!-- library(patchwork) -->
<!-- p_legend1 + p_legend2 -->
<!-- ``` -->

<!-- Using `ggtrace_inspect_return()`, we can grab the return value from the legend-making function for each plot and then plot them over the panel using `{patchwork}`: -->

<!-- ```{r legends-inset} -->
<!-- legend1 <- ggtrace_inspect_return(p_legend1, ggplot2:::guide_gengrob.legend) -->
<!-- legend2 <- ggtrace_inspect_return(p_legend2, ggplot2:::guide_gengrob.legend) -->

<!-- (p_legend + guides(color = guide_none())) + -->
<!--   inset_element(legend1, .7, .8, .7, .8) + -->
<!--   inset_element(legend2, .85, .8, .85, .8) -->
<!-- ``` -->
