---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
ragg_png = function(...) {
  ragg::agg_png(..., res = 150, units = "in")
}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "ragg_png",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# **{ggtrace}**

<!-- badges: start -->
<!-- badges: end -->

An experimental package for programmatically debugging ggproto methods.

## **Why {ggtrace}?**

- **Lightweight** ‚ö°
    - The only dependency is `{rlang}` (not even `{ggplot2}`!)
    - There isn't a lot of code in the package - most of the heavy lifting is done by `base::trace()`
    
- **User-friendly** ‚ù§
    - Everything happens in your local session - no need to fork a repo to inspect/edit the internals!
    - Multiple expressions can be passed in for evaluation inside method body at specified steps
    - Output of evaluated expressions are available for inspection outside of the debugging environment
    - Calls `untrace()`/`gguntrace()` on itself on exit by default, for extra safety.
  
- **Flexible** üõ†
    - You can  _programmatically_ debug with `ggtrace()` or _interactively_ debug with `ggedit()`
    - Plays nice with existing debugging tools (e.g., `browser()`).
    - Since `ggtrace()` doesn't rely on interactivity or side effects, it's ideal for making targeted `{reprex}`-es
    - Works with other object oriented systems in R (e.g., R6), not just ggproto!
    
- **Powerful** üí™
    - You can return the method's whole environment with `ggtrace()` for further inspection
    - You can test changes to the source code with `ggedit()`, which is restored upon `gguntrace()`
    - You can insert` browser()` calls inside deep parts of the method body with `ggedit()`


More on the üì¶ pkgdown website: [https://yjunechoe.github.io/ggtrace](https://yjunechoe.github.io/ggtrace)

## **Installation**

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("yjunechoe/ggtrace")
```

## **Usage**

```{r setup}
library(ggtrace) # v0.1.1
```

## **Example 1 - `compute_layer` method from `PositionJitter`**

### **Step 1. Make plot**

```{r ex-1-setup}
library(ggplot2) # v3.3.5

jitter_plot <- ggplot(diamonds[1:1000,], aes(cut, depth)) +
  geom_point(position = position_jitter(width = 0.2, seed = 2021))
jitter_plot
```

### **Step 2. Inspect callstack of the ggproto method**

```{r ex-1-ggbody}
ggbody(PositionJitter$compute_layer)
```

### **Step 3. `ggtrace()` - with expressions wrapped in `head()`**

```{r ex-1-ggtrace, fig.show='hide'}
ggtrace(
  method = PositionJitter$compute_layer,
  trace_steps = c(1, 1, 9, 12),
  trace_exprs = rlang::exprs(
    head(data),        # What does the data passed in look like?
    params,            # What do the initial parameters look like?
    head(dummy_data),  # What is `dummy_data` defined at Step 8?
    head(~line)        # What does the last line evaluate to?
                       # - i.e., what is returned by the method?
  ),
  .print = FALSE       # Don't print evaluated expressions to console
)

# plot not printed to save space
jitter_plot
```

### **Step 4. Inspect trace dump**

```{r ex-1-last}
jitter_tracedump <- last_ggtrace()

lapply(jitter_tracedump, nrow)

lapply(jitter_tracedump, head)
```

## **Example 2 - `draw_group` method from `GeomSmooth`**

### **Step 1. Make plot**

```{r ex-2-setup}
smooth_plot <- ggplot(mtcars, aes(mpg, hp)) +
  geom_point() +
  stat_smooth()
smooth_plot
```

### **Step 2. Inspect callstack of the ggproto method**

```{r ex-2-ggbody}
ggbody(GeomSmooth$draw_group)
```

### **Step 3. `ggtrace()` - get `gList()`**

```{r ex-2-ggtrace, fig.show='hide'}
ggtrace(
  method = GeomSmooth$draw_group,
  trace_steps = 7,
  trace_exprs = quote(~line), # Grab the gList() object it returns
  .print = FALSE
)

# plot not printed to save space
smooth_plot
```

### **Step 4. Inspect trace dump**

Get grobs in the gList and do some weird stuff with it

```{r ex-2-last-a, out.width="20%", fig.width=1.5, fig.height=1}
smooth_tracedump <- last_ggtrace()

smooth_gList <- smooth_tracedump[[1]]

smooth_gList

library(grid)

grid.ls(smooth_gList)

grid.newpage()
grid.draw(gTree(children = smooth_gList, vp = viewport()))

# The weird stuff

smooth_ribbon_polygon <- editGrob(
  smooth_gList[1][[1]],
  "polygon",
  grep = TRUE,
  gp = gpar(fill = "#b742ce", alpha = 0.7, lwd = 3, col = "black")
)
smooth_ribbon_gTree <- gTree(
  children = gList(
    smooth_ribbon_polygon,
    textGrob("Weee", x = .7, gp = gpar(col = "red", fontsize = unit(10, "pt")))
  ),
  vp = viewport(width = 1, height = 1, default.units = "in", angle = 30)
)

grid.newpage()
grid.draw(smooth_ribbon_gTree)
```

I guess you could use this for some fancy _data-driven legends_ or something but it's meant to be exploratory not practical

```{r ex-2-last-b}
library(patchwork)
smooth_plot +
  inset_element(
    wrap_elements(full = smooth_ribbon_gTree) +
      theme(plot.background = element_rect(fill = NA, color = NA)),
    left = 0.5, bottom = 0.5, right = 0.8, top = 0.8
  )
```

But I will just add that the above way of "intercepting" and retrieving a grob is kinda nice because you know what will be there ahead of the time from your knowledge of that Geom (whereas if you wanted to grab a grob after the ggplot is built, you'd have to navigate the whole `ggplotGrob(smooth_plot)[["grobs"]]`).

## **Example 3 - `compute_group` method from `StatBoxplot`**

### **Step 1. Make plot**

```{r ex-3-setup}
boxplot_plot <- ggplot(diamonds[1:500,], aes(cut, depth)) +
  geom_boxplot()
boxplot_plot
```

### **Step 2. Inspect callstack of the ggproto method**

`"compute_panel"` method is not defined for `StatBoxplot`, which means it's being inherited. 

```{r ex-3-ggbody-a, error = TRUE}
ggbody(StatBoxplot$compute_panel)
```

`StatBoxplot` is a child of the parent ggproto `Stat`, and the `"compute_panel"` method is inherited from `Stat` as well, so that's what we want to trace instead:

```{r ex-3-ggbody-b}
class(StatBoxplot)
```

```{r ex-3-ggbody-c}
ggbody(Stat$compute_panel)
```

### **Step 3. `ggtrace()` - retrieve the parent environment**

`Stat$compute_panel` does split-apply-combine (Steps 3, 4-5, 6).

Let's return the split and the combine:

```{r ex-3-ggtrace, fig.show='hide'}
ggtrace(
  Stat$compute_panel,
  trace_steps = c(3, 6, 6),
  trace_exprs = list(
    quote(~line),         # What are the splits?
    quote(~line),         # What does the combined result look like?
    quote(environment())  # Grab the method environment
  ),
  .print = FALSE
)

# plot not printed to save space
boxplot_plot
```

### **Step 4. Inspect trace dump**

```{r ex-3-last}
boxplot_tracedump <- last_ggtrace()

# The splits
lapply(boxplot_tracedump[[1]], head)

# Manually calculating some boxplot parameters
lapply(boxplot_tracedump[[1]], function(group) {
  quantile(group$y, c(0, 0.25, 0.5, 0.75, 1))
})

# The combined result
boxplot_tracedump[[2]]

# Evaluating Step 6 with the cached method environment
eval(
  ggbody(Stat$compute_panel)[[6]],
  envir = boxplot_tracedump[[3]]
)

# What is inside the environment?
ls(envir = boxplot_tracedump[[3]])

# Use compute_group method from StatBoxplot to apply
# transformation to the first group using the method environment
eval(
  quote(StatBoxplot$compute_group(groups[[1]], scales, ...)),
  envir = boxplot_tracedump[[3]]
)
```


## **Example 4 - `compute_group` method from `StatSina` {ggforce}**

### **Step 1. Make plot**

```{r ex-4-setup}
library(ggforce) # v.0.3.3

sina_plot <- ggplot(diamonds[diamonds$cut == "Ideal",][1:50,], aes(cut, depth)) +
  geom_violin() +
  geom_sina(seed = 2021)
sina_plot
```

### **Step 2. Inspect callstack of the ggproto method**

```{r ex-4-ggbody}
ggbody(StatSina$compute_group)
```

### **Step 3. `ggtrace()` - with one expression evaluated at multiple steps**

```{r ex-4-ggtrace, fig.show='hide'}
ggtrace(
  method = StatSina$compute_group,
  trace_steps = c(1, 8),
  trace_exprs = quote(data), # What does the data look like at start and end?
  .print = FALSE
)

# plot not printed to save space
sina_plot
```

### **Step 4. Inspect trace dump**

```{r ex-4-last}
sina_tracedump <- last_ggtrace()

# The returned data has some new columns
waldo::compare(sina_tracedump[[1]], sina_tracedump[[2]])
```
