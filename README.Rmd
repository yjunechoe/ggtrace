---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# **{ggtrace}**

<!-- badges: start -->
[](https://lifecycle.r-lib.org/articles/figures/lifecycle-experimental.svg)
[![R-CMD-check](https://github.com/yjunechoe/ggtrace/workflows/R-CMD-check/badge.svg)](https://github.com/yjunechoe/ggtrace/actions)
<!-- badges: end -->

An experimental package for programmatically debugging ggproto methods with `trace()`.

## **Why {ggtrace}?**

- ‚ö° **Lightweight**: 
    - The only dependency is `{rlang}` (not even `{ggplot2}` is required!)
    - There isn't a lot of code in the package - most of the heavy lifting is done by `base::trace()`
    
- ‚ù§ **User-friendly**:
    - Everything happens in your local session - no need to fork a repo to inspect/edit the internals!
    - Multiple expressions can be passed in to be evaluated inside method body
    - Output of evaluated expressions are available for inspection outside of the debugging environment.
    - Calls `untrace()` on itself on exit by default, for extra safety
  
- üõ† **Flexible**:
    - You can either...
        - _Programmatically_ debug with `ggtrace()`, for testing, building reprexes, etc., OR
        - _Interactively_ debug with `ggedit()` by directly editing the source code.
    - Your favorite debugging tools (e.g., `browser()`) can be easily incorporated into this workflow.
    - Can be used to debug other object classes in R, not just ggproto!

More on the pkgdown website: [https://yjunechoe.github.io/ggtrace]()

## **Installation**

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("yjunechoe/ggtrace")
```

## **Usage**

```{r setup}
library(ggtrace)
library(ggplot2) # v3.3.5
```

## **Example 1 - `compute_layer` method from `PositionJitter`**

### **Step 1. Make plot**

```{r ex-1-setup}
jitter_plot <- ggplot(diamonds[1:1000,], aes(cut, depth)) +
  geom_point(position = position_jitter(width = 0.2, seed = 2021))
jitter_plot
```

### **Step 2. Inspect callstack of the ggproto of interest**

```{r ex-1-ggbody}
ggbody(PositionJitter$compute_layer)
```

### **Step 3a. `ggtrace()` - with expressions wrapped in `head()`**

```{r ex-1a-ggtrace, fig.show='hide'}
ggtrace(
  method = PositionJitter$compute_layer,
  trace_steps = c(1, 1, 9, 12),
  trace_exprs = rlang::exprs(
    head(data),        # What does the data passed in look like?
    params,            # What do the initial parameters look like?
    head(dummy_data),  # What is `dummy_data` defined at Step 8?
    head(~line)        # What does the last line evaluate to?
                       # - i.e., what is returned by the method?
  )
)

# plot not printed to save space
jitter_plot
```

### **Step 4a. Inspect trace dumnp**

```{r ex-1a-last}
last_ggtrace()
```

### **Step 3b. `ggtrace()` - with `.print = FALSE` instead (recommended)**

```{r ex-1b-ggtrace, fig.show='hide'}
ggtrace(
  method = PositionJitter$compute_layer,
  trace_steps = c(1, 9, 12),
  trace_exprs = rlang::exprs(
    data,
    dummy_data,
    ~line
  ),
  .print = FALSE
)

# plot not printed to save space
jitter_plot
```

### **Step 4b. Inspect trace dump**

```{r ex-1b-last}
jitter_tracedump <- last_ggtrace()
lapply(jitter_tracedump, nrow)
lapply(jitter_tracedump, head)
```

## **Example 2 - `draw_group` method from `GeomSmooth`**

### **Step 1. Make plot**

```{r ex-2-setup}
smooth_plot <- ggplot(mtcars, aes(mpg, hp)) +
  geom_point() +
  stat_smooth(method = "lm")
smooth_plot
```

### **Step 2. Inspect callstack of the ggproto of interest**

```{r ex-2-ggbody}
ggbody(GeomSmooth$draw_group)
```

### **Step 3. `ggtrace()` - get `gList()`**

```{r ex-2-ggtrace, fig.show='hide'}
ggtrace(
  method = GeomSmooth$draw_group,
  trace_steps = 7,
  trace_exprs = quote(~line),
  .print = FALSE
)

# plot not printed to save space
smooth_plot
```

### **Step 4. Inspect trace dump**

```{r ex-2-last}
smooth_tracedump <- last_ggtrace()
smooth_tracedump
str(smooth_tracedump[[1]])
```


## **Example 3 - `compute_group` method from `StatSina` {ggforce}**

### **Step 1. Make plot**

```{r ex-3-setup}
library(ggforce) # v.0.3.3

sina_plot <- ggplot(diamonds[diamonds$cut == "Ideal",][1:50,], aes(cut, depth)) +
  geom_violin() +
  geom_sina(seed = 2021)
sina_plot
```

### **Step 2. Inspect callstack of the ggproto of interest**

```{r ex-3-ggbody}
ggbody(StatSina$compute_group)
```

### **Step 3. `ggtrace()` - with one expression evaluated at multiple steps**

```{r ex-3-ggtrace, fig.show='hide'}
ggtrace(
  method = StatSina$compute_group,
  trace_steps = c(1, 8),
  trace_exprs = quote(data),
  .print = FALSE
)

# plot not printed to save space
sina_plot
```

### **Step 4. Inspect trace dump**

```{r ex-3-last}
sina_tracedump <- last_ggtrace()
waldo::compare(sina_tracedump[[1]], sina_tracedump[[2]])
```
