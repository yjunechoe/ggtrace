% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sublayer-data.R
\name{sublayer-data}
\alias{sublayer-data}
\alias{layer_before_stat}
\alias{layer_after_stat}
\alias{layer_before_geom}
\alias{layer_after_scale}
\alias{layer_is}
\alias{.layer_is}
\title{Inspect snapshots of sub-layer data}
\usage{
layer_before_stat(plot, i = 1L, ..., error = FALSE, verbose = TRUE)

layer_after_stat(plot, i = 1L, ..., error = FALSE, verbose = TRUE)

layer_before_geom(plot, i = 1L, ..., error = FALSE, verbose = TRUE)

layer_after_scale(plot, i = 1L, ..., error = FALSE, verbose = TRUE)

layer_is(expr)

.layer_is(expr)
}
\arguments{
\item{plot}{A ggplot object. If missing, defaults to \code{ggplot2::last_plot()}.}

\item{i}{Index of the layer to inspect. Defaults to \code{1L}.}

\item{...}{Unused.}

\item{error}{If \code{TRUE}, returns the layer data early if available before the point of error.}

\item{verbose}{If \code{TRUE}, prints the corresponding ggtrace code and re-prints the error if it exists.}

\item{expr}{An expression to evaluate for each call to the method, which
exposes information about the current layer that the method is being
called for. In technical terms, \code{layer_is()} subsets calls to the method
that are downstream of the \code{by_layer()} function in the ggplot internals.
It exposes some context-dependent variables, including:
\itemize{
\item \code{i}: Scalar integer representing the nth layer
\item \code{layers}: A list whose contents are equivalent to \verb{<ggplot>$layers}
}}
}
\value{
A dataframe
}
\description{
\code{layer_before_stat()}, \code{layer_after_stat()}, \code{layer_before_geom()}, and
\code{layer_after_scale()} are convenience functions that return a snapshot of
a layer's data in the internals. \code{layer_is()} is a helper function used by
these.
}
\examples{
library(ggplot2)
p1 <- ggplot(mpg, aes(displ, class)) +
  geom_boxplot(outlier.shape = NA) +
  geom_text(
    aes(
      label = after_stat(xmax),
      x = stage(displ, after_stat = xmax)
    ),
    stat = "boxplot", hjust = -0.5
  )
p1

# Before Stat snapshot of first layer's data
layer_before_stat()

# After Stat snapshot of first layer's data
layer_after_stat()

# First and second layer's data are identical for those two stages
identical(layer_before_stat(), layer_before_stat(i = 2))
identical(layer_after_stat(), layer_after_stat(i = 2))

# `after_stat()` mappings add new columns to the second layer's data
# by the time the geom receives the data in the Before Geom stage
library(dplyr)
layer_before_geom(i = 2)

# After Scale data reflects `after_scale()` mappings
p2 <- ggplot(mpg, aes(as.factor(cyl), hwy, color = as.factor(cyl))) +
  theme(legend.position = 0)
p2a <- p2 +
  geom_boxplot(aes(fill = as.factor(cyl)))
p2b <- p2 +
  geom_boxplot(aes(fill = after_scale(alpha(color, .6))))

library(patchwork)
p2a + p2b

layer_after_scale(p2a, verbose = FALSE)$fill
layer_after_scale(p2b, verbose = FALSE)$fill
alpha( layer_after_scale(p2a, verbose = FALSE)$fill, .6 )

}
\keyword{internal}
