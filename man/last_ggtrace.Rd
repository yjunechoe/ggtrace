% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/last_ggtrace.R
\name{last_ggtrace}
\alias{last_ggtrace}
\alias{clear_last_ggtrace}
\alias{global_ggtrace}
\alias{clear_global_ggtrace}
\alias{global_ggtrace_state}
\title{Retrieve the trace dump created by \code{ggtrace()}}
\usage{
last_ggtrace()

clear_last_ggtrace()

global_ggtrace()

clear_global_ggtrace()

global_ggtrace_state(state)
}
\arguments{
\item{state}{If missing, returns whether the global tracedump is currently active.
The global tracedump is active by default (\code{state} is \code{TRUE}), meaning that
every time a trace created by \code{ggtrace()} is triggered, its tracedump is added
to the global tracedump storage, which can be inspected with \code{global_ggtrace()}.

The global tracedump can be turned on/off by setting \code{state} to \code{TRUE}/\code{FALSE}.}
}
\value{
A list

A logical indicating the current state of the global trace dump.
If \code{state} is provided, changes the state first, then returns the state invisibly.
}
\description{
Retrieve the trace dump created by \code{ggtrace()}
}
\details{
\itemize{
\item \code{last_ggtrace()} retrieves the last trace dump created by \code{ggtrace()} - i.e., from the last time
the trace has been triggered.
\item \code{global_ggtrace()} is a list of trace dumps collected across multiple traces, and is recommended
for use with \code{ggtrace(once = FALSE)} when you expect a trace to be independently triggered multiple
times (for example, when you are tracing a (compute/draw)_group method and there are multiple groups, or
when the plot has multiple layers which all call the method being traced).
}

When a trace dump is pushed to \code{global_ggtrace()} upon exiting a trace, it gets named after the ggproto method
and a hex code identifying the method's runtime environment, e.g. \code{"Stat$compute_layer-00000267437FD3D8"}.
\itemize{
\item \code{clear_global_ggtrace()} sets the value of \code{global_ggtrace()} to \code{NULL} and returns it.
}
}
\examples{
library(ggplot2)

# Inspect last tracedump

ggtrace(StatSmooth$compute_group, trace_steps = -1, trace_exprs = quote(head(prediction)))

ggplot(mtcars, aes(mpg, hp)) + geom_point() + geom_smooth(method = 'lm')

last_ggtrace()

ggtrace(
  StatSmooth$compute_group,
  trace_steps = -1,
  trace_exprs = quote(prediction),
  verbose = FALSE
)

ggplot(mtcars, aes(mpg, hp)) + geom_point() + geom_smooth(method = 'lm')

head(last_ggtrace()[[1]])


# Inspect an accumulation of trace dumps

clear_global_ggtrace()
ggtrace(
  GeomBoxplot$draw_group,
  trace_steps = -1,
  once = FALSE,
  verbose = FALSE
)

ggplot(mpg, aes(class, hwy)) + geom_boxplot()

gguntrace(GeomBoxplot$draw_group)

boxplot_group_tracedump <- global_ggtrace()

length(boxplot_group_tracedump)

boxplot_group_tracedump <- unlist(
  boxplot_group_tracedump,
  recursive = FALSE,
  use.names = FALSE
)

patchwork::wrap_plots(boxplot_group_tracedump, nrow = 1)

clear_global_ggtrace()

}
\seealso{
\code{\link[=ggtrace]{ggtrace()}}, \code{\link[=gguntrace]{gguntrace()}}
}
\keyword{internal}
