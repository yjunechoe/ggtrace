% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/workflows-capture.R
\name{ggtrace_capture_fn}
\alias{ggtrace_capture_fn}
\title{Capture a snapshot of a method as a pre-filled function}
\usage{
ggtrace_capture_fn(x, method, cond = 1L)
}
\arguments{
\item{x}{A ggplot object}

\item{method}{A function or a ggproto method.
The ggproto method may be specified using any of the following forms:
\itemize{
\item \code{ggproto$method}
\item \code{namespace::ggproto$method}
\item \code{namespace:::ggproto$method}
}}

\item{cond}{When the method function should be captured. Defaults to \code{1L}.}
}
\value{
A function
}
\description{
Returns a ggproto method as a function with arguments pre-filled to their values when it was first called
}
\note{
For functions and methods that take \code{...}, arguments passed to \code{...} are captured and
promoted to function arguments. The captured values are available for inspection via \code{formals()}.
}
\section{Tracing context}{

When quoted expressions are passed to the \code{cond} or \code{value} argument of
workflow functions they are evaluated in a special environment which
we call the "tracing context".

The tracing context is "data-masked" (see \code{rlang::eval_tidy()}), and exposes
an internal variable called \code{._counter_} which increments every time a
function/method has been called by the ggplot object supplied to the \code{x}
argument of workflow functions. For example, \code{cond = quote(._counter_ == 1L)}
is evaluated as \code{TRUE} when the method is called for the first time. The
\code{cond} argument also supports numeric shorthands like \code{cond = 1L} which evaluates to
\code{quote(._counter_ == 1L)}, and this is the default value of \code{cond} for
all workflow functions that only return one value (e.g., \code{ggtrace_capture_fn()}).
It is recommended to consult the output of \code{ggtrace_inspect_n()} and
\code{ggtrace_inspect_which()} to construct expressions that condition on \code{._counter_}.

For highjack functions like \code{ggtrace_highjack_return()}, the value about to
be returned by the function/method can be accessed with \code{returnValue()} in the
\code{value} argument. By default, \code{value} is set to \code{quote(returnValue())} which
simply evaluates to the return value, but directly computing on \code{returnValue()} to
derive a different return value for the function/method is also possible.
}

\examples{
library(ggplot2)

set.seed(47)
df <- as.data.frame(matrix(sample(5, 1000, TRUE), ncol = 2))
table(df)

base <- ggplot(df, aes(x = V1, y = V2))

p1 <- base + stat_summary(orientation = "x")
p1

p1_compute_panel <- ggtrace_capture_fn(p1, method = StatSummary$compute_panel)

# `p1_compute_panel` is a copy of the ggproto method
body(p1_compute_panel)
ggbody(StatSummary$compute_panel, as.list = FALSE)

# Its arguments are pre-filled (captured at runtime)
sapply(formals(p1_compute_panel), class)

# Runs as it should
p1_compute_panel()

# You can inspect changes to its behavior outisde of ggplot
# For example, see what happens when aes is flipped via `orientation = "y"`
p1_compute_panel(flipped_aes = TRUE)

# We confirm this output to be true when `orientation = "y"` in `stat_summary()`
p2 <- base + stat_summary(orientation = "y")
p2_compute_panel <- ggtrace_capture_fn(p2, method = StatSummary$compute_panel)

identical(p1_compute_panel(flipped_aes = TRUE), p2_compute_panel())

# You can interactively explore with `debugonce(p2_compute_panel)`


# Note that the captured method looks slightly different if the method takes `...`
p3 <- base + stat_smooth() + geom_jitter()
p3

p3_compute_panel <- ggtrace_capture_fn(p3, method = Stat$compute_panel)

# For one, the body is different - it's a "wrapper" around the captured method
body(p3_compute_panel)

# The captured method is stored in the `"inner"` attribute
attr(p3_compute_panel, "inner")

# Captured argument defaults are again available for inspection via `formals()`
# Note that arguments passed to the `...` are promoted to function arguments
names(ggformals(Stat$compute_panel))
names(formals(p3_compute_panel))

# It works the same otherwise - plus you get the benefit of autocomplete
head(p3_compute_panel())
head(p3_compute_panel(level = .99)[, c("ymin", "ymax")])
head(p3_compute_panel(flipped_aes = TRUE))

# Interactively explore with `debugonce(attr(p3_compute_panel, "inner"))`

}
