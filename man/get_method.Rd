% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_method.R
\name{get_method}
\alias{get_method}
\alias{get_method_inheritance}
\alias{ggbody}
\alias{ggformals}
\title{Get information about ggproto methods}
\usage{
get_method(method, inherit = FALSE)

get_method_inheritance(obj, trim_overriden = TRUE)

ggbody(method, inherit = FALSE, as.list = TRUE)

ggformals(method, inherit = FALSE)
}
\arguments{
\item{method}{A function or a ggproto method.
The ggproto method may be specified using any of the following forms:
\itemize{
\item \code{ggproto$method}
\item \code{namespace::ggproto$method}
\item \code{namespace:::ggproto$method}
}}

\item{inherit}{Whether the method should be searched from its closest parent. Defaults to \code{FALSE}.
If \code{TRUE}, returns the parent's method and the corresponding \code{ggbody()} code as a message.}

\item{obj}{A ggproto object}

\item{trim_overriden}{Whether \code{get_method_inheritance} should recursively hide methods defined by a parent.}

\item{as.list}{Whether \code{ggbody()} should return the body of the method as a list. Defaults to \code{TRUE}.}
}
\value{
A list
}
\description{
Get information about ggproto methods
}
\details{
\itemize{
\item \code{get_method()} returns the method.
\item \code{get_method_inheritance()} lists available methods from self and parent ggprotos.
\item \code{ggbody()} returns the body of the method.
\item \code{ggformals()} returns the formals of the method.
}
}
\note{
\code{get_method()} calls \code{get("method", ggproto)} under the hood.
The \code{get("method", ggproto)} syntax is the long form of \code{ggproto$method} which retrieves
the actual function body. This is a subtle but important difference for inspecting ggproto methods.
\itemize{
\item For example, this works: \code{debugonce(get("compute_group", StatCount))}
\item But this fails to insert a break point: \code{debugonce(StatCount$compute_group)}
}

\code{get_method()} was designed so that you do not have to worry about this distinction.
}
\section{Gotchas}{

\itemize{
\item If a method is being traced via \code{ggtrace()} or \code{ggedit()}, \code{get_method()} will return the current \emph{modified state}
of the method. As of v0.3.5, calling \code{get_method()} on a method that has a trace on it will return a warning
to emphasize this fact.
\item When using \code{inherit = TRUE}, make sure that all ggproto objects from \code{class(ggproto)} are available (by loading
the packages where they are defined, for example). Under the hood, \code{get_method()} loops through the parents
to search for the method, so it needs to be able to evaluate each element of \code{class(ggproto)} as an object.
}
}

\examples{
library(ggplot2)

# Uninformative
StatCount$compute_group
formals(StatCount$compute_group)
body(StatCount$compute_group)

# Errors
# get(StatCount$compute_group)

# Informative
get_method(StatCount$compute_group)
ggformals(StatCount$compute_group) # formals(get_method(StatCount$compute_group))
ggbody(StatCount$compute_group)    # body(get_method(StatCount$compute_group))

# Works for ggproto in extension packages

ggbody(ggforce::StatDelaunaySegment$compute_group)

library(ggforce)
ggbody(StatBezier$compute_panel)

# `inherit = TRUE` will return the method from the closest parent

## ERRORS:
## get_method(StatBoxplot$compute_panel)
## ggbody(StatBoxplot$compute_panel)
## ggformals(StatBoxplot$compute_panel)
ggbody(StatBoxplot$compute_panel, inherit = TRUE)
ggbody(Stat$compute_panel)

# Navigating complex inheritance
class(GeomArcBar)
invisible(ggbody(GeomArcBar$default_aes, inherit = TRUE)) # self
invisible(ggbody(GeomArcBar$draw_panel, inherit = TRUE))  # parent
invisible(ggbody(GeomArcBar$draw_key, inherit = TRUE))    # grandparent
invisible(ggbody(GeomArcBar$draw_group, inherit = TRUE))  # top-level

# Getting information about method inheritance all at once
# - default `trim_overriden = TRUE` hides redundant methods defined in parent
get_method_inheritance(GeomArcBar, trim_overriden = TRUE)

# Works for custom ggproto
# - Example from {ggplot2} "Extending ggplot2" vignette
StatDensityCommon <- ggproto("StatDensityCommon", Stat,
  required_aes = "x",

  setup_params = function(data, params) {
    if (!is.null(params$bandwidth))
      return(params)

    xs <- split(data$x, data$group)
    bws <- vapply(xs, bw.nrd0, numeric(1))
    bw <- mean(bws)
    message("Picking bandwidth of ", signif(bw, 3))

    params$bandwidth <- bw
    params
  },

  compute_group = function(data, scales, bandwidth = 1) {
    d <- density(data$x, bw = bandwidth)
    data.frame(x = d$x, y = d$y)
  }
)

as.list(body(get("compute_group", StatDensityCommon)))

ggbody(StatDensityCommon$compute_group)

# As of v.0.4.0, ggbody works for functions as well
ggbody(sample)
ggtrace(sample, 1)
invisible(ggbody(sample))
is_traced(sample)
gguntrace(sample)

}
