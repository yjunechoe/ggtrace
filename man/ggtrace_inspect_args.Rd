% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/workflows-inspect.R, R/aliases.R
\name{ggtrace_inspect_args}
\alias{ggtrace_inspect_args}
\alias{inspect_args}
\title{Inspect the arguments passed into a method}
\usage{
ggtrace_inspect_args(
  x,
  method,
  cond = 1L,
  hoist_dots = TRUE,
  ...,
  error = FALSE
)

inspect_args(x, method, cond = 1L, hoist_dots = TRUE, ..., error = FALSE)
}
\arguments{
\item{x}{A ggplot object}

\item{method}{A function or a ggproto method.
The ggproto method may be specified using any of the following forms:
\itemize{
\item \code{ggproto$method}
\item \code{namespace::ggproto$method}
\item \code{namespace:::ggproto$method}
}}

\item{cond}{When the arguments should be inspected. Defaults to \code{1L}.}

\item{hoist_dots}{Whether treat arguments passed to \code{...} like regular arguments. If \code{FALSE},
the \code{...} is treated as an argument}

\item{...}{Unused.}

\item{error}{If \code{TRUE}, continues inspecting the method until the ggplot errors.
This is useful for debugging but note that it can sometimes return incomplete output.}
}
\value{
A list of argument-value pairs from the \code{method} when it is called.
}
\description{
Inspect the arguments passed into a method
}
\section{Tracing context}{

When quoted expressions are passed to the \code{cond} or \code{value} argument of
workflow functions they are evaluated in a special environment which
we call the "tracing context".

The tracing context is "data-masked" (see \code{rlang::eval_tidy()}), and exposes
an internal variable called \code{._counter_} which increments every time a
function/method has been called by the ggplot object supplied to the \code{x}
argument of workflow functions. For example, \code{cond = quote(._counter_ == 1L)}
is evaluated as \code{TRUE} when the method is called for the first time. The
\code{cond} argument also supports numeric shorthands like \code{cond = 1L} which evaluates to
\code{quote(._counter_ == 1L)}, and this is the default value of \code{cond} for
all workflow functions that only return one value (e.g., \code{ggtrace_capture_fn()}).
It is recommended to consult the output of \code{ggtrace_inspect_n()} and
\code{ggtrace_inspect_which()} to construct expressions that condition on \code{._counter_}.

For highjack functions like \code{ggtrace_highjack_return()}, the value about to
be returned by the function/method can be accessed with \code{returnValue()} in the
\code{value} argument. By default, \code{value} is set to \code{quote(returnValue())} which
simply evaluates to the return value, but directly computing on \code{returnValue()} to
derive a different return value for the function/method is also possible.
}

\examples{

library(ggplot2)

p1 <- ggplot(diamonds, aes(cut)) +
  geom_bar(aes(fill = cut)) +
  facet_wrap(~ clarity)

p1

# Argument value of `Stat$compute_panel` for the first panel
compute_panel_args_1 <- ggtrace_inspect_args(x = p1, method = Stat$compute_panel)
names(ggformals(Stat$compute_panel))
names(compute_panel_args_1)
table(compute_panel_args_1$data$fill)

# `hoist_dots` preserves information about which arguments were passed to `...`
with_dots <- ggtrace_inspect_args(p1, Stat$compute_panel, hoist_dots = FALSE)
names(with_dots)
with_dots$`...`

}
