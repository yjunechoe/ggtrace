% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggtrace.R
\name{ggtrace}
\alias{ggtrace}
\title{Programmatically debug ggproto methods with trace}
\usage{
ggtrace(method, trace_steps, trace_exprs, once = TRUE, .print = TRUE)
}
\arguments{
\item{method}{An expression that evaluates to the ggproto method.
This may be specified using any of the following forms:\preformatted{- `ggproto$method`

- `namespace::ggproto$method`

- `namespace:::ggproto$method`
}}

\item{trace_steps}{A list of positions in the method's body to trace. Negative indices
reference steps from the last, where \code{-1} references the last step in the body.}

\item{trace_exprs}{A list of expressions to evaluate at each position specified
in \code{trace_steps}. If a single expression is provided, it is recycled.

To simply run a step and return its output, you can use the \code{~step} keyword. If the step
assigns a value to a local variable, the value of that local variable is returned.

If \code{trace_exprs} is not provided, \code{ggtrace()} is called with \code{~step} by default.}

\item{once}{Whether to \code{untrace()} itself on exit. Defaults to \code{TRUE}.}

\item{.print}{Whether to print the output of each expression to the console. Defaults to \code{TRUE}.}
}
\description{
Programmatically debug ggproto methods with trace
}
\details{
\code{ggtrace()} is a wrapper around \code{base::trace()} which is called on the ggproto method.
It calls \code{base::untrace()} on itself on exit by default, to make its effect ephemeral (like \code{base::debugonce()}).
A major feature is the ability to pass multiple positions and expressions to \code{trace_steps} and \code{trace_exprs} to
inspect, debug, and modify the run time environment of ggproto methods. It is recommended to consult the output
of \code{ggbody()} when deciding which expressions to evaluate at which steps.

The output of the expressions passed to \code{trace_exprs} is printed while tracing takes place. The
list of outputs from the last \code{ggtrace()} can be returned for further inspection with \code{last_ggtrace()}.
}
\section{Tips & Tricks}{

\itemize{
\item If the intent is to run complex calculations, it is recommended to use \code{ggtrace()} to simply return the method's
run time environment with \code{trace_exprs = quote(environment())}. The returned environment is the method's execution
environment which also contextualizes the \code{self} object in addition to making all local variables available. This
allows for more complex explorations outside of the debugger, and is also recommended for safety reasons.
\item To modify the behavior of a method as it runs, you can pass in an expression that make assignments. For example,
\code{trace_steps = c(1, 10)} with \code{rlang::exprs(a <- 5, a)} will first assign a new variable \code{a} at step 1, and then
return its value \code{5} at step 10. This can also be used to modify important variables like \verb{quote(data <- <expr>)}.
Note that this only in effect while the method is being traced. For making any arbitrary modifications to the code,
see \code{\link[=ggedit]{ggedit()}}).
}
}

\section{Gotchas}{

\itemize{
\item If you wrap a ggplot in \code{invisible()} to silence \code{ggtrace()}, the plot will not build, which also means that
the tracing is not triggered. This is because the print/plot method of ggplot is what triggers the evaluation
of the plot code. It is recommended to allow \code{ggtrace()} to print messages, but if you'd really like to silence
it, you can do so by wrapping the plot in \verb{invisible(capture.output(<plot_object>))}.
\item If for any reason \code{ggtrace(once = TRUE)} fails to untrace itself on exit, you may accidentally trigger
the tracing again. To check if a method is being traced, call \code{ggbody()} on it and inspect its body. If you
see \code{.doTrace()} scattered around the body, that's a sign the method is still being traced. You can also always
\code{gguntrace()} any number of times without adverse consequences.
\item Environments are mutable, which means that returning \code{environment()} at different steps in the body will still
reference the same run time environment. To get a snapshot of the method's environment at a particular step,
it is recommended to use \code{rlang::env_clone(environment())} instead, which makes a deep copy.
\itemize{
\item Note that the execution environment is created anew each time the method is ran, so modifying the
environment from its previous execution will not affect future calls to the method, even with \code{once = FALSE}.
\item Because \code{base::trace()} wraps the method body in a special environment, it is not possible to inspect the
higher method which called it, even with something like \code{rlang::caller_env()}. You will traverse through
a few enclosing environments created by \code{base::trace()} which eventually ends up looping around.
}
}
}

\examples{
\dontrun{
library(ggplot2)

p <- ggplot(diamonds[1:1000,], aes(cut, depth)) +
  geom_point(position = position_jitter(width = 0.2, seed = 2021))
p

ggbody(PositionJitter$compute_layer)

## Example 1 ====
## Inspect what `data` look like at the start of the function
ggtrace(PositionJitter$compute_layer, trace_steps = 1, trace_exprs = quote(head(data)))
p

## Example 2 ====
## What does `data` look like at the end of the method? Unfortunately, `trace()` only lets us enter
## at the beginning of a step, so we can't inspect what happens after the last step is evaluated. To
## address this, `ggtrace()` offers a `~step` keyword which gets substituted for the current line.
## We also set `.print = FALSE` to disable printing of the output
ggtrace(
  PositionJitter$compute_layer,
  trace_steps = 12,
  trace_exprs = quote(~step), # This the default if `trace_exprs` is not provided
  .print = FALSE
)
p

## Example 3 ====
## If we want both to be returned at the same time for an easier comparison, we can pass in a list
## of expressions. We use `rlang::exprs()` here to conveniently construct a list of expressions.
ggtrace(
  PositionJitter$compute_layer,
  trace_steps = c(1, 12),
  trace_exprs = rlang::exprs(data, ~step),
  .print = FALSE
)
p

## Example 4 ====
## The output of the evaluated expressions can be inspected with `last_ggtrace()`
jitter_tracedump <- last_ggtrace()
lapply(jitter_tracedump, head)
hist(jitter_tracedump[[1]]$x - jitter_tracedump[[2]]$x)
}
}
\seealso{
\code{\link[=last_ggtrace]{last_ggtrace()}}, \code{\link[=gguntrace]{gguntrace()}}
}
