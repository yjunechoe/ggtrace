% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggtrace.R
\name{ggtrace}
\alias{ggtrace}
\title{Programmatically debug ggproto methods with trace}
\usage{
ggtrace(method, obj, trace_steps, trace_exprs, once = TRUE, .print = TRUE)
}
\arguments{
\item{method}{The method name as a string. Alternatively an expression
that evaluates to the ggproto method in the form of \code{ggproto$method}.}

\item{obj}{The ggproto object. Can be omitted if the method is an expression
in the form of \code{ggproto$method} that evalutes to the ggproto object's method.}

\item{trace_steps}{A list of positions in the method's callstack to trace.}

\item{trace_exprs}{A list of expressions to evaluate at each position specified
in \code{trace_steps}. If a single expression is provided, it is recycled.

To simply run a step and return its output, you can use the \code{~step} keyword. If the step
assigns a value to a local variable, the value of that local variable is returned.}

\item{once}{Whether to \code{untrace()} itself on exit. Defaults to \code{TRUE}.}

\item{.print}{Whether to print the output of each expression to the console. Defaults to \code{TRUE}.}
}
\description{
Programmatically debug ggproto methods with trace
}
\details{
\code{ggtrace()} is a wrapper around \code{base::trace()} which is called on the ggproto method.
It calls \code{base::untrace()} on itself on exit by default, to make its effect ephemeral (like \code{base::debugonce()}).
A major feature is the ability to pass multiple positions and expressions to \code{trace_steps} and \code{trace_exprs}.
It is recommended to consult the output of \code{ggbody()} when deciding which expressions to evaluate at which steps.

The output of the expressions passed to \code{trace_exprs} is printed while tracing takes place. The last \code{ggtrace()}
trace dump is available for further inspection with \code{last_ggtrace()}.
}
\examples{
\dontrun{
library(ggplot2)

p <- ggplot(diamonds[1:1000,], aes(cut, depth)) +
  geom_point(position = position_jitter(width = 0.2, seed = 2021))
p

ggbody(PositionJitter$compute_layer)

## Example 1 ====
## Inspect what `data` look like at the start of the function
ggtrace(PositionJitter$compute_layer, trace_steps = 1, trace_exprs = quote(head(data)))
p

## Example 2 ====
## What does `data` look like at the end of the method? Unfortunately, `trace()` only lets us enter
## at the beginning of a step, so we can't inspect what happens after the last step is evaluated. To
## address this, `ggtrace()` offers a `~list` keyword which gets substituted for the current line.
## We also set `.print = FALSE` to disable printing of the output
ggtrace(
  PositionJitter$compute_layer,
  trace_steps = 12,
  trace_exprs = quote(~step),
  .print = FALSE
)
p

## Example 3 ====
## If we want both to be returned at the same time for an easier comparison, we can pass in a list
## of expressions. We use `rlang::exprs()` here to conveniently construct a list of expressions.
ggtrace(
  PositionJitter$compute_layer,
  trace_steps = c(1, 12),
  trace_exprs = rlang::exprs(data, ~step),
  .print = FALSE
)
p

## Example 4 ====
## The output of the evaluated expressions can be inspected with `last_ggtrace()`
jitter_tracedump <- last_ggtrace()
lapply(jitter_tracedump, head)
hist(jitter_tracedump[[1]]$x - jitter_tracedump[[2]]$x)
}
}
