% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggedit.R
\name{ggedit}
\alias{ggedit}
\title{Interactively edit a masking copy of the source code}
\usage{
ggedit(method, remove_trace = FALSE, ...)
}
\arguments{
\item{method}{A function or a ggproto method.
The ggproto method may be specified using any of the following forms:
\itemize{
\item \code{ggproto$method}
\item \code{namespace::ggproto$method}
\item \code{namespace:::ggproto$method}
}}

\item{remove_trace}{Whether to edit from a clean slate. Defaults to \code{FALSE}.}

\item{...}{Unused, for extensibility.}
}
\description{
Interactively edit a masking copy of the source code
}
\details{
Like \code{base::trace()}, the edit is in effect until \code{gguntrace()} is called.
Changes with \code{ggedit()} are cumulative, so \code{ggedit()} will inform you via a warning
if you're making an edit on top of an existing edit. Call \code{gguntrace()} on the object
first if you'd like to edit the method's original unaltered source code.

Only works in interactive contexts.
}
\section{Gotchas}{

\itemize{
\item Calling \code{ggtrace()} on an method that that has changes from \code{ggedit()} will remove the
changes from \code{ggedit()}. It \emph{is} possible to combine both features, but disabled in
the package to keep the API consistent. It is against the philosophy of \code{{ggtrace}} to
mix programmatic and interactive workflows.
}
}

\examples{
\dontrun{

jitter_plot <- ggplot(diamonds[1:1000,], aes(cut, depth)) +
  geom_point(position = position_jitter(width = 0.2, seed = 2021))

# Interactively modify the method's source code in text editor
ggedit(Position$compute_layer)

# Check the edited code
ggbody(Position$compute_layer)

# Execute method with edit
jitter_plot

# Untrace
gguntrace(Position$compute_layer)

# Edit is removed in the next call
jitter_plot

}
}
\seealso{
\code{\link[=gguntrace]{gguntrace()}}, \code{\link[=is_traced]{is_traced()}}
}
