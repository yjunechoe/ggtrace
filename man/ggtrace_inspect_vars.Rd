% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/workflows-inspect.R, R/aliases.R
\name{ggtrace_inspect_vars}
\alias{ggtrace_inspect_vars}
\alias{inspect_vars}
\title{Inspect the value of variables from a method}
\usage{
ggtrace_inspect_vars(
  x,
  method,
  cond = 1L,
  at = "all",
  vars,
  by_var = TRUE,
  ...,
  error = FALSE
)

inspect_vars(
  x,
  method,
  cond = 1L,
  at = "all",
  vars,
  by_var = TRUE,
  ...,
  error = FALSE
)
}
\arguments{
\item{x}{A ggplot object}

\item{method}{A function or a ggproto method.
The ggproto method may be specified using any of the following forms:
\itemize{
\item \code{ggproto$method}
\item \code{namespace::ggproto$method}
\item \code{namespace:::ggproto$method}
}}

\item{cond}{When the return value should be inspected. Defaults to \code{1L}.}

\item{at}{Which steps in the method body the values of \code{vars} should be retrieved.
Defaults to a special value \code{all} which is evaluated to all steps in the method body.}

\item{vars}{A character vector of variable names}

\item{by_var}{Boolean that controls the format of the output:
\itemize{
\item \code{TRUE} (default): returns a list of variables, with their values at each step. This
also drops steps within a variable where the variable value has not changed from a previous
step specified by \code{at}.
\item \code{FALSE}: returns a list of steps, where each element holds the value of \code{vars}
at each step of \code{at}. Unchanged variable values are not dropped.
}}

\item{...}{Unused.}

\item{error}{If \code{TRUE}, continues inspecting the method until the ggplot errors.
This is useful for debugging but note that it can sometimes return incomplete output.}
}
\value{
A list of values of \code{vars} at each step \code{at}. Simplifies if \code{vars} and/or \code{at} is length-1.
}
\description{
Inspect the value of variables from a method
}
\section{Tracing context}{

When quoted expressions are passed to the \code{cond} or \code{value} argument of
workflow functions they are evaluated in a special environment which
we call the "tracing context".

The tracing context is "data-masked" (see \code{rlang::eval_tidy()}), and exposes
an internal variable called \code{._counter_} which increments every time a
function/method has been called by the ggplot object supplied to the \code{x}
argument of workflow functions. For example, \code{cond = quote(._counter_ == 1L)}
is evaluated as \code{TRUE} when the method is called for the first time. The
\code{cond} argument also supports numeric shorthands like \code{cond = 1L} which evaluates to
\code{quote(._counter_ == 1L)}, and this is the default value of \code{cond} for
all workflow functions that only return one value (e.g., \code{ggtrace_capture_fn()}).
It is recommended to consult the output of \code{ggtrace_inspect_n()} and
\code{ggtrace_inspect_which()} to construct expressions that condition on \code{._counter_}.

For highjack functions like \code{ggtrace_highjack_return()}, the value about to
be returned by the function/method can be accessed with \code{returnValue()} in the
\code{value} argument. By default, \code{value} is set to \code{quote(returnValue())} which
simply evaluates to the return value, but directly computing on \code{returnValue()} to
derive a different return value for the function/method is also possible.
}

\examples{

library(ggplot2)

p1 <- ggplot(mtcars[1:10,], aes(mpg, hp)) +
  geom_smooth()
p1

# The `data` variable is bound to two unique values in `compute_group` method:
ggtrace_inspect_vars(p1, StatSmooth$compute_group, vars = "data")

# Note that elements of this list capture the method's state upon entering a step,
# so "Step1" and "Step5" should be interpreted as the value of `data` at the start
# the method's execution (before "Step1") and its value as a result of running Step4
# (before "Step5"). Indeed, we see that the `weight` column is defined in Step4, so
# the data is flagged as changed at the start of Step5
ggbody(StatSmooth$compute_group)[[4]]


# Comparing the "Steps" themselves can be useful
p2 <- p1 +
  scale_x_continuous(trans = "log") +
  scale_y_continuous(trans = "log")
p2

# Comparing the original plot to one with log-transformed scales reveals a change
# in data detected at the beginning of Step 14
names(ggtrace_inspect_vars(p1, ggplot2:::ggplot_build.ggplot, vars = "data"))
names(ggtrace_inspect_vars(p2, ggplot2:::ggplot_build.ggplot, vars = "data"))

# We can pinpoint the calculation of scale transformations to Step 13:
ggbody(ggplot2:::ggplot_build.ggplot)[[13]]


# With `by_vars = FALSE`, elements of the returned list are steps instead of values.
# Note that this does not drop unchanged values:
ggtrace_inspect_vars(p1, StatSmooth$compute_group, vars = "data", at = 1:6, by_var = FALSE)


}
