% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/workflows-capture.R
\name{ggtrace_capture_env}
\alias{ggtrace_capture_env}
\title{Capture a snapshot of a method's execution environment}
\usage{
ggtrace_capture_env(x, method, cond = quote(._counter_ == 1), at = -1L)
}
\arguments{
\item{x}{A ggplot object}

\item{method}{A function or a ggproto method.
The ggproto method may be specified using any of the following forms:
\itemize{
\item \code{ggproto$method}
\item \code{namespace::ggproto$method}
\item \code{namespace:::ggproto$method}
}}

\item{cond}{When the method environment should be captured. Defaults to \code{quote(._counter_ == 1L)}.}

\item{at}{Which step of the method body the environment should be captured.
See \code{ggbody()} for a list of expressions/steps in the method body.}
}
\value{
An environment
}
\description{
Capture a snapshot of a method's execution environment
}
\section{Tracing context}{

When quoted expressions are passed to the \code{cond} or \code{value} argument of
workflow functions (in the form of \verb{ggtrace_\{action\}_\{value\}()}), they are
evaluated in a special environment which we call the "tracing context".

The tracing context is "data-masked" (see \code{rlang::eval_tidy()}), and exposes
an internal variable called \code{._counter_} (\code{.data$._counter_}) which tracks how
many times a function/method has been called by the ggplot object supplied to
the \code{x} argument of workflow functions. For example, \code{cond = quote(._counter_ == 1)}
is evaluated as \code{TRUE} when the method is called for the first time, and
this is the default value of \code{cond} for workflow functions that only return
one value (e.g., \code{ggtrace_capture_fn()}).

For highjack functions like \code{ggtrace_highjack_return()}, the value about to
be returned by the function/method can be accessed with \code{returnValue()} in the
\code{value} argument. By default, \code{value} is set to \code{quote(returnValue())} which
simply evaluates to the return value, but directly computing on \code{returnValue()} to
derive a different return value for the function/method is also possible.
}

\examples{
library(ggplot2)

# Example from https://ggplot2.tidyverse.org/reference/aes_eval.html
after_scale_plot <- ggplot(mpg, aes(class, hwy)) +
  geom_boxplot(aes(colour = class, fill = after_scale(alpha(colour, 0.4))))
after_scale_plot

# `after_scale()` is resolved by `Geom$use_defaults` (at Step 6)

before_applying <- ggtrace_capture_env(
  x = after_scale_plot,
  method = Geom$use_defaults,
  at = 1  # To be more specific, do `at = 6`
)
after_applying <- ggtrace_capture_env(
  x = after_scale_plot,
  method = Geom$use_defaults,
  at = -1  # To be more specific, do `at = 7`
)

colnames(before_applying$data)
colnames(after_applying$data)

library(dplyr)

before_applying$data \%>\%
  select(any_of(c("colour", "fill")))
after_applying$data \%>\%
  select(any_of(c("colour", "fill")))

identical(
  before_applying$data \%>\%
    select(any_of(c("colour", "fill"))) \%>\%
    mutate(fill = alpha(colour, 0.4)),       #< after_scale() logic here
  after_applying$data \%>\%
    select(any_of(c("colour", "fill")))
)


# Using the captured environment for further evaluation
ggbody(Geom$draw_panel)

by_group_drawing_code <- rlang::call_args(ggbody(Geom$draw_panel)[[3]])[[2]]
by_group_drawing_code

draw_panel_env <- ggtrace_capture_env(
  x = after_scale_plot,
  method = Geom$draw_panel
)
draw_panel_env

boxes <- eval(by_group_drawing_code, draw_panel_env)

library(grid)
grid.newpage()
grid.draw(editGrob(boxes[[1]], vp = viewport()))

}
