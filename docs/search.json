[{"path":"/articles/casestudy-after_scale.html","id":"motivating-thing","dir":"Articles","previous_headings":"","what":"Motivating thing","title":"Case Study: inspecting aes evaluation with `after_scale()`","text":"vignette starts question - happens ggplot internals something? Often times can make inferences surface form, surface form shares thing? ’ve hit roadblock traditional tools users, develop mental models. vignette shows can test hypotheses competing (mental) models ggplot internals make predictions (.e., plots “look” ). Going approach like scientific endeavor - fancy way saying kind trial--error way self-learning many useRs comfortable ","code":""},{"path":"/articles/casestudy-after_scale.html","id":"the-research-question","dir":"Articles","previous_headings":"","what":"The research question","title":"Case Study: inspecting aes evaluation with `after_scale()`","text":"know can map variable aesthetic. – plot also know taht can grab mapped aesthetics statistical transofmration scaling applied, after_stat() after_scale() respectivelyt. – plots also know can override aes constant supplied directly aes. (2-layer plot global aes inheritance)","code":""},{"path":"/articles/casestudy-after_scale.html","id":"under-construction","dir":"Articles","previous_headings":"","what":"Under construction","title":"Case Study: inspecting aes evaluation with `after_scale()`","text":"Slides ggplot internals / {ggtrace} talk December 4th 2021: https://yjunechoe.github.io/ggtrace-talk","code":"library(ggtrace)"},{"path":"/articles/casestudy-ggxmean.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Debugging an extension package","text":"like follow along, can install version {ggxmean} package containing bug vignette address. use devtools::dev_mode() install inspect version {ggxmean} development mode (except skip installation already version dev directory). ’ve also attached code relevant issue hand , like familiarize begin (though assume prior knowledge ).","code":"library(ggtrace) library(ggplot2) theme_set(theme_minimal()) library(devtools) #> Loading required package: usethis  # Current installation version devtools::package_info(\"ggxmean\", FALSE, FALSE)$source #> [1] \"local\"  # Activate development mode devtools::dev_mode(on = TRUE, path = getOption(\"devtools.path\")) #> v Dev mode: ON  # devtools::install_github(\"EvaMaeRey/ggxmean@cbb909c\")  # Prior version installed for dev mode devtools::package_info(\"ggxmean\", FALSE, FALSE)$source #> [1] \"Github (EvaMaeRey/ggxmean@cbb909c)\"  library(ggxmean) # https://github.com/EvaMaeRey/ggxmean/blob/cbb909cee7d4f0a4395722020a75330641e5f54c/R/geom_x_line.R  GeomXline <- ggplot2::ggproto(\"GeomXline\", ggplot2::Geom,                      draw_panel = function(data, panel_params, coord) {                        ranges <- coord$backtransform_range(panel_params)                        data$x    <- data$x                        data$xend <- data$x                        data$y    <- ranges$y[1]                        data$yend <- ranges$y[2]                        GeomSegment$draw_panel(unique(data), panel_params, coord)                      },                      default_aes = ggplot2::aes(colour = \"black\", size = 0.5,                                        linetype = 1, alpha = NA),                      required_aes = \"x\",                      draw_key = ggplot2::draw_key_vline )  # https://github.com/EvaMaeRey/ggxmean/blob/cbb909cee7d4f0a4395722020a75330641e5f54c/R/geom_x_mean.R StatXmean <- ggplot2::ggproto(\"StatXmean\",                               ggplot2::Stat,                               compute_group = function(data, scales) {                                 data.frame(x = mean(data$x))                               },                               required_aes = c(\"x\") )  geom_x_mean <- function(mapping = NULL, data = NULL,                         position = \"identity\", na.rm = FALSE, show.legend = NA,                         inherit.aes = TRUE, ...) {   ggplot2::layer(     stat = StatXmean, geom = GeomXline, data = data, mapping = mapping,     position = position, show.legend = show.legend, inherit.aes = inherit.aes,     params = list(na.rm = na.rm, ...)   ) }"},{"path":"/articles/casestudy-ggxmean.html","id":"introduction-of-the-issue","dir":"Articles","previous_headings":"","what":"Introduction of the issue","title":"Debugging an extension package","text":"{ggxmean} {ggplot2} extension package offers many features, including layer geom_x_mean() can used draw line mean value variable represented x-axis.  geom_x_mean() works smoothly groups facets, might expect experience ggplot.  However, something somewhat unexpected happens pass map discrete variable aesthetic understandable geom_x_mean(). Despite fact lines understand fill aesthetic, aesthetic mapping fill = drv nevertheless highjacks calculation grouping geom_x_mean().","code":"ggplot(mpg, aes(x = hwy)) +   geom_histogram() +   geom_x_mean() #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(mpg, aes(x = hwy, group = drv)) +   geom_histogram() +   geom_x_mean() +   facet_wrap(~drv) #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(mpg, aes(x = hwy, fill = drv)) +   geom_histogram() +   geom_x_mean() #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`."},{"path":"/articles/casestudy-ggxmean.html","id":"making-a-reprex","dir":"Articles","previous_headings":"Introduction of the issue","what":"Making a reprex","title":"Debugging an extension package","text":"isolate problem, let’s remove geom_histogram() examples. minimal reprex (reproducible example) issue:  can pinpoint formalize issue help layer_data(). see expected group = drv unexpected fill = drv cases, end three unique groups (lines) indicated values group column.","code":"ggplot(mpg) +   aes(x = hwy, fill = drv) +   geom_x_mean() p <- ggplot(mpg) +   aes(x = hwy) +   geom_x_mean() layer_data(p + aes(group = drv)) #>          x group PANEL colour size linetype alpha #> 1 19.17476     1     1  black  0.5        1    NA #> 2 28.16038     2     1  black  0.5        1    NA #> 3 21.00000     3     1  black  0.5        1    NA layer_data(p + aes(fill = drv)) #>      fill        x PANEL group colour size linetype alpha #> 1 #F8766D 19.17476     1     1  black  0.5        1    NA #> 2 #00BA38 28.16038     1     2  black  0.5        1    NA #> 3 #619CFF 21.00000     1     3  black  0.5        1    NA"},{"path":"/articles/casestudy-ggxmean.html","id":"expected-cases","dir":"Articles","previous_headings":"Introduction of the issue","what":"Expected cases","title":"Debugging an extension package","text":", correctly get groups category drv lines understand color aesthetic.  also correctly get groups category drv set group aesthetic explicitly.","code":"p + aes(color = drv) layer_data(p + aes(color = drv))$group #> [1] 1 2 3 p + aes(group = drv) layer_data(p + aes(group = drv))$group #> [1] 1 2 3"},{"path":"/articles/casestudy-ggxmean.html","id":"unexpected-cases","dir":"Articles","previous_headings":"Introduction of the issue","what":"Unexpected cases","title":"Debugging an extension package","text":", ’d like 1 group/line lines don’t understand shape aesthetic  , ’d like 3 groups drv mapped color. Categories fl variable interact drv creation groups lines don’t understand fill aesthetic.","code":"p + aes(shape = drv) layer_data(p + aes(shape = drv))$group #> [1] 1 2 3 p + aes(fill = fl, color = drv) layer_data(p + aes(fill = fl, color = drv))$group #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12"},{"path":[]},{"path":[]},{"path":"/articles/casestudy-ggxmean.html","id":"starting-at-ggplot_build","dir":"Articles","previous_headings":"Step 1 - Locating the problem","what":"1.1 Starting at ggplot_build()","title":"Debugging an extension package","text":"first step, let’s see groups calculated added data inspecting ggplot_build(), main engine behind ggplot. exploratory debugging ggplot internals, inspecting data transformation pipeline ggplot_build() often best place start. first exposure ggplot_build(), just need know output basically ’s returned layer_data() function demoed . use ggbody() function {ggtrace} grab body ggplot_build() list, , metaprogramming rlang, pick steps data gets transformed. Note syntax ggplot2:::ggplot_build.ggplot reflects fact ggplot_build() S3 generic defined class <<ggplot>>. can inspect source code ggplot_build() ggplot2 Github repo, output ggbody(ggplot2:::ggplot_build.ggplot) also available : data transformation step (steps + 1L), let’s log data first () layer reprex plot. , tracedump1 list data looked like data-transformation step inside ggplot_build(). ’s list data frames ’s lot , ’s looks like ’s cleaned tibble::as_tibble() can now map every element list see group column first present. Step 12 ggplot_build() group first appears. suspect ’s group computed assigned code Step 12 ggplot_build() calls compute_aesthetics method layer l. by_layer() function defined Step 7 ggplot_build() ’s .","code":"layer_data #> function (plot, i = 1L)  #> { #>     ggplot_build(plot)$data[[i]] #> } #> <bytecode: 0x00000000348f33d0> #> <environment: namespace:ggplot2> build_pipeline <- ggbody(ggplot2:::ggplot_build.ggplot) data_assigns <- sapply(build_pipeline,   function(x) {     rlang::is_call(x) &&       !is.null(rlang::call_name(x)) &&        rlang::call_name(x) == \"<-\" &&       rlang::call_args(x)[[1]] == \"data\"   } ) which(data_assigns) # Steps of the build pipeline where data is transformed #>  [1]  8  9 11 12 13 17 18 19 21 22 26 29 30 31 ggbody(ggplot2:::ggplot_build.ggplot) #> [[1]] #> `{` #>  #> [[2]] #> plot <- plot_clone(plot) #>  #> [[3]] #> if (length(plot$layers) == 0) { #>     plot <- plot + geom_blank() #> } #>  #> [[4]] #> layers <- plot$layers #>  #> [[5]] #> layer_data <- lapply(layers, function(y) y$layer_data(plot$data)) #>  #> [[6]] #> scales <- plot$scales #>  #> [[7]] #> by_layer <- function(f) { #>     out <- vector(\"list\", length(data)) #>     for (i in seq_along(data)) { #>         out[[i]] <- f(l = layers[[i]], d = data[[i]]) #>     } #>     out #> } #>  #> [[8]] #> data <- layer_data #>  #> [[9]] #> data <- by_layer(function(l, d) l$setup_layer(d, plot)) #>  #> [[10]] #> layout <- create_layout(plot$facet, plot$coordinates) #>  #> [[11]] #> data <- layout$setup(data, plot$data, plot$plot_env) #>  #> [[12]] #> data <- by_layer(function(l, d) l$compute_aesthetics(d, plot)) #>  #> [[13]] #> data <- lapply(data, scales_transform_df, scales = scales) #>  #> [[14]] #> scale_x <- function() scales$get_scales(\"x\") #>  #> [[15]] #> scale_y <- function() scales$get_scales(\"y\") #>  #> [[16]] #> layout$train_position(data, scale_x(), scale_y()) #>  #> [[17]] #> data <- layout$map_position(data) #>  #> [[18]] #> data <- by_layer(function(l, d) l$compute_statistic(d, layout)) #>  #> [[19]] #> data <- by_layer(function(l, d) l$map_statistic(d, plot)) #>  #> [[20]] #> scales_add_missing(plot, c(\"x\", \"y\"), plot$plot_env) #>  #> [[21]] #> data <- by_layer(function(l, d) l$compute_geom_1(d)) #>  #> [[22]] #> data <- by_layer(function(l, d) l$compute_position(d, layout)) #>  #> [[23]] #> layout$reset_scales() #>  #> [[24]] #> layout$train_position(data, scale_x(), scale_y()) #>  #> [[25]] #> layout$setup_panel_params() #>  #> [[26]] #> data <- layout$map_position(data) #>  #> [[27]] #> npscales <- scales$non_position_scales() #>  #> [[28]] #> if (npscales$n() > 0) { #>     lapply(data, scales_train_df, scales = npscales) #>     data <- lapply(data, scales_map_df, scales = npscales) #> } #>  #> [[29]] #> data <- by_layer(function(l, d) l$compute_geom_2(d)) #>  #> [[30]] #> data <- by_layer(function(l, d) l$finish_statistics(d)) #>  #> [[31]] #> data <- layout$finish_data(data) #>  #> [[32]] #> plot$labels$alt <- get_alt_text(plot) #>  #> [[33]] #> structure(list(data = data, layout = layout, plot = plot), class = \"ggplot_built\") ggtrace(   method = ggplot2:::ggplot_build.ggplot,   trace_steps = which(data_assigns) + 1, # After each data transformation step ...   trace_exprs = quote(data[[1]]),        # ... return the data for the first layer   verbose = FALSE ) #> `ggplot2:::ggplot_build.ggplot` now being traced.  # plot not printed for space p + aes(fill = drv) #> Triggering trace on `ggplot2:::ggplot_build.ggplot` #> Untracing `ggplot2:::ggplot_build.ggplot` on exit.  tracedump1 <- last_ggtrace() lapply(tracedump1, tibble::as_tibble) #> [[1]] #> # A tibble: 234 x 11 #>    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class #>    <chr>        <chr>      <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> #>  1 audi         a4           1.8  1999     4 auto~ f        18    29 p     comp~ #>  2 audi         a4           1.8  1999     4 manu~ f        21    29 p     comp~ #>  3 audi         a4           2    2008     4 manu~ f        20    31 p     comp~ #>  4 audi         a4           2    2008     4 auto~ f        21    30 p     comp~ #>  5 audi         a4           2.8  1999     6 auto~ f        16    26 p     comp~ #>  6 audi         a4           2.8  1999     6 manu~ f        18    26 p     comp~ #>  7 audi         a4           3.1  2008     6 auto~ f        18    27 p     comp~ #>  8 audi         a4 quattro   1.8  1999     4 manu~ 4        18    26 p     comp~ #>  9 audi         a4 quattro   1.8  1999     4 auto~ 4        16    25 p     comp~ #> 10 audi         a4 quattro   2    2008     4 manu~ 4        20    28 p     comp~ #> # ... with 224 more rows #>  #> [[2]] #> # A tibble: 234 x 11 #>    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class #>    <chr>        <chr>      <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> #>  1 audi         a4           1.8  1999     4 auto~ f        18    29 p     comp~ #>  2 audi         a4           1.8  1999     4 manu~ f        21    29 p     comp~ #>  3 audi         a4           2    2008     4 manu~ f        20    31 p     comp~ #>  4 audi         a4           2    2008     4 auto~ f        21    30 p     comp~ #>  5 audi         a4           2.8  1999     6 auto~ f        16    26 p     comp~ #>  6 audi         a4           2.8  1999     6 manu~ f        18    26 p     comp~ #>  7 audi         a4           3.1  2008     6 auto~ f        18    27 p     comp~ #>  8 audi         a4 quattro   1.8  1999     4 manu~ 4        18    26 p     comp~ #>  9 audi         a4 quattro   1.8  1999     4 auto~ 4        16    25 p     comp~ #> 10 audi         a4 quattro   2    2008     4 manu~ 4        20    28 p     comp~ #> # ... with 224 more rows #>  #> [[3]] #> # A tibble: 234 x 12 #>    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class #>    <chr>        <chr>      <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> #>  1 audi         a4           1.8  1999     4 auto~ f        18    29 p     comp~ #>  2 audi         a4           1.8  1999     4 manu~ f        21    29 p     comp~ #>  3 audi         a4           2    2008     4 manu~ f        20    31 p     comp~ #>  4 audi         a4           2    2008     4 auto~ f        21    30 p     comp~ #>  5 audi         a4           2.8  1999     6 auto~ f        16    26 p     comp~ #>  6 audi         a4           2.8  1999     6 manu~ f        18    26 p     comp~ #>  7 audi         a4           3.1  2008     6 auto~ f        18    27 p     comp~ #>  8 audi         a4 quattro   1.8  1999     4 manu~ 4        18    26 p     comp~ #>  9 audi         a4 quattro   1.8  1999     4 auto~ 4        16    25 p     comp~ #> 10 audi         a4 quattro   2    2008     4 manu~ 4        20    28 p     comp~ #> # ... with 224 more rows, and 1 more variable: PANEL <fct> #>  #> [[4]] #> # A tibble: 234 x 4 #>    fill      x PANEL group #>    <chr> <int> <fct> <int> #>  1 f        29 1         2 #>  2 f        29 1         2 #>  3 f        31 1         2 #>  4 f        30 1         2 #>  5 f        26 1         2 #>  6 f        26 1         2 #>  7 f        27 1         2 #>  8 4        26 1         1 #>  9 4        25 1         1 #> 10 4        28 1         1 #> # ... with 224 more rows #>  #> [[5]] #> # A tibble: 234 x 4 #>    fill      x PANEL group #>    <chr> <int> <fct> <int> #>  1 f        29 1         2 #>  2 f        29 1         2 #>  3 f        31 1         2 #>  4 f        30 1         2 #>  5 f        26 1         2 #>  6 f        26 1         2 #>  7 f        27 1         2 #>  8 4        26 1         1 #>  9 4        25 1         1 #> 10 4        28 1         1 #> # ... with 224 more rows #>  #> [[6]] #> # A tibble: 234 x 4 #>    fill      x PANEL group #>    <chr> <dbl> <fct> <int> #>  1 f        29 1         2 #>  2 f        29 1         2 #>  3 f        31 1         2 #>  4 f        30 1         2 #>  5 f        26 1         2 #>  6 f        26 1         2 #>  7 f        27 1         2 #>  8 4        26 1         1 #>  9 4        25 1         1 #> 10 4        28 1         1 #> # ... with 224 more rows #>  #> [[7]] #> # A tibble: 3 x 4 #>       x fill  PANEL group #>   <dbl> <chr> <fct> <int> #> 1  19.2 4     1         1 #> 2  28.2 f     1         2 #> 3  21   r     1         3 #>  #> [[8]] #> # A tibble: 3 x 4 #>       x fill  PANEL group #>   <dbl> <chr> <fct> <int> #> 1  19.2 4     1         1 #> 2  28.2 f     1         2 #> 3  21   r     1         3 #>  #> [[9]] #> # A tibble: 3 x 4 #>       x fill  PANEL group #>   <dbl> <chr> <fct> <int> #> 1  19.2 4     1         1 #> 2  28.2 f     1         2 #> 3  21   r     1         3 #>  #> [[10]] #> # A tibble: 3 x 4 #>       x fill  PANEL group #>   <dbl> <chr> <fct> <int> #> 1  19.2 4     1         1 #> 2  28.2 f     1         2 #> 3  21   r     1         3 #>  #> [[11]] #> # A tibble: 3 x 4 #>       x fill  PANEL group #>   <dbl> <chr> <fct> <int> #> 1  19.2 4     1         1 #> 2  28.2 f     1         2 #> 3  21   r     1         3 #>  #> [[12]] #> # A tibble: 3 x 8 #>   fill        x PANEL group colour  size linetype alpha #>   <chr>   <dbl> <fct> <int> <chr>  <dbl>    <dbl> <lgl> #> 1 #F8766D  19.2 1         1 black    0.5        1 NA    #> 2 #00BA38  28.2 1         2 black    0.5        1 NA    #> 3 #619CFF  21   1         3 black    0.5        1 NA    #>  #> [[13]] #> # A tibble: 3 x 8 #>   fill        x PANEL group colour  size linetype alpha #>   <chr>   <dbl> <fct> <int> <chr>  <dbl>    <dbl> <lgl> #> 1 #F8766D  19.2 1         1 black    0.5        1 NA    #> 2 #00BA38  28.2 1         2 black    0.5        1 NA    #> 3 #619CFF  21   1         3 black    0.5        1 NA    #>  #> [[14]] #> # A tibble: 3 x 8 #>   fill        x PANEL group colour  size linetype alpha #>   <chr>   <dbl> <fct> <int> <chr>  <dbl>    <dbl> <lgl> #> 1 #F8766D  19.2 1         1 black    0.5        1 NA    #> 2 #00BA38  28.2 1         2 black    0.5        1 NA    #> 3 #619CFF  21   1         3 black    0.5        1 NA group_present1 <- sapply(tracedump1, function(x) {   \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3 }) group_present1 #>  [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE #> [13]  TRUE  TRUE which(data_assigns)[min(which(group_present1))] #> [1] 12 ggbody(ggplot2:::ggplot_build.ggplot)[[12]] #> data <- by_layer(function(l, d) l$compute_aesthetics(d, plot)) ggbody(ggplot2:::ggplot_build.ggplot)[[7]] #> by_layer <- function(f) { #>     out <- vector(\"list\", length(data)) #>     for (i in seq_along(data)) { #>         out[[i]] <- f(l = layers[[i]], d = data[[i]]) #>     } #>     out #> }"},{"path":"/articles/casestudy-ggxmean.html","id":"digging-deeper-into-layercompute_aesthetics","dir":"Articles","previous_headings":"Step 1 - Locating the problem","what":"1.2 Digging deeper into Layer$compute_aesthetics()","title":"Debugging an extension package","text":"point realize go little deeper ggplot_build(). need inspect Layer$compute_aesthetics - compute_aesthetics method Layer ggproto. (Check quick aside Layer ggproto first time encountering , purposes vignette just need know Layer$compute_aesthetics function called inside ggplot_build() think group calculated.) Layer object returned ggplot2::layer(). don’t see function often, ’s gets returned geom_*() stat_*() functions, ’ve actually seen lot. example, call geom_bar() , ’ll get back object class LayerInstance/Layer body geom_bar() just calls layer() defaults optimized drawing bar plots. two practically : Layer objects various properties methods, including compute_aesthetics. compute_aesthetics method defined parent Layer ggproto unexported. layer returned geom_bar() simply inherits method, reflected fact class LayerInstance, also . Let’s now repeat know-nothing, brute-force exploratory process inside Layer$compute_aesthetics. , inspect output every line using ~step keyword inside trace_exprs argument locate group get computed. Step 21 Layer$compute_aesthetics seems happens. , calls unexported internal utility function called add_group(), look source code can confirm indeed located group calculated assigned. gets us half-way solving issue can’t/shouldn’t modify Layer ggproto extension packages - ’s unexported! Plus, want change behavior geom_x_mean() specifically, aesthetics can’t understand ignored calculation groups, groups layers.","code":"geom_bar() #> geom_bar: width = NULL, na.rm = FALSE, orientation = NA #> stat_count: width = NULL, na.rm = FALSE, orientation = NA #> position_stack class(geom_bar()) #> [1] \"LayerInstance\" \"Layer\"         \"ggproto\"       \"gg\" body(geom_bar) #> { #>     layer(data = data, mapping = mapping, stat = stat, geom = GeomBar,  #>         position = position, show.legend = show.legend, inherit.aes = inherit.aes,  #>         params = list(width = width, na.rm = na.rm, orientation = orientation,  #>             ...)) #> } geom_bar() #> geom_bar: width = NULL, na.rm = FALSE, orientation = NA #> stat_count: width = NULL, na.rm = FALSE, orientation = NA #> position_stack layer(   geom = GeomBar, stat = StatCount, position = PositionStack,   params = list(width = NULL, na.rm = FALSE, orientation = NA) ) #> geom_bar: width = NULL, na.rm = FALSE, orientation = NA #> stat_count: width = NULL, na.rm = FALSE, orientation = NA #> position_stack names(as.list(geom_bar())) #>  [1] \"mapping\"              \"geom_params\"          \"layer_data\"           #>  [4] \"compute_statistic\"    \"computed_mapping\"     \"compute_aesthetics\"   #>  [7] \"stat_params\"          \"map_statistic\"        \"draw_geom\"            #> [10] \"stat\"                 \"setup_layer\"          \"inherit.aes\"          #> [13] \"finish_statistics\"    \"geom\"                 \"compute_position\"     #> [16] \"position\"             \"print\"                \"data\"                 #> [19] \"aes_params\"           \"computed_stat_params\" \"computed_geom_params\" #> [22] \"compute_geom_1\"       \"compute_geom_2\"       \"show.legend\" class(ggplot2:::Layer) #> [1] \"Layer\"   \"ggproto\" \"gg\" class(geom_bar()) #> [1] \"LayerInstance\" \"Layer\"         \"ggproto\"       \"gg\" ggbody(ggplot2:::Layer$compute_aesthetics) #> [[1]] #> `{` #>  #> [[2]] #> aesthetics <- self$computed_mapping #>  #> [[3]] #> set <- names(aesthetics) %in% names(self$aes_params) #>  #> [[4]] #> calculated <- is_calculated_aes(aesthetics) #>  #> [[5]] #> modifiers <- is_scaled_aes(aesthetics) #>  #> [[6]] #> aesthetics <- aesthetics[!set & !calculated & !modifiers] #>  #> [[7]] #> if (!is.null(self$geom_params$group)) { #>     aesthetics[[\"group\"]] <- self$aes_params$group #> } #>  #> [[8]] #> scales_add_defaults(plot$scales, data, aesthetics, plot$plot_env) #>  #> [[9]] #> env <- child_env(baseenv(), stage = stage) #>  #> [[10]] #> evaled <- lapply(aesthetics, eval_tidy, data = data, env = env) #>  #> [[11]] #> evaled <- compact(evaled) #>  #> [[12]] #> warn_for_aes_extract_usage(aesthetics, data[setdiff(names(data),  #>     \"PANEL\")]) #>  #> [[13]] #> nondata_cols <- check_nondata_cols(evaled) #>  #> [[14]] #> if (length(nondata_cols) > 0) { #>     msg <- paste0(\"Aesthetics must be valid data columns. Problematic aesthetic(s): \",  #>         paste0(vapply(nondata_cols, function(x) { #>             paste0(x, \" = \", as_label(aesthetics[[x]])) #>         }, character(1)), collapse = \", \"), \". \\nDid you mistype the name of a data column or forget to add after_stat()?\") #>     abort(msg) #> } #>  #> [[15]] #> n <- nrow(data) #>  #> [[16]] #> if (n == 0) { #>     if (length(evaled) == 0) { #>         n <- 0 #>     } #>     else { #>         n <- max(vapply(evaled, length, integer(1))) #>     } #> } #>  #> [[17]] #> check_aesthetics(evaled, n) #>  #> [[18]] #> if (empty(data) && n > 0) { #>     evaled$PANEL <- 1 #> } else { #>     evaled$PANEL <- data$PANEL #> } #>  #> [[19]] #> evaled <- lapply(evaled, unname) #>  #> [[20]] #> evaled <- as_gg_data_frame(evaled) #>  #> [[21]] #> evaled <- add_group(evaled) #>  #> [[22]] #> evaled ggtrace(   method = ggplot2:::Layer$compute_aesthetics,   trace_steps = seq_along(ggbody(ggplot2:::Layer$compute_aesthetics)),   trace_exprs = quote(~step),   verbose = FALSE ) #> `ggplot2:::Layer$compute_aesthetics` now being traced.  # plot not printed for space p + aes(fill = drv) #> Triggering trace on `ggplot2:::Layer$compute_aesthetics` #> Untracing `ggplot2:::Layer$compute_aesthetics` on exit.  tracedump2 <- last_ggtrace()  group_present2 <- sapply(tracedump2, function(x) {   \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3 }) length(group_present2) #> [1] 22 which(group_present2) #> [1] 21 22 min(which(group_present2)) #> [1] 21 ggbody(ggplot2:::Layer$compute_aesthetics)[[21]] #> evaled <- add_group(evaled)"},{"path":"/articles/casestudy-ggxmean.html","id":"step-2---identifying-the-extension-point","dir":"Articles","previous_headings":"","what":"Step 2 - Identifying the extension point","title":"Debugging an extension package","text":"point, hunt next time Layer dispatches Stat Geom ggproto method transformed data group calculated, can undo grouping calculation inside Stat/Geom necessary (since Stat Geom exported recommended extension points). Going back ggplot_build(), next l$<method> call l$compute_aesthetics compute_statistic method Step 18 Let’s see happens inside Layer$compute_statistic method see next time data gets transformed passed Layer$compute_statistic setup_data method layer’s Stat ggproto Step 4. Let’s see kind information stage, whether information sufficient us implement desired design change geom_x_mean()","code":"ggbody(ggplot2:::ggplot_build.ggplot)[[18]] #> data <- by_layer(function(l, d) l$compute_statistic(d, layout)) ggbody(ggplot2:::Layer$compute_statistic) #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(new_data_frame()) #>  #> [[3]] #> self$computed_stat_params <- self$stat$setup_params(data, self$stat_params) #>  #> [[4]] #> data <- self$stat$setup_data(data, self$computed_stat_params) #>  #> [[5]] #> self$stat$compute_layer(data, self$computed_stat_params, layout) ggbody(ggplot2:::Layer$compute_statistic)[[4]] #> data <- self$stat$setup_data(data, self$computed_stat_params)"},{"path":"/articles/casestudy-ggxmean.html","id":"step-2-1---inspecting-the-setup_data-method","dir":"Articles","previous_headings":"Step 2 - Identifying the extension point","what":"Step 2.1 - Inspecting the setup_data method","title":"Debugging an extension package","text":"First, let’s figure Stat ggproto associated geom_x_mean() let’s inspect setup_data method looks like setup_data inherited parent ggproto. candidate looking class() Stat parent ggproto. decide change behavior setup_data StatXmean, ’ll need define version method, instead simlpy inherit Stat$setup_data. now, let’s grab inherited method Stat proceed inspecting behavior. inherit = TRUE argument inside ggbody(), confirm StatXmean indeed inherits Stat$setup_data Okay method just returns data default. data look like practice?","code":"class(geom_x_mean()$stat)[1] #> [1] \"StatXmean\" ggbody(ggxmean:::StatXmean$setup_data) # errors! #> Error: #> ! Method 'setup_data' is not defined for `ggxmean:::StatXmean` #> Check inheritance with `get_method(ggxmean:::StatXmean$setup_data, inherit = TRUE)` class(ggxmean:::StatXmean) #> [1] \"StatXmean\" \"Stat\"      \"ggproto\"   \"gg\" ggbody(ggxmean:::StatXmean$setup_data, inherit = TRUE) #> Method inherited from `Stat$setup_data` #> [[1]] #> `{` #>  #> [[2]] #> data"},{"path":"/articles/casestudy-ggxmean.html","id":"step-2-2---logging-the-execution-of-statsetup_data","dir":"Articles","previous_headings":"Step 2 - Identifying the extension point","what":"Step 2.2 - Logging the execution of Stat$setup_data","title":"Debugging an extension package","text":"following ggtrace() code shorthand inserting trace simply returns output last step (-1) method: see data contains information supplied aesthetics calculated PANEL group information. sufficient information purposes.","code":"ggtrace(Stat$setup_data, -1, verbose = FALSE) #> `Stat$setup_data` now being traced.  # plot not printed for space p + aes(fill = drv) #> Triggering trace on `Stat$setup_data` #> Untracing `Stat$setup_data` on exit. tibble::as_tibble(last_ggtrace()[[1]]) #> # A tibble: 234 x 4 #>    fill      x PANEL group #>    <chr> <dbl> <fct> <int> #>  1 f        29 1         2 #>  2 f        29 1         2 #>  3 f        31 1         2 #>  4 f        30 1         2 #>  5 f        26 1         2 #>  6 f        26 1         2 #>  7 f        27 1         2 #>  8 4        26 1         1 #>  9 4        25 1         1 #> 10 4        28 1         1 #> # ... with 224 more rows"},{"path":[]},{"path":"/articles/casestudy-ggxmean.html","id":"step-3-1---devising-a-plan-pseudo-code-outline","dir":"Articles","previous_headings":"Step 3 - Developing a solution","what":"Step 3.1 - Devising a plan (pseudo-code outline)","title":"Debugging an extension package","text":"’s plan. Instead setup_data method just return data receives, let’s check two conditions: , leave data alone. Otherwise… , leave data alone. Otherwise, re-calculate groups dropping extraneous variables passing data ggplot2:::add_group() .","code":""},{"path":"/articles/casestudy-ggxmean.html","id":"step-3-2---setting-up-for-testing","dir":"Articles","previous_headings":"Step 3 - Developing a solution","what":"Step 3.2 - Setting up for testing","title":"Debugging an extension package","text":"One biggest perks {ggtrace} ability log output triggered traces. ’ve seeing bit last_ggtrace() can scale . Using global_ggtrace() persistent tracing ggtrace(= FALSE), can capture data looks like inside setup_data method across two expected two unexpected cases reprex. Now tracedump3 holds value data inside setup_data method four plots interest.","code":"# Turn the global tracedump on global_ggtrace_on() #> Global tracedump activated.  ggtrace(Stat$setup_data, -1, once = FALSE, verbose = FALSE) #> `Stat$setup_data` now being traced. #> Creating a persistent trace. Remember to `gguntrace(Stat$setup_data)`!  # plots not printed for space p + aes(color = drv) #> Triggering persistent trace on `Stat$setup_data` p + aes(group = drv) #> Triggering persistent trace on `Stat$setup_data` p + aes(shape = drv) #> Triggering persistent trace on `Stat$setup_data` p + aes(fill = fl, color = drv) #> Triggering persistent trace on `Stat$setup_data`  tracedump3 <- global_ggtrace() tracedump3 <- lapply(tracedump3, `[[`, 1) # simplify  # Clean up and turn the global tracedump back off gguntrace(Stat$setup_data) #> `Stat$setup_data` no longer being traced. clear_global_ggtrace() #> Global tracedump cleared. global_ggtrace_off() #> Global tracedump deactivated.  # Label the trace dumps names(tracedump3) <- c(paste0(\"expected\", 1:2), paste0(\"unexpected\", 1:2)) names(tracedump3) #> [1] \"expected1\"   \"expected2\"   \"unexpected1\" \"unexpected2\" lapply(tracedump3, tibble::as_tibble) #> $expected1 #> # A tibble: 234 x 4 #>    colour     x PANEL group #>    <chr>  <dbl> <fct> <int> #>  1 f         29 1         2 #>  2 f         29 1         2 #>  3 f         31 1         2 #>  4 f         30 1         2 #>  5 f         26 1         2 #>  6 f         26 1         2 #>  7 f         27 1         2 #>  8 4         26 1         1 #>  9 4         25 1         1 #> 10 4         28 1         1 #> # ... with 224 more rows #>  #> $expected2 #> # A tibble: 234 x 3 #>        x group PANEL #>    <dbl> <int> <fct> #>  1    29     2 1     #>  2    29     2 1     #>  3    31     2 1     #>  4    30     2 1     #>  5    26     2 1     #>  6    26     2 1     #>  7    27     2 1     #>  8    26     1 1     #>  9    25     1 1     #> 10    28     1 1     #> # ... with 224 more rows #>  #> $unexpected1 #> # A tibble: 234 x 4 #>    shape     x PANEL group #>    <chr> <dbl> <fct> <int> #>  1 f        29 1         2 #>  2 f        29 1         2 #>  3 f        31 1         2 #>  4 f        30 1         2 #>  5 f        26 1         2 #>  6 f        26 1         2 #>  7 f        27 1         2 #>  8 4        26 1         1 #>  9 4        25 1         1 #> 10 4        28 1         1 #> # ... with 224 more rows #>  #> $unexpected2 #> # A tibble: 234 x 5 #>    fill  colour     x PANEL group #>    <chr> <chr>  <dbl> <fct> <int> #>  1 p     f         29 1         8 #>  2 p     f         29 1         8 #>  3 p     f         31 1         8 #>  4 p     f         30 1         8 #>  5 p     f         26 1         8 #>  6 p     f         26 1         8 #>  7 p     f         27 1         8 #>  8 p     4         26 1         7 #>  9 p     4         25 1         7 #> 10 p     4         28 1         7 #> # ... with 224 more rows"},{"path":[]},{"path":"/articles/casestudy-ggxmean.html","id":"part-1---check-if-group-is-derived","dir":"Articles","previous_headings":"Step 3 - Developing a solution > Step 3.3 - Tackling the problem piece by piece","what":"Part 1 - Check if group is derived","title":"Debugging an extension package","text":"first condition checking whether group explicitly supplied actually easy implement. Going back Layer$compute_aesthetics, can see PANEL column assigned first group column assigned afterwards. means group already exist, ’d appear right PANEL. exist , ’d just modified original position appear left PANEL (since PANEL can never exist ). can confirm two expected cases: can make function checks position group column relative PANEL column, use tracedump validate ","code":"colnames(tracedump3$expected1) # `aes(color = drv)` #> [1] \"colour\" \"x\"      \"PANEL\"  \"group\" colnames(tracedump3$expected2) # `aes(group = drv)` #> [1] \"x\"     \"group\" \"PANEL\" group_is_derived <- function(data) {   # Do \"group\" and \"PANEL\" appear out of order?   is.unsorted(match(c(\"group\", \"PANEL\"), colnames(data))) } group_is_derived(tracedump3$expected1) #> [1] TRUE group_is_derived(tracedump3$expected2) #> [1] FALSE"},{"path":"/articles/casestudy-ggxmean.html","id":"part-2---check-if-the-geom-can-understand-all-discrete-aesthetics","dir":"Articles","previous_headings":"Step 3 - Developing a solution > Step 3.3 - Tackling the problem piece by piece","what":"Part 2 - Check if the geom can understand all discrete aesthetics","title":"Debugging an extension package","text":"second condition, need figure aesthetics geom can understand. First, check geom geom_x_mean() uses. see uses unexported geom ggxmean:::GeomXline. gather aesthetics can handle just want check among non-positional aesthetics, set want: can now write function returns discrete variables data understood GeomXline. validate function tracedump","code":"class(geom_x_mean()$geom)[1] #> [1] \"GeomXline\" understandable_aes <- unique(c(   ggxmean:::GeomXline$required_aes,   names(ggxmean:::GeomXline$default_aes),   ggxmean:::GeomXline$optional_aes )) understandable_aes #> [1] \"x\"        \"colour\"   \"size\"     \"linetype\" \"alpha\" understandable_aes[!understandable_aes %in% c(\"x\", \"y\")] #> [1] \"colour\"   \"size\"     \"linetype\" \"alpha\" not_understandable_aes <- function(data) {   discretes <- colnames(data)[sapply(data, ggplot2:::is.discrete)]   discretes <- discretes[!discretes %in% c(\"group\", \"PANEL\")]   discretes[!discretes %in% c(\"colour\", \"size\", \"linetype\", \"alpha\")] } lengths(lapply(tracedump3, not_understandable_aes)) > 0 #>   expected1   expected2 unexpected1 unexpected2  #>       FALSE       FALSE        TRUE        TRUE not_understandable_aes(tracedump3$unexpected1) #> [1] \"shape\" not_understandable_aes(tracedump3$unexpected2) #> [1] \"fill\""},{"path":"/articles/casestudy-ggxmean.html","id":"part-3---handle-the-exception","dir":"Articles","previous_headings":"Step 3 - Developing a solution > Step 3.3 - Tackling the problem piece by piece","what":"Part 3 - Handle the exception","title":"Debugging an extension package","text":"Lastly, case groups computed using discrete variables mapped aesthetics GeomXline doesn’t understand, want re-assign groups. following function takes data, strips offending variables/columns, returns vector new groupings. returns us expected number groups unexpected reprex cases (recall unexpected2 used 12 groups now 3 ’s correctly ignoring interaction fill = fl).","code":"retrained_groups <- function(data) {   not_understandables <- not_understandable_aes(data)   data <- data[!colnames(data) %in% c(\"group\", not_understandables)]   ggplot2:::add_group(data)$group } lapply(tracedump3[3:4], function(x) { sort(unique(retrained_groups(x))) }) #> $unexpected1 #> [1] -1 #>  #> $unexpected2 #> [1] 1 2 3"},{"path":"/articles/casestudy-ggxmean.html","id":"part-4---bring-it-together","dir":"Articles","previous_headings":"Step 3 - Developing a solution > Step 3.3 - Tackling the problem piece by piece","what":"Part 4 - Bring it together","title":"Debugging an extension package","text":"Now melt functions Parts 1-3 single function become new setup_data method StatXmean. validate expected unexpected cases see indeed works! *Note ’re still using unexported ggplot2 functions like .discrete add_group. ’d normally refactor copy releasing fix, ’ll skip sake time.","code":"setup_data_new <- function(data) {   if (is.unsorted(match(c(\"group\", \"PANEL\"), colnames(data)))) {     discretes <- colnames(data)[sapply(data, ggplot2:::is.discrete)]     discretes <- discretes[!discretes %in% c(\"group\", \"PANEL\")]     not_understandables <- discretes[!discretes %in% c(\"colour\", \"size\", \"linetype\", \"alpha\")]     if (length(not_understandables) > 0) {       dummy_data <- data[!colnames(data) %in% c(\"group\", not_understandables)]       data$group <- ggplot2:::add_group(dummy_data)$group     }   }   data } tracedump3_modified <- lapply(tracedump3, setup_data_new) lapply(tracedump3_modified, function(x) sort(unique(x$group) )) #> $expected1 #> [1] 1 2 3 #>  #> $expected2 #> [1] 1 2 3 #>  #> $unexpected1 #> [1] -1 #>  #> $unexpected2 #> [1] 1 2 3"},{"path":"/articles/casestudy-ggxmean.html","id":"step-3-4---implementing-the-solution","dir":"Articles","previous_headings":"Step 3 - Developing a solution","what":"Step 3.4 - Implementing the solution","title":"Debugging an extension package","text":"’d like test whole solution user-facing layer call day. just two important pieces : create ggproto class called StatXmean2 exact copy StatXmean except also defines setup_data method defined . create layer called geom_x_mean2() exact copy geom_x_mean() except stat argument ofggplot2::layer() StatXmean2 final check original reprexes shows works intended","code":"StatXmean2 <- ggplot2::ggproto(   \"StatXmean2\",   ggplot2::Stat,   setup_data = function(data, params) {     if (is.unsorted(match(c(\"group\", \"PANEL\"), colnames(data)))) {       discretes <- colnames(data)[sapply(data, ggplot2:::is.discrete)]       discretes <- discretes[!discretes %in% c(\"group\", \"PANEL\")]       not_understandables <- discretes[!discretes %in% c(\"colour\", \"size\", \"linetype\", \"alpha\")]       if (length(not_understandables) > 0) {         dummy_data <- data[!colnames(data) %in% c(\"group\", not_understandables)]         data$group <- ggplot2:::add_group(dummy_data)$group       }     }     data   },   compute_group = function(data, scales) {     data.frame(x = mean(data$x))   },   required_aes = c(\"x\") )  geom_x_mean2 <- function(mapping = NULL, data = NULL,                         position = \"identity\", na.rm = FALSE, show.legend = NA,                         inherit.aes = TRUE, ...) {   ggplot2::layer(     stat = StatXmean2, geom = ggxmean:::GeomXline, data = data, mapping = mapping,     position = position, show.legend = show.legend, inherit.aes = inherit.aes,     params = list(na.rm = na.rm, ...)   ) } p2 <- ggplot(mpg) +   aes(x = hwy) +   geom_x_mean2()  p2 + aes(color = drv) p2 + aes(group = drv) p2 + aes(shape = drv) p2 + aes(fill = fl, color = drv)"},{"path":"/articles/casestudy-ggxmean.html","id":"step-3-5---testing-the-solution","dir":"Articles","previous_headings":"Step 3 - Developing a solution","what":"Step 3.5 - Testing the solution","title":"Debugging an extension package","text":"want write tests, can also check whether solution generalizes cases. , can see correctly works facets even groups missing facet, ’s good  can also see fails way ’s supplied explicit group aesthetic also receives another discrete mapping color  ’s one unique match fl == \"c\" drv== \"f\", unique value drv four fl categories. color scale assigns color one lines four lines just gives returns NAs (colored grey default)","code":"p2 +   aes(color = drv) +   facet_wrap(~fl) p2 + aes(group = fl, color = drv) table(mpg$drv, mpg$fl) #>     #>      c  d  e  p  r #>   4  0  2  6 20 75 #>   f  1  3  1 25 76 #>   r  0  0  1  7 17 p2 +   aes(group = fl, color = drv) +   geom_label(aes(label = fl, y = 0), stat = StatXmean2)"},{"path":"/articles/casestudy-ggxmean.html","id":"wrapping-up","dir":"Articles","previous_headings":"","what":"Wrapping up","title":"Debugging an extension package","text":"’re satisfied can now turn development mode , lets us access current installation {ggxmean} . can now also test solution current version package see whether ’d still work (although skip step ). Finally, since vignette covered real-world debugging scenario, solution submitted PR! Many thanks Gina allowing use {ggxmean} case study exploratory debugging {ggtrace}!","code":"devtools::dev_mode(on = FALSE) #> v Dev mode: OFF devtools::package_info(\"ggxmean\", FALSE, FALSE)$source #> [1] \"local\""},{"path":[]},{"path":"/articles/comparisons.html","id":"sneak-peak","dir":"Articles","previous_headings":"","what":"Sneak peak:","title":"Comparison of debugging methods","text":"debug()/debugonce() browser() + load_all() layer_data() trace() Hiroaki Yutani’s blog post {ggplot2} + browser() Pedro J. Aphalo’s {gginnards} Brodie Gaslam’s {ggbg} ggplot2 internals reference document Dewey Dunnington’s {ggdebug}, also features function name ggdebug::ggtrace use trace(). Maybe things changed last 2-3 years, trace() untrace() work ggproto methods, package shows!","code":""},{"path":"/articles/FAQ.html","id":"is-ggtrace-safe","dir":"Articles","previous_headings":"","what":"Is ggtrace() safe?","title":"Frequently asked questions","text":"ggtrace() essentially just wrapper around base::trace() designed make easy safe programmatically trace/untrace functions methods. short answer ggtrace() least safe trace(). safe trace()? beauty trace() modified function traced masks original function without overwriting . allows non-destructive modifications execution behavior. simple example, add trace replace() multiples value x 10 function enters last step. traced function looks strange runs different behavior , non-destructive. original function body safely stored away \"original\" attribute traced function original function can recovered removing trace call untrace() Beyond , ggtrace also offers extra built-safety measures: Cleans untracing exit (default behavior = TRUE) Always untraces tracing, prevents nested traces created Provides ample messages whethere existing trace (can also check is_traced()) Exits early possible method expression ill-formed informative error messages can actually act Prevents traces created functions aren’t bound variable way (.e., prevents creating traces can’t trigger) However, expression pass ggtrace() delayed evaluation without consequences. need careful running functions side effects making assignments environments (ex: self$method <- ... modify place). isn’t problem ggtrace - follow general rules reference semantics R.","code":"body(replace) #> { #>     x[list] <- values #>     x #> }  replace(1:5, 3, 30) #> [1]  1  2 30  4  5  as.list(body(replace)) #> [[1]] #> `{` #>  #> [[2]] #> x[list] <- values #>  #> [[3]] #> x  trace(replace, tracer = quote(x <- x * 10), at = 3) #> Tracing function \"replace\" in package \"base\" #> [1] \"replace\" class(replace) #> [1] \"functionWithTrace\" #> attr(,\"package\") #> [1] \"methods\"  body(replace) #> { #>     x[list] <- values #>     { #>         .doTrace(x <- x * 10, \"step 3\") #>         x #>     } #> }  replace(1:5, 3, 30) #> Tracing replace(1:5, 3, 30) step 3 #> [1]  10  20 300  40  50 attr(replace, \"original\") #> function (x, list, values)  #> { #>     x[list] <- values #>     x #> } #> <bytecode: 0x0000000016f22e00> #> <environment: namespace:base> untrace(replace) #> Untracing function \"replace\" in package \"base\"  body(replace) #> { #>     x[list] <- values #>     x #> }  replace(1:5, 3, 30) #> [1]  1  2 30  4  5"},{"path":[]},{"path":"/articles/FAQ.html","id":"functions","dir":"Articles","previous_headings":"What can you ggtrace()?","what":"Functions","title":"Frequently asked questions","text":"{base} functions Imported functions Custom functions","code":"sample(letters, 5) #> [1] \"g\" \"f\" \"n\" \"z\" \"l\" ggtrace(sample, 1, quote(x <- LETTERS), verbose = FALSE) #> `sample` now being traced. sample(letters, 5) #> Triggering trace on `sample` #> Untracing `sample` on exit. #> [1] \"T\" \"F\" \"Y\" \"X\" \"N\" sample(letters, 5) #> [1] \"e\" \"o\" \"g\" \"i\" \"l\" ggtrace(ggplot2::mean_se, 1, quote(cat(\"Running...\\n\")), verbose = FALSE) #> `ggplot2::mean_se` now being traced. ggplot2::mean_se(mtcars$mpg) #> Triggering trace on `ggplot2::mean_se` #> Running... #> Untracing `ggplot2::mean_se` on exit. #>          y    ymin     ymax #> 1 20.09062 19.0252 21.15605 please_return_number <- function() {   result <- runif(1)   result } please_return_number() #> [1] 0.5456977  ggtrace(please_return_number, -1, quote(result <- \"no\"), verbose = FALSE) #> `please_return_number` now being traced. please_return_number() #> Triggering trace on `please_return_number` #> Untracing `please_return_number` on exit. #> [1] \"no\""},{"path":"/articles/FAQ.html","id":"ggproto-methods","dir":"Articles","previous_headings":"What can you ggtrace()?","what":"ggproto methods","title":"Frequently asked questions","text":"Default tracing behavior untracing exit Persistent trace = FALSE explicit untracing gguntrace()","code":"library(ggplot2) boxplot_plot <- ggplot(mpg, aes(drv, hwy)) +   geom_boxplot()  boxplot_plot ggtrace(StatBoxplot$compute_group, -1, verbose = FALSE) #> `StatBoxplot$compute_group` now being traced.  # Plot not printed to save space boxplot_plot #> Triggering trace on `StatBoxplot$compute_group` #> Untracing `StatBoxplot$compute_group` on exit.  last_ggtrace() #> [[1]] #>   ymin lower middle upper ymax outliers notchupper notchlower x width #> 1   12    17     18    22   28            18.77841   17.22159 1  0.75 #>   relvarwidth flipped_aes #> 1    10.14889       FALSE global_ggtrace_state() #> [1] FALSE global_ggtrace_state(TRUE) #> Global tracedump activated. clear_global_ggtrace() #> Global tracedump cleared.  ggtrace(StatBoxplot$compute_group, -1, once = FALSE, verbose = FALSE) #> `StatBoxplot$compute_group` now being traced. #> Creating a persistent trace. Remember to `gguntrace(StatBoxplot$compute_group)`!  # Plot not printed to save space boxplot_plot #> Triggering persistent trace on `StatBoxplot$compute_group` #> Triggering persistent trace on `StatBoxplot$compute_group` #> Triggering persistent trace on `StatBoxplot$compute_group`  gguntrace(StatBoxplot$compute_group) #> `StatBoxplot$compute_group` no longer being traced.  global_ggtrace() #> $`StatBoxplot$compute_group-0x00000000245b75e0` #> $`StatBoxplot$compute_group-0x00000000245b75e0`[[1]] #>   ymin lower middle upper ymax outliers notchupper notchlower x width #> 1   12    17     18    22   28            18.77841   17.22159 1  0.75 #>   relvarwidth flipped_aes #> 1    10.14889       FALSE #>  #>  #> $`StatBoxplot$compute_group-0x000000001ff3a7a8` #> $`StatBoxplot$compute_group-0x000000001ff3a7a8`[[1]] #>   ymin lower middle upper ymax                                   outliers #> 1   22    26     28    29   33 17, 21, 34, 36, 36, 35, 37, 35, 44, 44, 41 #>   notchupper notchlower x width relvarwidth flipped_aes #> 1   28.46039   27.53961 2  0.75    10.29563       FALSE #>  #>  #> $`StatBoxplot$compute_group-0x00000000137485e0` #> $`StatBoxplot$compute_group-0x00000000137485e0`[[1]] #>   ymin lower middle upper ymax outliers notchupper notchlower x width #> 1   15    17     21    24   26              23.212     18.788 3  0.75 #>   relvarwidth flipped_aes #> 1           5       FALSE  global_ggtrace_state(FALSE) #> Global tracedump deactivated."},{"path":"/articles/FAQ.html","id":"s3s4-generics","dir":"Articles","previous_headings":"What can you ggtrace()?","what":"S3/S4 generics","title":"Frequently asked questions","text":"exported generic function ggplot_build() ggplot2 meaningful, unexported method <ggplot> class ggplot_build.ggplot() contains actual data transformation pipeline. can trace ggplot_build() method defined <ggplot> way functions","code":"body(ggplot_build) #> { #>     UseMethod(\"ggplot_build\") #> }  attr(utils::methods(\"ggplot_build\"), \"info\") #>                     visible                                 from      generic #> ggplot_build.ggplot   FALSE registered S3method for ggplot_build ggplot_build #>                      isS4 #> ggplot_build.ggplot FALSE ggtrace(ggplot2:::ggplot_build.ggplot, -1, verbose = FALSE) #> `ggplot2:::ggplot_build.ggplot` now being traced.  boxplot_plot #> Triggering trace on `ggplot2:::ggplot_build.ggplot` #> Untracing `ggplot2:::ggplot_build.ggplot` on exit. last_ggtrace()[[1]]$data[[1]] #>   ymin lower middle upper ymax                                   outliers #> 1   12    17     18    22   28                                            #> 2   22    26     28    29   33 17, 21, 34, 36, 36, 35, 37, 35, 44, 44, 41 #> 3   15    17     21    24   26                                            #>   notchupper notchlower x flipped_aes PANEL group ymin_final ymax_final  xmin #> 1   18.77841   17.22159 1       FALSE     1     1         12         28 0.625 #> 2   28.46039   27.53961 2       FALSE     1     2         17         44 1.625 #> 3   23.21200   18.78800 3       FALSE     1     3         15         26 2.625 #>    xmax xid newx new_width weight colour  fill size alpha shape linetype #> 1 1.375   1    1      0.75      1 grey20 white  0.5    NA    19    solid #> 2 2.375   2    2      0.75      1 grey20 white  0.5    NA    19    solid #> 3 3.375   3    3      0.75      1 grey20 white  0.5    NA    19    solid  identical(last_ggtrace()[[1]]$data[[1]], layer_data(boxplot_plot, 1)) #> [1] TRUE"},{"path":"/articles/FAQ.html","id":"r6-methods","dir":"Articles","previous_headings":"What can you ggtrace()?","what":"R6 methods","title":"Frequently asked questions","text":"Adopted Advanced R Ch. 14.2","code":"library(R6) Accumulator <- R6Class(\"Accumulator\", list(   sum = 0,   add = function(x = 1) {     self$sum <- self$sum + x      invisible(self)   }) ) x <- Accumulator$new() x$add(1) x$sum #> [1] 1 ggtrace(   method = x$add,   trace_steps = c(1, -1),   trace_exprs = list(     before = quote(self$sum),     after = quote(self$sum)   ),   once = FALSE,   verbose = FALSE ) #> `x$add` now being traced. #> Creating a persistent trace. Remember to `gguntrace(x$add)`! x$add(10) #> Triggering persistent trace on `x$add` last_ggtrace() #> $before #> [1] 1 #>  #> $after #> [1] 11 x$add(100) #> Triggering persistent trace on `x$add` last_ggtrace() #> $before #> [1] 11 #>  #> $after #> [1] 111 gguntrace(x$add) #> `x$add` no longer being traced. x$add(1000) x$sum #> [1] 1111"},{"path":"/articles/FAQ.html","id":"what-cant-you-ggtrace","dir":"Articles","previous_headings":"","what":"What can’t you ggtrace()?","title":"Frequently asked questions","text":"Non-functions (ex: constants, object properties). can still inspect values ggbody() Functions defined environment (ex: can’t define function trace --spot inside ggtrace()) Limited support closures (LHS $ must environment function can searched )","code":""},{"path":"/articles/FAQ.html","id":"how-can-i-save-a-modified-ggplot","dir":"Articles","previous_headings":"","what":"How can I save a modified ggplot?","title":"Frequently asked questions","text":"trace internals ggplot, doesn’t directly modify instructions plotting. Instead, changes certain components behave executed. means get different ggplot following code original_plot traced modifications, since original_plot executed . looks like worked first print …  variable modified_pot doesn’t hold modified code generating plot. Instead, just happened trigger trace ggplot_build.ggplot(). next time runs, ’s ran normal behavior original_plot.  capture actual figure generated ggplot, can use ggplotGrob(), returns Graphical object representation plot: get object class <gtable>, can draw device like grob:  can also use ggsave() render <gtable> image: Still, modified_plot graphical representation plot ggplot object can’t keep adding layers . grobs limiting sense. ’s totally limiting like raster image figure. example, patchwork patchwork::wrap_ggplot_grob() allows <gtable> properly aligned ggplots.","code":"original_plot <- ggplot(mtcars, aes(hp, mpg)) + geom_point()  ggtrace(ggplot2:::ggplot_build.ggplot, -1, quote(data[[1]]$colour <- \"red\"), verbose = FALSE) #> `ggplot2:::ggplot_build.ggplot` now being traced.  modified_plot <- original_plot modified_plot #> Triggering trace on `ggplot2:::ggplot_build.ggplot` #> Untracing `ggplot2:::ggplot_build.ggplot` on exit. modified_plot ggtrace(ggplot2:::ggplot_build.ggplot, -1, quote(data[[1]]$colour <- \"red\"), verbose = FALSE) #> `ggplot2:::ggplot_build.ggplot` now being traced.  modified_plot <- ggplotGrob(original_plot) #> Triggering trace on `ggplot2:::ggplot_build.ggplot` #> Untracing `ggplot2:::ggplot_build.ggplot` on exit.  modified_plot #> TableGrob (12 x 9) \"layout\": 18 grobs #>     z         cells       name                                          grob #> 1   0 ( 1-12, 1- 9) background               rect[plot.background..rect.357] #> 2   5 ( 6- 6, 4- 4)     spacer                                zeroGrob[NULL] #> 3   7 ( 7- 7, 4- 4)     axis-l           absoluteGrob[GRID.absoluteGrob.345] #> 4   3 ( 8- 8, 4- 4)     spacer                                zeroGrob[NULL] #> 5   6 ( 6- 6, 5- 5)     axis-t                                zeroGrob[NULL] #> 6   1 ( 7- 7, 5- 5)      panel                      gTree[panel-1.gTree.337] #> 7   9 ( 8- 8, 5- 5)     axis-b           absoluteGrob[GRID.absoluteGrob.341] #> 8   4 ( 6- 6, 6- 6)     spacer                                zeroGrob[NULL] #> 9   8 ( 7- 7, 6- 6)     axis-r                                zeroGrob[NULL] #> 10  2 ( 8- 8, 6- 6)     spacer                                zeroGrob[NULL] #> 11 10 ( 5- 5, 5- 5)     xlab-t                                zeroGrob[NULL] #> 12 11 ( 9- 9, 5- 5)     xlab-b titleGrob[axis.title.x.bottom..titleGrob.348] #> 13 12 ( 7- 7, 3- 3)     ylab-l   titleGrob[axis.title.y.left..titleGrob.351] #> 14 13 ( 7- 7, 7- 7)     ylab-r                                zeroGrob[NULL] #> 15 14 ( 4- 4, 5- 5)   subtitle         zeroGrob[plot.subtitle..zeroGrob.353] #> 16 15 ( 3- 3, 5- 5)      title            zeroGrob[plot.title..zeroGrob.352] #> 17 16 (10-10, 5- 5)    caption          zeroGrob[plot.caption..zeroGrob.355] #> 18 17 ( 2- 2, 2- 2)        tag              zeroGrob[plot.tag..zeroGrob.354] class(modified_plot) #> [1] \"gtable\" \"gTree\"  \"grob\"   \"gDesc\"  library(grid) grid.newpage() grid.draw(modified_plot) # Not ran  ggsave(filename = \"modified_plot.png\", plot = modified_plot, ...) library(patchwork) original_plot_titled <- original_plot + ggtitle(\"original plot\")  # Panels get aligned since `modified_plot` contains info about that original_plot_titled + wrap_ggplot_grob(modified_plot)"},{"path":"/articles/intro.html","id":"under-construction","dir":"Articles","previous_headings":"","what":"Under construction","title":"Introduction to ggtrace()","text":"Slides ggplot internals / {ggtrace} talk December 4th 2021: https://yjunechoe.github.io/ggtrace-talk","code":"library(ggtrace)"},{"path":"/articles/showcase-aes_evaluation.html","id":"under-construction","dir":"Articles","previous_headings":"","what":"Under construction","title":"Showcase: aes evaluation","text":"","code":"library(ggtrace) library(ggplot2)"},{"path":"/articles/showcase-aes_evaluation.html","id":"sneak-peak","dir":"Articles","previous_headings":"","what":"Sneak peak:","title":"Showcase: aes evaluation","text":"Read draft!","code":""},{"path":"/articles/showcase-ggplot_build.html","id":"under-construction","dir":"Articles","previous_headings":"","what":"Under construction","title":"Showcase: ggplot build","text":"","code":"library(ggtrace) library(ggplot2)"},{"path":"/articles/showcase-ggplot_build.html","id":"sneak-peak","dir":"Articles","previous_headings":"","what":"Sneak peak:","title":"Showcase: ggplot build","text":"Read draft!","code":""},{"path":[]},{"path":"/articles/technical-details.html","id":"sneak-peak","dir":"Articles","previous_headings":"","what":"Sneak peak:","title":"Technical details","text":"quick trace (tracer, , edit) ’s best debugging tool ever Getting arbitrary expressions evaluated inside tracer ggtrace works","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"June Choe. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Choe J (2022). ggtrace: Programmatically debug ggproto methods trace. https://yjunechoe.github.io/ggtrace, https://github.com/yjunechoe/ggtrace.","code":"@Manual{,   title = {ggtrace: Programmatically debug ggproto methods with trace},   author = {June Choe},   year = {2022},   note = {https://yjunechoe.github.io/ggtrace, https://github.com/yjunechoe/ggtrace}, }"},{"path":[]},{"path":"/index.html","id":"programmatically-inspect-debug-and-manipulate-ggplot-internals","dir":"","previous_headings":"","what":"Programmatically inspect, debug, and manipulate ggplot internals","title":"ggtrace","text":"dependency rlang - even ggplot2! lot code - heavy lifting done base::trace() Everything happens local session - need fork repo inspect internals! output available inspection outside debugging context last_ggtrace() global_ggtrace() Untraces exit default, like debugonce() Works functions object methods, just ggproto! can programmatically debug ggtrace() interactively debug ggedit() Since ggtrace() doesn’t rely interactivity, can used reprex-es Plays nice existing debugging tools (ex: can insert browser() calls deep inside body ggedit()) Return execution environment ggtrace() inspection Modify execution environment passing assignment expressions ggtrace() Change source code ggedit(), restored upon gguntrace() 📦 package website: https://yjunechoe.github.io/ggtrace","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"ggtrace","text":"can install development version GitHub :","code":"# install.packages(\"remotes\") remotes::install_github(\"yjunechoe/ggtrace\")  library(ggtrace) # v0.4.8"},{"path":[]},{"path":"/index.html","id":"step-1-make-plot","dir":"","previous_headings":"Example 1 - compute_layer method from PositionJitter","what":"Step 1. Make plot","title":"ggtrace","text":"","code":"library(ggplot2) # v3.3.5  jitter_plot <- ggplot(diamonds[1:1000,], aes(cut, depth)) +   geom_point(position = position_jitter(width = 0.2, seed = 2021)) jitter_plot"},{"path":"/index.html","id":"step-2-inspect-body-of-the-ggproto-method","dir":"","previous_headings":"Example 1 - compute_layer method from PositionJitter","what":"Step 2. Inspect body of the ggproto method","title":"ggtrace","text":"","code":"ggbody(PositionJitter$compute_layer) #> [[1]] #> `{` #>  #> [[2]] #> trans_x <- if (params$width > 0) function(x) jitter(x, amount = params$width) #>  #> [[3]] #> trans_y <- if (params$height > 0) function(x) jitter(x, amount = params$height) #>  #> [[4]] #> x_aes <- intersect(ggplot_global$x_aes, names(data)) #>  #> [[5]] #> x <- if (length(x_aes) == 0) 0 else data[[x_aes[1]]] #>  #> [[6]] #> y_aes <- intersect(ggplot_global$y_aes, names(data)) #>  #> [[7]] #> y <- if (length(y_aes) == 0) 0 else data[[y_aes[1]]] #>  #> [[8]] #> dummy_data <- new_data_frame(list(x = x, y = y), nrow(data)) #>  #> [[9]] #> fixed_jitter <- with_seed_null(params$seed, transform_position(dummy_data,  #>     trans_x, trans_y)) #>  #> [[10]] #> x_jit <- fixed_jitter$x - x #>  #> [[11]] #> y_jit <- fixed_jitter$y - y #>  #> [[12]] #> transform_position(data, function(x) x + x_jit, function(x) x +  #>     y_jit)"},{"path":"/index.html","id":"step-3-ggtrace---including-the-last-line-with-keyword-step","dir":"","previous_headings":"Example 1 - compute_layer method from PositionJitter","what":"Step 3. ggtrace() - including the last line with keyword ~step","title":"ggtrace","text":"","code":"ggtrace(   method = PositionJitter$compute_layer,   trace_steps = c(1, 1, 9, 12),   trace_exprs = rlang::exprs(     data,            # What does the data passed in look like?     params,          # What do the initial parameters look like?     dummy_data,      # What is `dummy_data` defined at Step 8?     ~step            # What does the last line evaluate to?                      # - i.e., what is returned by the method?   ),   print_output = FALSE   # Don't print evaluated expressions to console ) #> `PositionJitter$compute_layer` now being traced.  # plot not printed to save space jitter_plot #> Triggering trace on `PositionJitter$compute_layer` #> Untracing `PositionJitter$compute_layer` on exit."},{"path":"/index.html","id":"step-4-inspect-trace-dump","dir":"","previous_headings":"Example 1 - compute_layer method from PositionJitter","what":"Step 4. Inspect trace dump","title":"ggtrace","text":"","code":"jitter_tracedump <- last_ggtrace()  jitter_tracedump[[2]] #> $width #> [1] 0.2 #>  #> $height #> [1] 0.04 #>  #> $seed #> [1] 2021  lapply(jitter_tracedump[-2], nrow) #> [[1]] #> [1] 1000 #>  #> [[2]] #> [1] 1000 #>  #> [[3]] #> [1] 1000  lapply(jitter_tracedump[-2], head, 3) #> [[1]] #>   x    y PANEL group #> 1 5 61.5     1     5 #> 2 4 59.8     1     4 #> 3 2 56.9     1     2 #>  #> [[2]] #>   x    y #> 1 5 61.5 #> 2 4 59.8 #> 3 2 56.9 #>  #> [[3]] #>          x        y PANEL group #> 1 4.980507 61.50684     1     5 #> 2 4.113512 59.77872     1     4 #> 3 2.083873 56.86655     1     2"},{"path":[]},{"path":"/index.html","id":"step-1-make-plot-1","dir":"","previous_headings":"Example 2 - draw_group method from GeomSmooth","what":"Step 1. Make plot","title":"ggtrace","text":"","code":"smooth_plot <- ggplot(mtcars, aes(mpg, hp)) +   geom_point() +   stat_smooth(method = \"loess\", formula = y ~ x) smooth_plot"},{"path":"/index.html","id":"step-2-inspect-body-of-the-ggproto-method-1","dir":"","previous_headings":"Example 2 - draw_group method from GeomSmooth","what":"Step 2. Inspect body of the ggproto method","title":"ggtrace","text":"","code":"ggbody(GeomSmooth$draw_group) #> [[1]] #> `{` #>  #> [[2]] #> ribbon <- transform(data, colour = NA) #>  #> [[3]] #> path <- transform(data, alpha = NA) #>  #> [[4]] #> ymin = flipped_names(flipped_aes)$ymin #>  #> [[5]] #> ymax = flipped_names(flipped_aes)$ymax #>  #> [[6]] #> has_ribbon <- se && !is.null(data[[ymax]]) && !is.null(data[[ymin]]) #>  #> [[7]] #> gList(if (has_ribbon) GeomRibbon$draw_group(ribbon, panel_params,  #>     coord, flipped_aes = flipped_aes), GeomLine$draw_panel(path,  #>     panel_params, coord))"},{"path":"/index.html","id":"step-3-ggtrace---get-the-glist","dir":"","previous_headings":"Example 2 - draw_group method from GeomSmooth","what":"Step 3. ggtrace() - get the gList()","title":"ggtrace","text":"","code":"ggtrace(   method = GeomSmooth$draw_group,   trace_steps = -1,           # Trace the last line   trace_exprs = quote(~step), # Grab the gList() object it returns   print_output = FALSE ) #> `GeomSmooth$draw_group` now being traced.  # plot not printed to save space smooth_plot #> Triggering trace on `GeomSmooth$draw_group` #> Untracing `GeomSmooth$draw_group` on exit."},{"path":"/index.html","id":"step-4-inspect-trace-dump-1","dir":"","previous_headings":"Example 2 - draw_group method from GeomSmooth","what":"Step 4. Inspect trace dump","title":"ggtrace","text":"Get grobs gList weird stuff . nice don’t navigate whole list ggplotGrob(smooth_plot)[[\"grobs\"]].   might use fancy data-driven legends something, though ’s meant exploratory practical.","code":"smooth_tracedump <- last_ggtrace()  smooth_gList <- smooth_tracedump[[1]]  smooth_gList #> (gTree[geom_ribbon.gTree.132], polyline[GRID.polyline.133])  library(grid)  grid.ls(smooth_gList) #> geom_ribbon.gTree.132 #>   GRID.polygon.129 #>   GRID.polyline.130 #> GRID.polyline.133  grid.newpage() grid.draw(gTree(children = smooth_gList, vp = viewport())) # The weird stuff  smooth_ribbon_polygon <- editGrob(   smooth_gList[1][[1]],   \"polygon\",   grep = TRUE,   gp = gpar(fill = \"#b742ce\", alpha = 0.7, lwd = 3, col = \"black\") ) smooth_ribbon_gTree <- gTree(   children = gList(     smooth_ribbon_polygon,     textGrob(\"Weee\", x = .7, gp = gpar(col = \"red\", fontsize = unit(10, \"pt\")))   ),   vp = viewport(width = 1, height = 1, default.units = \"in\", angle = 30) )  grid.newpage() grid.draw(smooth_ribbon_gTree) library(patchwork) smooth_plot +   inset_element(     wrap_elements(full = smooth_ribbon_gTree) +       theme(plot.background = element_rect(fill = NA, color = NA)),     left = 0.5, bottom = 0.5, right = 0.8, top = 0.8   )"},{"path":[]},{"path":"/index.html","id":"step-1-make-plot-2","dir":"","previous_headings":"Example 3 - compute_panel method from StatBoxplot","what":"Step 1. Make plot","title":"ggtrace","text":"","code":"boxplot_plot <- ggplot(diamonds[1:500,], aes(cut, depth)) +   geom_boxplot() boxplot_plot"},{"path":"/index.html","id":"step-2-inspect-body-of-the-ggproto-method-2","dir":"","previous_headings":"Example 3 - compute_panel method from StatBoxplot","what":"Step 2. Inspect body of the ggproto method","title":"ggtrace","text":"Actually, \"compute_panel\" method defined StatBoxplot. ggbody() gives hint may inherited. StatBoxplot child parent ggproto Stat, \"compute_panel\" method inherited Stat well, ’s want trace instead: inherit = TRUE, ggbody() returns method defined closest parent, corresponding code get . confirm passing Stat$compute_panel method argument ggtrace().","code":"ggbody(StatBoxplot$compute_panel) #> Error: #> ! Method 'compute_panel' is not defined for `StatBoxplot` #> Check inheritance with `get_method(StatBoxplot$compute_panel, inherit = TRUE)` class(StatBoxplot) #> [1] \"StatBoxplot\" \"Stat\"        \"ggproto\"     \"gg\" ggbody(StatBoxplot$compute_panel, inherit = TRUE) #> Method inherited from `Stat$compute_panel` #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(new_data_frame()) #>  #> [[3]] #> groups <- split(data, data$group) #>  #> [[4]] #> stats <- lapply(groups, function(group) { #>     self$compute_group(data = group, scales = scales, ...) #> }) #>  #> [[5]] #> stats <- mapply(function(new, old) { #>     if (empty(new))  #>         return(new_data_frame()) #>     unique <- uniquecols(old) #>     missing <- !(names(unique) %in% names(new)) #>     cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #> }, stats, groups, SIMPLIFY = FALSE) #>  #> [[6]] #> rbind_dfs(stats)"},{"path":"/index.html","id":"step-3-ggtrace---retrieve-the-parent-environment","dir":"","previous_headings":"Example 3 - compute_panel method from StatBoxplot","what":"Step 3. ggtrace() - retrieve the parent environment","title":"ggtrace","text":"Stat$compute_panel split-apply-combine (Steps 3, 4-5, 6). Let’s return split combine:","code":"ggtrace(   Stat$compute_panel,   trace_steps = c(3, 6, 6),   trace_exprs = rlang::exprs(     splits      = ~step,         # What are the splits?     combined    = ~step,         # What does the combined result look like?     runtime_env = environment()  # Grab the method's execution environment   ),   use_names = TRUE,       # Use names of `trace_exprs` for names of the tracedump (default)   verbose = FALSE         # Suppress all printing (except `message()`s)                           # This entails the effects of `print_output = FALSE` ) #> `Stat$compute_panel` now being traced.  # plot not printed to save space boxplot_plot #> Triggering trace on `Stat$compute_panel` #> Untracing `Stat$compute_panel` on exit."},{"path":"/index.html","id":"step-4-inspect-trace-dump-2","dir":"","previous_headings":"Example 3 - compute_panel method from StatBoxplot","what":"Step 4. Inspect trace dump","title":"ggtrace","text":"Using returned environment opens powerful manipulations:","code":"boxplot_tracedump <- last_ggtrace()  # Trace dump is named after `trace_exprs` names(boxplot_tracedump) #> [1] \"splits\"      \"combined\"    \"runtime_env\"  # Inspect the splits sapply(boxplot_tracedump[[\"splits\"]], nrow) #>   1   2   3   4   5  #>  26  51 127 144 152 lapply(boxplot_tracedump$splits, head, 3) #> $`1` #>    x    y PANEL group #> 9  1 65.1     1     1 #> 92 1 55.1     1     1 #> 98 1 66.3     1     1 #>  #> $`2` #>    x    y PANEL group #> 3  2 56.9     1     2 #> 5  2 63.3     1     2 #> 11 2 64.0     1     2 #>  #> $`3` #>   x    y PANEL group #> 6 3 62.8     1     3 #> 7 3 62.3     1     3 #> 8 3 61.9     1     3 #>  #> $`4` #>    x    y PANEL group #> 2  4 59.8     1     4 #> 4  4 62.4     1     4 #> 13 4 60.4     1     4 #>  #> $`5` #>    x    y PANEL group #> 1  5 61.5     1     5 #> 12 5 62.8     1     5 #> 14 5 62.2     1     5  # Manually calculating some boxplot parameters lapply(boxplot_tracedump[[\"splits\"]], function(group) {   quantile(group$y, c(0, 0.25, 0.5, 0.75, 1)) }) #> $`1` #>     0%    25%    50%    75%   100%  #> 53.100 58.850 64.800 65.775 68.100  #>  #> $`2` #>    0%   25%   50%   75%  100%  #> 56.90 60.20 63.30 63.95 65.20  #>  #> $`3` #>   0%  25%  50%  75% 100%  #> 57.5 60.7 62.0 63.1 64.0  #>  #> $`4` #>     0%    25%    50%    75%   100%  #> 58.000 60.700 61.500 62.325 63.000  #>  #> $`5` #>    0%   25%   50%   75%  100%  #> 58.80 61.30 61.75 62.20 62.90  # The combined result boxplot_tracedump[[\"combined\"]] #>   ymin lower middle  upper ymax               outliers notchupper notchlower x #> 1 53.1 58.85  64.80 65.775 68.1                          66.94580   62.65420 1 #> 2 56.9 60.20  63.30 63.950 65.2                          64.12967   62.47033 2 #> 3 57.5 60.70  62.00 63.100 64.0                          62.33649   61.66351 3 #> 4 58.3 60.70  61.50 62.325 63.0 58.0, 58.0, 58.2, 58.0   61.71396   61.28604 4 #> 5 60.1 61.30  61.75 62.200 62.9       58.8, 59.9, 59.9   61.86534   61.63466 5 #>   width relvarwidth flipped_aes PANEL group #> 1  0.75    5.099020       FALSE     1     1 #> 2  0.75    7.141428       FALSE     1     2 #> 3  0.75   11.269428       FALSE     1     3 #> 4  0.75   12.000000       FALSE     1     4 #> 5  0.75   12.328828       FALSE     1     5 # What was inside the method environment? ls(envir = boxplot_tracedump[[\"runtime_env\"]]) #> [1] \"data\"   \"groups\" \"scales\" \"self\"   \"stats\"  # Evaluate the expression in Step 6 with the method's runtime environment eval(   ggbody(Stat$compute_panel)[[6]],   envir = boxplot_tracedump[[\"runtime_env\"]] ) #>   ymin lower middle  upper ymax               outliers notchupper notchlower x #> 1 53.1 58.85  64.80 65.775 68.1                          66.94580   62.65420 1 #> 2 56.9 60.20  63.30 63.950 65.2                          64.12967   62.47033 2 #> 3 57.5 60.70  62.00 63.100 64.0                          62.33649   61.66351 3 #> 4 58.3 60.70  61.50 62.325 63.0 58.0, 58.0, 58.2, 58.0   61.71396   61.28604 4 #> 5 60.1 61.30  61.75 62.200 62.9       58.8, 59.9, 59.9   61.86534   61.63466 5 #>   width relvarwidth flipped_aes PANEL group #> 1  0.75    5.099020       FALSE     1     1 #> 2  0.75    7.141428       FALSE     1     2 #> 3  0.75   11.269428       FALSE     1     3 #> 4  0.75   12.000000       FALSE     1     4 #> 5  0.75   12.328828       FALSE     1     5  # Manually call the compute_group method from StatBoxplot to apply # transformation to the third group using the method environment eval(   quote(StatBoxplot$compute_group(groups[[3]], scales, ...)),   envir = boxplot_tracedump[[\"runtime_env\"]] ) #>   ymin lower middle upper ymax outliers notchupper notchlower x width #> 1 57.5  60.7     62  63.1   64            62.33649   61.66351 3  0.75 #>   relvarwidth flipped_aes #> 1    11.26943       FALSE"},{"path":[]},{"path":"/index.html","id":"step-1-make-plot-3","dir":"","previous_headings":"Example 4 - compute_group method from StatSina {ggforce}","what":"Step 1. Make plot","title":"ggtrace","text":"","code":"library(ggforce) # v.0.3.3  sina_plot <- ggplot(diamonds[diamonds$cut == \"Ideal\",][1:50,], aes(cut, depth)) +   geom_violin() +   geom_sina(seed = 2021) +   ggtitle(\"Original\") sina_plot"},{"path":"/index.html","id":"step-2-inspect-body-of-the-ggproto-method-3","dir":"","previous_headings":"Example 4 - compute_group method from StatSina {ggforce}","what":"Step 2. Inspect body of the ggproto method","title":"ggtrace","text":"","code":"ggbody(StatSina$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> if (nrow(data) == 0) return(NULL) #>  #> [[3]] #> if (nrow(data) < 3) { #>     data$density <- 0 #>     data$scaled <- 1 #> } else if (method == \"density\") { #>     range <- range(data$y, na.rm = TRUE) #>     bw <- calc_bw(data$y, bw) #>     dens <- compute_density(data$y, data$w, from = range[1],  #>         to = range[2], bw = bw, adjust = adjust, kernel = kernel) #>     densf <- stats::approxfun(dens$x, dens$density, rule = 2) #>     data$density <- densf(data$y) #>     data$scaled <- data$density/max(dens$density) #>     data #> } else { #>     bin_index <- cut(data$y, bins, include.lowest = TRUE, labels = FALSE) #>     data$density <- tapply(bin_index, bin_index, length)[as.character(bin_index)] #>     data$density[data$density <= bin_limit] <- 0 #>     data$scaled <- data$density/max(data$density) #> } #>  #> [[4]] #> if (length(unique(data$x)) > 1) { #>     width <- diff(range(data$x)) * maxwidth #> } else { #>     width <- maxwidth #> } #>  #> [[5]] #> data$width <- width #>  #> [[6]] #> data$n <- nrow(data) #>  #> [[7]] #> data$x <- mean(range(data$x)) #>  #> [[8]] #> data"},{"path":"/index.html","id":"step-3-ggtrace---inject-code-that-modifies-method-env","dir":"","previous_headings":"Example 4 - compute_group method from StatSina {ggforce}","what":"Step 3. ggtrace() - inject code that modifies method env","title":"ggtrace","text":"effect ephemeral = TRUE default ggtrace(), meaning last plot saved sina_plot_modified rendered modifications. confirm method restored exit:","code":"ggtrace(   method = StatSina$compute_group,   trace_steps = c(1, 1, 8),   trace_exprs = rlang::exprs(     data,                      # 1. What does the data passed in look like at the start?     data <- dplyr::mutate(     # 2. Modify data in-place in the method environment       data,                y = y + 1,                 # Shift the points up       x = x - .2                 # Shift the points left     ),     data                       # 3. What do the stat transformations on the                                #    manipulated data look like at the end?   ),   verbose = FALSE ) #> `StatSina$compute_group` now being traced.  sina_plot_modified <- ggplotGrob(sina_plot + ggtitle(\"Modified\")) #> Triggering trace on `StatSina$compute_group` #> Untracing `StatSina$compute_group` on exit. grid.draw(sina_plot_modified) sina_plot sina_plot + patchwork::wrap_ggplot_grob(sina_plot_modified)"},{"path":"/index.html","id":"step-4-inspect-trace-dump-3","dir":"","previous_headings":"Example 4 - compute_group method from StatSina {ggforce}","what":"Step 4. Inspect trace dump","title":"ggtrace","text":"","code":"sina_tracedump <- last_ggtrace()  # StatSina did calculations on the modified data in the last `ggtrace()` lapply(sina_tracedump, head, 3) #> [[1]] #>   x    y PANEL group #> 1 1 61.5     1     1 #> 2 1 62.8     1     1 #> 3 1 62.2     1     1 #>  #> [[2]] #>     x    y PANEL group #> 1 0.8 62.5     1     1 #> 2 0.8 63.8     1     1 #> 3 0.8 63.2     1     1 #>  #> [[3]] #>     x    y PANEL group   density    scaled width  n #> 1 0.8 62.5     1     1 0.4632389 0.8454705   0.9 50 #> 2 0.8 63.8     1     1 0.2134967 0.3896590   0.9 50 #> 3 0.8 63.2     1     1 0.4973098 0.9076543   0.9 50"},{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2021 June Choe Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/reference/get_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Get ggproto methods — get_method","title":"Get ggproto methods — get_method","text":"Get ggproto methods","code":""},{"path":"/reference/get_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get ggproto methods — get_method","text":"","code":"get_method(method, inherit = FALSE)  ggbody(method, inherit = FALSE, as.list = TRUE)  ggformals(method, inherit = FALSE)"},{"path":"/reference/get_method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get ggproto methods — get_method","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method inherit Whether method searched closest parent. Defaults FALSE. TRUE, returns parent's method corresponding ggbody() code message. .list Whether ggbody() return body method list. Defaults TRUE.","code":""},{"path":"/reference/get_method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get ggproto methods — get_method","text":"list","code":""},{"path":"/reference/get_method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get ggproto methods — get_method","text":"get_method() returns method. ggbody() returns body method. ggformals() returns formals method.","code":""},{"path":"/reference/get_method.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Get ggproto methods — get_method","text":"get_method() calls get(\"method\", ggproto) hood. get(\"method\", ggproto) syntax long form ggproto$method retrieves actual function body. subtle important difference inspecting ggproto methods. example, works: debugonce(get(\"compute_group\", StatCount)) fails insert break point: debugonce(StatCount$compute_group) get_method() designed worry distinction.","code":""},{"path":"/reference/get_method.html","id":"gotchas","dir":"Reference","previous_headings":"","what":"Gotchas","title":"Get ggproto methods — get_method","text":"method traced via ggtrace() ggedit(), get_method() return current modified state method. v0.3.5, calling get_method() method trace return warning emphasize fact. using inherit = TRUE, make sure ggproto objects class(ggproto) available (loading packages defined, example). hood, get_method() loops parents search method, needs able evaluate element class(ggproto) object.","code":""},{"path":"/reference/get_method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get ggproto methods — get_method","text":"","code":"library(ggplot2)  # Uninformative StatCount$compute_group #> <ggproto method> #>   <Wrapper function> #>     function (...)  #> f(..., self = self) #>  #>   <Inner function (f)> #>     function (self, data, scales, width = NULL, flipped_aes = FALSE)  #> { #>     data <- flip_data(data, flipped_aes) #>     x <- data$x #>     weight <- data$weight %||% rep(1, length(x)) #>     count <- as.numeric(tapply(weight, x, sum, na.rm = TRUE)) #>     count[is.na(count)] <- 0 #>     bars <- new_data_frame(list(count = count, prop = count/sum(abs(count)),  #>         x = sort(unique(x)), width = width, flipped_aes = flipped_aes),  #>         n = length(count)) #>     flip_data(bars, flipped_aes) #> } formals(StatCount$compute_group) #> $... #>  #>  body(StatCount$compute_group) #> f(..., self = self)  # Errors # get(StatCount$compute_group)  # Informative get_method(StatCount$compute_group) #> function (self, data, scales, width = NULL, flipped_aes = FALSE)  #> { #>     data <- flip_data(data, flipped_aes) #>     x <- data$x #>     weight <- data$weight %||% rep(1, length(x)) #>     count <- as.numeric(tapply(weight, x, sum, na.rm = TRUE)) #>     count[is.na(count)] <- 0 #>     bars <- new_data_frame(list(count = count, prop = count/sum(abs(count)),  #>         x = sort(unique(x)), width = width, flipped_aes = flipped_aes),  #>         n = length(count)) #>     flip_data(bars, flipped_aes) #> } #> <bytecode: 0x0000000017272a50> #> <environment: namespace:ggplot2> ggformals(StatCount$compute_group) # formals(get_method(StatCount$compute_group)) #> $self #>  #>  #> $data #>  #>  #> $scales #>  #>  #> $width #> NULL #>  #> $flipped_aes #> [1] FALSE #>  ggbody(StatCount$compute_group)    # body(get_method(StatCount$compute_group)) #> [[1]] #> `{` #>  #> [[2]] #> data <- flip_data(data, flipped_aes) #>  #> [[3]] #> x <- data$x #>  #> [[4]] #> weight <- data$weight %||% rep(1, length(x)) #>  #> [[5]] #> count <- as.numeric(tapply(weight, x, sum, na.rm = TRUE)) #>  #> [[6]] #> count[is.na(count)] <- 0 #>  #> [[7]] #> bars <- new_data_frame(list(count = count, prop = count/sum(abs(count)),  #>     x = sort(unique(x)), width = width, flipped_aes = flipped_aes),  #>     n = length(count)) #>  #> [[8]] #> flip_data(bars, flipped_aes) #>   # Works for ggproto in extension packages  ggbody(ggforce::StatDelaunaySegment$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> if (any(duplicated(data[, c(\"x\", \"y\")]))) { #>     warning(\"stat_delaunay_segment: dropping duplicated points\",  #>         call. = FALSE) #> } #>  #> [[3]] #> if (normalize) { #>     x_range <- range(data$x, na.rm = TRUE, finite = TRUE) #>     y_range <- range(data$y, na.rm = TRUE, finite = TRUE) #>     data$x <- rescale(data$x, from = x_range) * asp.ratio #>     data$y <- rescale(data$y, from = y_range) #>     if (!is.null(bound)) { #>         bound[1:2] <- rescale(bound[1:2], from = x_range) * asp.ratio #>         bound[3:4] <- rescale(bound[3:4], from = x_range) #>     } #> } #>  #> [[4]] #> vor <- deldir::deldir(data$x, data$y, rw = bound, eps = eps,  #>     suppressMsge = TRUE) #>  #> [[5]] #> segments <- vor$delsgs[, 1:5] #>  #> [[6]] #> names(segments) <- c(\"x\", \"y\", \"xend\", \"yend\", \"group\") #>  #> [[7]] #> segments$group <- vor$ind.orig[segments$group] #>  #> [[8]] #> data <- cbind(segments[, 1:4], data[segments$group, !names(data) %in%  #>     c(\"x\", \"y\"), drop = FALSE]) #>  #> [[9]] #> if (normalize) { #>     data$x <- rescale(data$x/asp.ratio, to = x_range, from = c(0,  #>         1)) #>     data$xend <- rescale(data$xend/asp.ratio, to = x_range, from = c(0,  #>         1)) #>     data$y <- rescale(data$y, to = y_range, from = c(0, 1)) #>     data$yend <- rescale(data$yend, to = y_range, from = c(0,  #>         1)) #> } #>  #> [[10]] #> data #>   library(ggforce) ggbody(StatBezier$compute_panel) #> [[1]] #> `{` #>  #> [[2]] #> if (is.null(data)) return(data) #>  #> [[3]] #> nControls <- table(data$group) #>  #> [[4]] #> controlRange <- range(nControls) #>  #> [[5]] #> if (min(controlRange) < 3 || max(controlRange) > 4) { #>     stop(\"Only support for quadratic and cubic beziers\") #> } #>  #> [[6]] #> data <- data[order(data$group), ] #>  #> [[7]] #> groups <- unique(data$group) #>  #> [[8]] #> paths <- getBeziers(data$x, data$y, match(data$group, groups),  #>     n) #>  #> [[9]] #> paths <- data.frame(x = paths$paths[, 1], y = paths$paths[, 2],  #>     group = groups[paths$pathID]) #>  #> [[10]] #> paths$index <- rep(seq(0, 1, length.out = n), length(nControls)) #>  #> [[11]] #> dataIndex <- rep(match(unique(data$group), data$group), each = n) #>  #> [[12]] #> cbind(paths, data[dataIndex, !names(data) %in% c(\"x\", \"y\", \"group\"),  #>     drop = FALSE]) #>   # `inherit = TRUE` will return the method from the closest parent  ## ERRORS: ## get_method(StatBoxplot$compute_panel) ## ggbody(StatBoxplot$compute_panel) ## ggformals(StatBoxplot$compute_panel) ggbody(StatBoxplot$compute_panel, inherit = TRUE) #> Method inherited from `Stat$compute_panel` #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(new_data_frame()) #>  #> [[3]] #> groups <- split(data, data$group) #>  #> [[4]] #> stats <- lapply(groups, function(group) { #>     self$compute_group(data = group, scales = scales, ...) #> }) #>  #> [[5]] #> stats <- mapply(function(new, old) { #>     if (empty(new))  #>         return(new_data_frame()) #>     unique <- uniquecols(old) #>     missing <- !(names(unique) %in% names(new)) #>     cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #> }, stats, groups, SIMPLIFY = FALSE) #>  #> [[6]] #> rbind_dfs(stats) #>  ggbody(Stat$compute_panel) #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(new_data_frame()) #>  #> [[3]] #> groups <- split(data, data$group) #>  #> [[4]] #> stats <- lapply(groups, function(group) { #>     self$compute_group(data = group, scales = scales, ...) #> }) #>  #> [[5]] #> stats <- mapply(function(new, old) { #>     if (empty(new))  #>         return(new_data_frame()) #>     unique <- uniquecols(old) #>     missing <- !(names(unique) %in% names(new)) #>     cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #> }, stats, groups, SIMPLIFY = FALSE) #>  #> [[6]] #> rbind_dfs(stats) #>   # Navigating complex inheritance class(GeomArcBar) #> [1] \"GeomArcBar\"  \"GeomShape\"   \"GeomPolygon\" \"Geom\"        \"ggproto\"     #> [6] \"gg\"          invisible(ggbody(GeomArcBar$default_aes, inherit = TRUE)) # self #> Method 'default_aes' is defined for `GeomArcBar`, not inherited. invisible(ggbody(GeomArcBar$draw_panel, inherit = TRUE))  # parent #> Method inherited from `GeomShape$draw_panel` invisible(ggbody(GeomArcBar$draw_key, inherit = TRUE))    # grandparent #> Method inherited from `GeomPolygon$draw_key` invisible(ggbody(GeomArcBar$draw_group, inherit = TRUE))  # top-level #> Method inherited from `Geom$draw_group`  # Works for custom ggproto # - Example from {ggplot2} \"Extending ggplot2\" vignette StatDensityCommon <- ggproto(\"StatDensityCommon\", Stat,   required_aes = \"x\",    setup_params = function(data, params) {     if (!is.null(params$bandwidth))       return(params)      xs <- split(data$x, data$group)     bws <- vapply(xs, bw.nrd0, numeric(1))     bw <- mean(bws)     message(\"Picking bandwidth of \", signif(bw, 3))      params$bandwidth <- bw     params   },    compute_group = function(data, scales, bandwidth = 1) {     d <- density(data$x, bw = bandwidth)     data.frame(x = d$x, y = d$y)   } )  as.list(body(get(\"compute_group\", StatDensityCommon))) #> [[1]] #> `{` #>  #> [[2]] #> d <- density(data$x, bw = bandwidth) #>  #> [[3]] #> data.frame(x = d$x, y = d$y) #>   ggbody(StatDensityCommon$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> d <- density(data$x, bw = bandwidth) #>  #> [[3]] #> data.frame(x = d$x, y = d$y) #>   # As of v.0.4.0, ggbody works for functions as well ggbody(sample) #> [[1]] #> `{` #>  #> [[2]] #> if (length(x) == 1L && is.numeric(x) && is.finite(x) && x >=  #>     1) { #>     if (missing(size))  #>         size <- x #>     sample.int(x, size, replace, prob) #> } else { #>     if (missing(size))  #>         size <- length(x) #>     x[sample.int(length(x), size, replace, prob)] #> } #>  ggtrace(sample, 1) #> `sample` now being traced. invisible(ggbody(sample)) #> Warning: `sample` is currently being traced is_traced(sample) #> [1] TRUE gguntrace(sample) #> `sample` no longer being traced."},{"path":"/reference/ggbody.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the body of a function or a method as a list — ggbody","title":"Retrieve the body of a function or a method as a list — ggbody","text":"Retrieve body function method list","code":""},{"path":"/reference/ggbody.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the body of a function or a method as a list — ggbody","text":"","code":"ggbody(method, inherit = FALSE)"},{"path":"/reference/ggbody.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the body of a function or a method as a list — ggbody","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method inherit Whether method searched closest parent. Defaults FALSE. TRUE, returns parent's method corresponding ggbody() code message.","code":""},{"path":"/reference/ggbody.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the body of a function or a method as a list — ggbody","text":"list","code":""},{"path":"/reference/ggbody.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Retrieve the body of a function or a method as a list — ggbody","text":"ggbody() calls .list(body(get(\"method\", ggproto))) hood. get(\"method\", ggproto) syntax long form ggproto$method retrieves actual function body. subtle important difference inspecting ggproto methods. example, works: debugonce(get(\"compute_group\", StatCount)) fails insert break point: debugonce(StatCount$compute_group) ggbody() designed worry distinction.","code":""},{"path":"/reference/ggbody.html","id":"gotchas","dir":"Reference","previous_headings":"","what":"Gotchas","title":"Retrieve the body of a function or a method as a list — ggbody","text":"method traced via ggtrace() ggedit(), ggbody() return current modified state method. v0.3.5, calling ggbody() method trace return warning emphasize fact. using inherit = TRUE, make sure ggproto objects class(ggproto) available (loading packages defined, example). hood, ggbody() loops parents search method, needs able evaluate element class(ggproto) object.","code":""},{"path":"/reference/ggbody.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the body of a function or a method as a list — ggbody","text":"","code":"library(ggplot2)  ggbody(StatCount$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> data <- flip_data(data, flipped_aes) #>  #> [[3]] #> x <- data$x #>  #> [[4]] #> weight <- data$weight %||% rep(1, length(x)) #>  #> [[5]] #> count <- as.numeric(tapply(weight, x, sum, na.rm = TRUE)) #>  #> [[6]] #> count[is.na(count)] <- 0 #>  #> [[7]] #> bars <- new_data_frame(list(count = count, prop = count/sum(abs(count)),  #>     x = sort(unique(x)), width = width, flipped_aes = flipped_aes),  #>     n = length(count)) #>  #> [[8]] #> flip_data(bars, flipped_aes) #>   # Works for ggproto in extension packages  ggbody(ggforce::StatDelaunaySegment$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> if (any(duplicated(data[, c(\"x\", \"y\")]))) { #>     warning(\"stat_delaunay_segment: dropping duplicated points\",  #>         call. = FALSE) #> } #>  #> [[3]] #> if (normalize) { #>     x_range <- range(data$x, na.rm = TRUE, finite = TRUE) #>     y_range <- range(data$y, na.rm = TRUE, finite = TRUE) #>     data$x <- rescale(data$x, from = x_range) * asp.ratio #>     data$y <- rescale(data$y, from = y_range) #>     if (!is.null(bound)) { #>         bound[1:2] <- rescale(bound[1:2], from = x_range) * asp.ratio #>         bound[3:4] <- rescale(bound[3:4], from = x_range) #>     } #> } #>  #> [[4]] #> vor <- deldir::deldir(data$x, data$y, rw = bound, eps = eps,  #>     suppressMsge = TRUE) #>  #> [[5]] #> segments <- vor$delsgs[, 1:5] #>  #> [[6]] #> names(segments) <- c(\"x\", \"y\", \"xend\", \"yend\", \"group\") #>  #> [[7]] #> segments$group <- vor$ind.orig[segments$group] #>  #> [[8]] #> data <- cbind(segments[, 1:4], data[segments$group, !names(data) %in%  #>     c(\"x\", \"y\"), drop = FALSE]) #>  #> [[9]] #> if (normalize) { #>     data$x <- rescale(data$x/asp.ratio, to = x_range, from = c(0,  #>         1)) #>     data$xend <- rescale(data$xend/asp.ratio, to = x_range, from = c(0,  #>         1)) #>     data$y <- rescale(data$y, to = y_range, from = c(0, 1)) #>     data$yend <- rescale(data$yend, to = y_range, from = c(0,  #>         1)) #> } #>  #> [[10]] #> data #>   library(ggforce) ggbody(StatBezier$compute_panel) #> [[1]] #> `{` #>  #> [[2]] #> if (is.null(data)) return(data) #>  #> [[3]] #> nControls <- table(data$group) #>  #> [[4]] #> controlRange <- range(nControls) #>  #> [[5]] #> if (min(controlRange) < 3 || max(controlRange) > 4) { #>     stop(\"Only support for quadratic and cubic beziers\") #> } #>  #> [[6]] #> data <- data[order(data$group), ] #>  #> [[7]] #> groups <- unique(data$group) #>  #> [[8]] #> paths <- getBeziers(data$x, data$y, match(data$group, groups),  #>     n) #>  #> [[9]] #> paths <- data.frame(x = paths$paths[, 1], y = paths$paths[, 2],  #>     group = groups[paths$pathID]) #>  #> [[10]] #> paths$index <- rep(seq(0, 1, length.out = n), length(nControls)) #>  #> [[11]] #> dataIndex <- rep(match(unique(data$group), data$group), each = n) #>  #> [[12]] #> cbind(paths, data[dataIndex, !names(data) %in% c(\"x\", \"y\", \"group\"),  #>     drop = FALSE]) #>   # `inherit = TRUE` will return the method from the closest parent  ## ERRORS: ## ggbody(StatBoxplot$compute_panel) ggbody(StatBoxplot$compute_panel, inherit = TRUE) #> Returning `ggbody(Stat$compute_panel)` #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(new_data_frame()) #>  #> [[3]] #> groups <- split(data, data$group) #>  #> [[4]] #> stats <- lapply(groups, function(group) { #>     self$compute_group(data = group, scales = scales, ...) #> }) #>  #> [[5]] #> stats <- mapply(function(new, old) { #>     if (empty(new))  #>         return(new_data_frame()) #>     unique <- uniquecols(old) #>     missing <- !(names(unique) %in% names(new)) #>     cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #> }, stats, groups, SIMPLIFY = FALSE) #>  #> [[6]] #> rbind_dfs(stats) #>  ggbody(Stat$compute_panel) #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(new_data_frame()) #>  #> [[3]] #> groups <- split(data, data$group) #>  #> [[4]] #> stats <- lapply(groups, function(group) { #>     self$compute_group(data = group, scales = scales, ...) #> }) #>  #> [[5]] #> stats <- mapply(function(new, old) { #>     if (empty(new))  #>         return(new_data_frame()) #>     unique <- uniquecols(old) #>     missing <- !(names(unique) %in% names(new)) #>     cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #> }, stats, groups, SIMPLIFY = FALSE) #>  #> [[6]] #> rbind_dfs(stats) #>   # Navigating complex inheritance class(GeomArcBar) #> [1] \"GeomArcBar\"  \"GeomShape\"   \"GeomPolygon\" \"Geom\"        \"ggproto\"     #> [6] \"gg\"          invisible(ggbody(GeomArcBar$default_aes, inherit = TRUE)) # self #> Method 'default_aes' is defined for `GeomArcBar`, not inherited. invisible(ggbody(GeomArcBar$draw_panel, inherit = TRUE))  # parent #> Returning `ggbody(GeomShape$draw_panel)` invisible(ggbody(GeomArcBar$draw_key, inherit = TRUE))    # grandparent #> Returning `ggbody(GeomPolygon$draw_key)` invisible(ggbody(GeomArcBar$draw_group, inherit = TRUE))  # top-level #> Returning `ggbody(Geom$draw_group)`  # Works for custom ggproto # - Example from {ggplot2} \"Extending ggplot2\" vignette StatDensityCommon <- ggproto(\"StatDensityCommon\", Stat,   required_aes = \"x\",    setup_params = function(data, params) {     if (!is.null(params$bandwidth))       return(params)      xs <- split(data$x, data$group)     bws <- vapply(xs, bw.nrd0, numeric(1))     bw <- mean(bws)     message(\"Picking bandwidth of \", signif(bw, 3))      params$bandwidth <- bw     params   },    compute_group = function(data, scales, bandwidth = 1) {     d <- density(data$x, bw = bandwidth)     data.frame(x = d$x, y = d$y)   } )  as.list(body(get(\"compute_group\", StatDensityCommon))) #> [[1]] #> `{` #>  #> [[2]] #> d <- density(data$x, bw = bandwidth) #>  #> [[3]] #> data.frame(x = d$x, y = d$y) #>   ggbody(StatDensityCommon$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> d <- density(data$x, bw = bandwidth) #>  #> [[3]] #> data.frame(x = d$x, y = d$y) #>   # As of v.0.4.0, ggbody works for functions as well ggbody(sample) #> [[1]] #> `{` #>  #> [[2]] #> if (length(x) == 1L && is.numeric(x) && is.finite(x) && x >=  #>     1) { #>     if (missing(size))  #>         size <- x #>     sample.int(x, size, replace, prob) #> } else { #>     if (missing(size))  #>         size <- length(x) #>     x[sample.int(length(x), size, replace, prob)] #> } #>  ggtrace(sample, 1) #> `sample` now being traced. invisible(ggbody(sample)) #> Warning: `sample` is currently being traced is_traced(sample) #> [1] TRUE gguntrace(sample) #> `sample` no longer being traced."},{"path":"/reference/ggdebugonce.html","id":null,"dir":"Reference","previous_headings":"","what":"Debugonce a ggproto method — ggdebugonce","title":"Debugonce a ggproto method — ggdebugonce","text":"Debugonce ggproto method","code":""},{"path":"/reference/ggdebugonce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Debugonce a ggproto method — ggdebugonce","text":"","code":"ggdebugonce(method, ...)"},{"path":"/reference/ggdebugonce.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Debugonce a ggproto method — ggdebugonce","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Ignored. Designed ease calling function modifying call earlier {ggtrace} function interactive contexts.","code":""},{"path":"/reference/ggedit.html","id":null,"dir":"Reference","previous_headings":"","what":"Interactively edit the source code — ggedit","title":"Interactively edit the source code — ggedit","text":"Interactively edit source code","code":""},{"path":"/reference/ggedit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interactively edit the source code — ggedit","text":"","code":"ggedit(method, remove_trace = FALSE, ...)"},{"path":"/reference/ggedit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interactively edit the source code — ggedit","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method remove_trace Whether edit clean slate. Defaults FALSE. ... Unused, extensibility.","code":""},{"path":"/reference/ggedit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interactively edit the source code — ggedit","text":"Like base::trace(), edit effect gguntrace() called. Changes ggedit() cumulative, ggedit() inform via warning making edit top existing edit. Call gguntrace() object first like edit method's original unaltered source code. works interactive contexts.","code":""},{"path":"/reference/ggedit.html","id":"gotchas","dir":"Reference","previous_headings":"","what":"Gotchas","title":"Interactively edit the source code — ggedit","text":"Calling ggtrace() method changes ggedit() remove changes ggedit(). possible combine features, disabled package keep API consistent. philosophy {ggtrace} mix programmatic interactive workflows.","code":""},{"path":[]},{"path":"/reference/ggedit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interactively edit the source code — ggedit","text":"","code":"if (FALSE) {  jitter_plot <- ggplot(diamonds[1:1000,], aes(cut, depth)) +   geom_point(position = position_jitter(width = 0.2, seed = 2021))  # Interactively modify the method's source code in text editor ggedit(PositionJitter$compute_layer)  # Check the edited code ggbody(PositionJitter$compute_layer)  # Execute method with edit jitter_plot  # Untrace gguntrace(PositionJitter$compute_layer)  # Edit is removed in the next call jitter_plot  }"},{"path":"/reference/ggeval_silent.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate printing of a ggplot object without side effects — ggeval_silent","title":"Simulate printing of a ggplot object without side effects — ggeval_silent","text":"Calls ggplot_gtable(ggplot_build(x)), executes instructions plotting x without side-effects ggplot2:::print.ggplot, namely:","code":""},{"path":"/reference/ggeval_silent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate printing of a ggplot object without side effects — ggeval_silent","text":"","code":"ggeval_silent(x)"},{"path":"/reference/ggeval_silent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate printing of a ggplot object without side effects — ggeval_silent","text":"x ggplot","code":""},{"path":"/reference/ggeval_silent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate printing of a ggplot object without side effects — ggeval_silent","text":"gtable","code":""},{"path":"/reference/ggeval_silent.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate printing of a ggplot object without side effects — ggeval_silent","text":"last_plot() overriden grid.draw() called (= nothing gets rendered/drawn)","code":""},{"path":"/reference/ggtrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Insert traces for delayed evaluation — ggtrace","title":"Insert traces for delayed evaluation — ggtrace","text":"Insert traces delayed evaluation","code":""},{"path":"/reference/ggtrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Insert traces for delayed evaluation — ggtrace","text":"","code":"ggtrace(   method,   trace_steps,   trace_exprs,   once = TRUE,   use_names = TRUE,   ...,   print_output = TRUE,   verbose = FALSE )"},{"path":"/reference/ggtrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Insert traces for delayed evaluation — ggtrace","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method trace_steps sorted numeric vector positions method's body trace. Negative indices reference steps last, -1 references last step body. trace_exprs list expressions evaluate position specified trace_steps. single expression provided, recycled match length trace_steps. simply run step return output, can use ~step keyword. step assign expression, value assigned variable returned. trace_exprs provided, ggtrace() called ~step default. Whether untrace() method exit. FALSE, creates persistent trace active gguntrace() called method. Defaults TRUE. use_names Whether trace dump use names trace_exprs. Defaults TRUE. ... Unused, extensibility. print_output Whether print() output expression console. Defaults TRUE. verbose Whether logs printed trace triggered. Encompasses print_output, meaning verbose = FALSE also triggers effect print_output = FALSE consequence. Defaults FALSE.","code":""},{"path":"/reference/ggtrace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Insert traces for delayed evaluation — ggtrace","text":"ggtrace() wrapper around base::trace() called ggproto method. calls base::untrace() exit default, make effect ephemeral like base::debugonce(). major feature ability pass multiple positions expressions trace_steps trace_exprs inspect, capture, modify run time environment ggproto methods. recommended consult output ggbody() deciding expressions evaluate steps. output expressions passed trace_exprs printed tracing takes place. list outputs ggtrace() (\"trace dumps\") can returned inspection last_ggtrace() global_ggtrace().","code":""},{"path":"/reference/ggtrace.html","id":"workflows","dir":"Reference","previous_headings":"","what":"Workflows","title":"Insert traces for delayed evaluation — ggtrace","text":"Broadly, four flavors working {ggtrace} package, listed order increasing complexity: Inspect: canonical use ggtrace() make queries, expressions passed evaluated output returned, potentially inspection. Capture: strategy returning method's runtime environment complex explorations outside debugging context. method's environment contextualizes self object addition making inherited params local variables available. reference method's runtime environment can returned environment(), trace_exprs = quote(environment()). Note environments mutable, meaning environment() returned first last steps reference environment. get snapshot environment particular step, can return deep copy rlang::env_clone(environment()). Inject: strategy modifying behavior method runs passing expressions make assignments. example, trace_steps = c(1, 10) trace_exprs = rlang::exprs(<- 5, ) first assign new variable step 1, return value 5 step 10. can also used modify important variables like quote(data$x <- data$x * 10). like inject object global environment, can make use !! (bang-bang) operator {rlang}, like : rlang::expr(data <- !!modified_data). Note execution environment created anew time method ran, modifying environment previous execution affect future calls method. like capture modified plot output assign variable, can ggplotGrob(). can render modified plot print(). Edit: also possible make arbitrary modifications method's source code, stays effect method untraced. also handled base::trace(), workflow fundamentally interactive. Therefore, refactored function ggedit(). See ?ggedit details.","code":""},{"path":"/reference/ggtrace.html","id":"gotchas","dir":"Reference","previous_headings":"","what":"Gotchas","title":"Insert traces for delayed evaluation — ggtrace","text":"wrap ggplot invisible() silence ggtrace(), plot build, also means tracing triggered. print/plot method ggplot triggers evaluation plot code. recommended allow ggtrace() print information, really like silence , can wrapping plot function forces evaluation first, like ggplotGrob, invisible(ggplotGrob(<plot>)). reason ggtrace(= TRUE) fails untrace exit, may accidentally trigger trace . check method traced, call is_traced(). can also always call gguntrace() since unlike base::untrace(), error trace exist method. Instead, gguntrace() nothing case simply inform trace remove. base::trace() wraps method body special environment, possible inspect method/function called , even something like rlang::caller_env(). traverse wrapping environments created base::trace() eventually ends looping around.","code":""},{"path":"/reference/ggtrace.html","id":"messages","dir":"Reference","previous_headings":"","what":"Messages","title":"Insert traces for delayed evaluation — ggtrace","text":"Various information sent console whenever trace triggered. can control gets displayed print_output verbose, TRUE default. print_output simply calls print() evaluated expressions, turning may desirable expressions trace_exprs evaluates long dataframe vector. verbose controls information printed console including print(), setting verbose = FALSE mean message()s displayed. Lastly, can suppress message() ggtrace() options(ggtrace.suppressMessages = TRUE), though suppressing messages generally recommended.","code":""},{"path":[]},{"path":"/reference/ggtrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Insert traces for delayed evaluation — ggtrace","text":"","code":"# One example of an Inspect workflow ----  library(ggplot2)  jitter_plot <- ggplot(diamonds[1:1000,], aes(cut, depth)) +   geom_point(position = position_jitter(width = 0.2, seed = 2021))  jitter_plot   ggbody(PositionJitter$compute_layer) #> [[1]] #> `{` #>  #> [[2]] #> trans_x <- if (params$width > 0) function(x) jitter(x, amount = params$width) #>  #> [[3]] #> trans_y <- if (params$height > 0) function(x) jitter(x, amount = params$height) #>  #> [[4]] #> x_aes <- intersect(ggplot_global$x_aes, names(data)) #>  #> [[5]] #> x <- if (length(x_aes) == 0) 0 else data[[x_aes[1]]] #>  #> [[6]] #> y_aes <- intersect(ggplot_global$y_aes, names(data)) #>  #> [[7]] #> y <- if (length(y_aes) == 0) 0 else data[[y_aes[1]]] #>  #> [[8]] #> dummy_data <- new_data_frame(list(x = x, y = y), nrow(data)) #>  #> [[9]] #> fixed_jitter <- with_seed_null(params$seed, transform_position(dummy_data,  #>     trans_x, trans_y)) #>  #> [[10]] #> x_jit <- fixed_jitter$x - x #>  #> [[11]] #> y_jit <- fixed_jitter$y - y #>  #> [[12]] #> transform_position(data, function(x) x + x_jit, function(x) x +  #>     y_jit) #>   ## Step 1 ==== ## Inspect what `data` look like at the start of the function ggtrace(PositionJitter$compute_layer, trace_steps = 1, trace_exprs = quote(head(data))) #> `PositionJitter$compute_layer` now being traced.  jitter_plot #> Triggering trace on `PositionJitter$compute_layer` #> Untracing `PositionJitter$compute_layer` on exit.   ## Step 2 ==== ## What does `data` look like at the end of the method? Unfortunately, `trace()` only lets us enter ## at the beginning of a step, so we can't inspect what happens after the last step is evaluated. To ## address this, `ggtrace()` offers a `~step` keyword which gets substituted for the current line. ## We also set `print_output = FALSE` to disable printing of the output ggtrace(   PositionJitter$compute_layer,   trace_steps = 12,   trace_exprs = quote(~step), # This is the default if `trace_exprs` is not provided   print_output = FALSE ) #> `PositionJitter$compute_layer` now being traced.  # We wrap the plot in `ggplotGrob()` and `invisible()` to force # its evaluation while suppressing its rendering invisible(ggplotGrob(jitter_plot)) #> Triggering trace on `PositionJitter$compute_layer` #> Untracing `PositionJitter$compute_layer` on exit.  # The output of the evaluated expressions can be inspected with `last_ggtrace()` head(last_ggtrace()[[1]]) #>          x        y PANEL group #> 1 4.980507 61.50684     1     5 #> 2 4.113512 59.77872     1     4 #> 3 2.083873 56.86655     1     2 #> 4 3.952698 62.42703     1     4 #> 5 2.054530 63.29763     1     2 #> 6 3.080538 62.77536     1     3  ## Step 3 ==== ## If we want both to be returned at the same time for an easier comparison, we can pass in a ## (named) list of expressions. ggtrace(   PositionJitter$compute_layer,   trace_steps = c(1, 12),   trace_exprs = rlang::exprs(     before_jitter = data,     after_jitter = ~step   ),   verbose = FALSE ) #> `PositionJitter$compute_layer` now being traced.  invisible(ggplotGrob(jitter_plot)) #> Triggering trace on `PositionJitter$compute_layer` #> Untracing `PositionJitter$compute_layer` on exit.  ## Step 4 ==== ## The output of the evaluated expressions can be inspected with `last_ggtrace()` jitter_tracedump <- last_ggtrace()  lapply(jitter_tracedump, head, 3) #> $before_jitter #>   x    y PANEL group #> 1 5 61.5     1     5 #> 2 4 59.8     1     4 #> 3 2 56.9     1     2 #>  #> $after_jitter #>          x        y PANEL group #> 1 4.980507 61.50684     1     5 #> 2 4.113512 59.77872     1     4 #> 3 2.083873 56.86655     1     2 #>   jitter_distances <- jitter_tracedump[[\"before_jitter\"]]$x -   jitter_tracedump[[\"after_jitter\"]]$x  range(jitter_distances) #> [1] -0.1994971  0.1995346 jitter_plot$layers[[1]]$position$width #> [1] 0.2"},{"path":"/reference/ggtraceback.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect the call stack on enter — ggtraceback","title":"Inspect the call stack on enter — ggtraceback","text":"Inspect call stack enter","code":""},{"path":"/reference/ggtraceback.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect the call stack on enter — ggtraceback","text":"","code":"ggtraceback(method, ...)"},{"path":"/reference/ggtraceback.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect the call stack on enter — ggtraceback","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Arguments passed rlang::trace_back top first frame environment included backtrace. becomes top backtrace tree represents oldest call backtrace. needed particular call trace_back() indirectly larger context, example tests inside RMarkdown document want knitr evaluation mechanisms appear backtrace. supplied, rlang_trace_top_env global option consulted. makes possible trim embedding context backtraces created option set. knitr progress, default value option knitr::knit_global() knitr context trimmed backtraces. bottom last frame environment included backtrace. becomes rightmost leaf backtrace tree represents youngest call backtrace. Set like capture backtrace without capture context. Can also integer passed caller_env().","code":""},{"path":"/reference/ggtraceback.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Inspect the call stack on enter — ggtraceback","text":"Calls rlang::trace_back() upon first entering function method. Note ggtraceback() ever prints back trace calls gguntrace() first time triggered. complex inspections call stack, ggedit() recommended.","code":""},{"path":"/reference/ggtraceback.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Inspect the call stack on enter — ggtraceback","text":"output rlang::trace_back() logged tracedumps (last_ggtrace() global_ggtrace())","code":""},{"path":"/reference/ggtrace_capture.html","id":null,"dir":"Reference","previous_headings":"","what":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"Returns ggproto method function arguments pre-filled values first called","code":""},{"path":"/reference/ggtrace_capture.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"","code":"ggtrace_capture(x, ...)"},{"path":"/reference/ggtrace_capture.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"x ggplot object ... Passed ggtrace(). method capture specified .","code":""},{"path":"/reference/ggtrace_capture.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"function","code":""},{"path":"/reference/ggtrace_capture.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"methods take ..., arguments passed ... runtime, captured stored .dots_captured argument returned function, accessible via formals(x)$.dots_captured. returned function also expose ..., defaults .dots_captured passed captured method unless also provided ...","code":""},{"path":"/reference/ggtrace_capture.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"","code":"library(ggplot2)  set.seed(47) df <- as.data.frame(matrix(sample(5, 50, TRUE), ncol = 2)) df #>    V1 V2 #> 1   3  5 #> 2   1  5 #> 3   2  4 #> 4   4  1 #> 5   1  5 #> 6   2  5 #> 7   5  1 #> 8   1  5 #> 9   5  2 #> 10  4  1 #> 11  5  3 #> 12  5  5 #> 13  4  3 #> 14  3  3 #> 15  3  5 #> 16  4  3 #> 17  1  1 #> 18  5  2 #> 19  2  5 #> 20  5  2 #> 21  2  2 #> 22  5  3 #> 23  3  5 #> 24  3  2 #> 25  1  3  base <- ggplot(df, aes(x = V1, y = V2))  p1 <- base + stat_summary(orientation = \"x\") p1 #> No summary function supplied, defaulting to `mean_se()`   p1_compute_panel <- ggtrace_capture(p1, method = StatSummary$compute_panel)  # `p1_compute_panel` is a copy of the ggproto method body(p1_compute_panel) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> } ggbody(StatSummary$compute_panel, as.list = FALSE) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> }  # Its arguments are pre-filled (captured at runtime) formals(p1_compute_panel) #> $data #>    x y PANEL group #> 1  3 5     1    -1 #> 2  1 5     1    -1 #> 3  2 4     1    -1 #> 4  4 1     1    -1 #> 5  1 5     1    -1 #> 6  2 5     1    -1 #> 7  5 1     1    -1 #> 8  1 5     1    -1 #> 9  5 2     1    -1 #> 10 4 1     1    -1 #> 11 5 3     1    -1 #> 12 5 5     1    -1 #> 13 4 3     1    -1 #> 14 3 3     1    -1 #> 15 3 5     1    -1 #> 16 4 3     1    -1 #> 17 1 1     1    -1 #> 18 5 2     1    -1 #> 19 2 5     1    -1 #> 20 5 2     1    -1 #> 21 2 2     1    -1 #> 22 5 3     1    -1 #> 23 3 5     1    -1 #> 24 3 2     1    -1 #> 25 1 3     1    -1 #>  #> $scales #> $scales$x #> <ScaleContinuousPosition> #>  Range:     1 --    5 #>  Limits:    1 --    5 #>  #> $scales$y #> <ScaleContinuousPosition> #>  Range:  1.42 -- 4.71 #>  Limits: 1.42 -- 4.71 #>  #>  #> $fun.data #> NULL #>  #> $fun #> NULL #>  #> $fun.max #> NULL #>  #> $fun.min #> NULL #>  #> $fun.args #> list() #>  #> $na.rm #> [1] FALSE #>  #> $flipped_aes #> [1] FALSE #>   # Runs as it should p1_compute_panel() #> No summary function supplied, defaulting to `mean_se()` #>   x group        y     ymin     ymax PANEL flipped_aes #> 1 1    -1 3.800000 3.000000 4.600000     1       FALSE #> 2 2    -1 4.000000 3.292893 4.707107     1       FALSE #> 3 3    -1 4.000000 3.367544 4.632456     1       FALSE #> 4 4    -1 2.000000 1.422650 2.577350     1       FALSE #> 5 5    -1 2.571429 2.090500 3.052357     1       FALSE  # You can inspect changes to its behavior outisde of ggplot # For example, see what happens when aes is flipped via `orientation = \"y\"` p1_compute_panel(flipped_aes = TRUE) #> No summary function supplied, defaulting to `mean_se()` #>   y group        x     xmin     xmax PANEL flipped_aes #> 1 1    -1 3.500000 2.633975 4.366025     1        TRUE #> 2 2    -1 4.000000 3.367544 4.632456     1        TRUE #> 3 3    -1 3.666667 3.052030 4.281303     1        TRUE #> 4 4    -1 2.000000       NA       NA     1        TRUE #> 5 5    -1 2.333333 1.892375 2.774292     1        TRUE  # We confirm this output to be true when `orientation = \"y\"` p2 <- base + stat_summary(orientation = \"y\") p2_compute_panel <- ggtrace_capture(p2, method = StatSummary$compute_panel) #> Warning: Removed 1 rows containing missing values (geom_segment).  identical(p1_compute_panel(flipped_aes = TRUE), p2_compute_panel()) #> No summary function supplied, defaulting to `mean_se()` #> No summary function supplied, defaulting to `mean_se()` #> [1] TRUE  # You can interactively explore with `debugonce(p2_compute_panel)`   # Note that the captured method looks slightly different if the method takes `...` p3 <- base + stat_smooth() + geom_jitter() p3 #> `geom_smooth()` using method = 'loess' and formula 'y ~ x'   p3_compute_panel <- ggtrace_capture(p3, method = Stat$compute_panel)  # For one, the body is different body(p3_compute_panel) #> { #>     cur_args <- mget(names(formals(rlang::current_fn()))) #>     specs <- names(cur_args) %in% names(formals(inner)) #>     do.call(inner, c(cur_args[specs], cur_args[!specs])) #> }  # The captured method is called internally, stored in the `\"inner\"` attribute attr(p3_compute_panel, \"inner\") #> function (self, data, scales, ...)  #> { #>     if (empty(data))  #>         return(new_data_frame()) #>     groups <- split(data, data$group) #>     stats <- lapply(groups, function(group) { #>         self$compute_group(data = group, scales = scales, ...) #>     }) #>     stats <- mapply(function(new, old) { #>         if (empty(new))  #>             return(new_data_frame()) #>         unique <- uniquecols(old) #>         missing <- !(names(unique) %in% names(new)) #>         cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #>     }, stats, groups, SIMPLIFY = FALSE) #>     rbind_dfs(stats) #> } #> <environment: 0x0000000039c61430>  # Captured argument defaults are again available for inspection via `formals()` # Note that arguments passed to the `...` are promoted to function arguments names(ggformals(Stat$compute_panel)) #> [1] \"self\"   \"data\"   \"scales\" \"...\"    names(formals(p3_compute_panel)) #>  [1] \"self\"        \"data\"        \"scales\"      \"method\"      \"formula\"     #>  [6] \"se\"          \"n\"           \"fullrange\"   \"level\"       \"na.rm\"       #> [11] \"method.args\" \"span\"        \"flipped_aes\"  # It works the same otherwise - plus you get the benefit of autocomplete head(p3_compute_panel()) #>          x        y     ymin     ymax        se flipped_aes PANEL group #> 1 1.000000 3.800000 2.456618 5.143382 0.6437060       FALSE     1    -1 #> 2 1.050633 3.814934 2.562634 5.067233 0.6000623       FALSE     1    -1 #> 3 1.101266 3.829354 2.645742 5.012967 0.5671495       FALSE     1    -1 #> 4 1.151899 3.843262 2.705881 4.980643 0.5449968       FALSE     1    -1 #> 5 1.202532 3.856658 2.744115 4.969200 0.5330951       FALSE     1    -1 #> 6 1.253165 3.869540 2.762657 4.976424 0.5303834       FALSE     1    -1 head(p3_compute_panel(level = .99)[, c(\"ymin\", \"ymax\")]) #>       ymin     ymax #> 1 1.967038 5.632962 #> 2 2.106247 5.523620 #> 3 2.214388 5.444321 #> 4 2.291376 5.395149 #> 5 2.338661 5.374654 #> 6 2.359266 5.379815 head(p3_compute_panel(flipped_aes = TRUE)) #>          y        x     xmin     xmax        se flipped_aes PANEL group #> 1 1.000000 3.486913 1.996579 4.977247 0.7148639        TRUE     1    -1 #> 2 1.050633 3.537510 2.136220 4.938801 0.6721527        TRUE     1    -1 #> 3 1.101266 3.585828 2.263181 4.908476 0.6344304        TRUE     1    -1 #> 4 1.151899 3.631850 2.377468 4.886232 0.6016854        TRUE     1    -1 #> 5 1.202532 3.675558 2.479204 4.871912 0.5738514        TRUE     1    -1 #> 6 1.253165 3.716935 2.568654 4.865215 0.5507921        TRUE     1    -1  # Interactively explore with `debugonce(attr(p3_compute_panel, \"inner\"))`"},{"path":"/reference/ggtrace_capture_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Capture a snapshot of a ggproto method's execution environment — ggtrace_capture_env","title":"Capture a snapshot of a ggproto method's execution environment — ggtrace_capture_env","text":"Capture snapshot ggproto method's execution environment","code":""},{"path":"/reference/ggtrace_capture_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capture a snapshot of a ggproto method's execution environment — ggtrace_capture_env","text":"","code":"ggtrace_capture_env(x, ..., at = -1L)"},{"path":"/reference/ggtrace_capture_env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capture a snapshot of a ggproto method's execution environment — ggtrace_capture_env","text":"x ggplot object ... Passed ggtrace(). method capture specified . position method body environment captured. Defaults -1L, right method returns.","code":""},{"path":"/reference/ggtrace_capture_env.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capture a snapshot of a ggproto method's execution environment — ggtrace_capture_env","text":"environment","code":""},{"path":"/reference/ggtrace_capture_env.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capture a snapshot of a ggproto method's execution environment — ggtrace_capture_env","text":"","code":"library(ggplot2)  # Example from https://ggplot2.tidyverse.org/reference/aes_eval.html after_scale_plot <- ggplot(mpg, aes(class, hwy)) +   geom_boxplot(aes(colour = class, fill = after_scale(alpha(colour, 0.4)))) after_scale_plot   # `after_scale()` is resolved by `Geom$use_defaults` (at Step 6)  before_applying <- ggtrace_capture_env(   x = after_scale_plot,   method = Geom$use_defaults,   at = 1  # To be more specific, do `at = 6` ) after_applying <- ggtrace_capture_env(   x = after_scale_plot,   method = Geom$use_defaults,   at = -1  # To be more specific, do `at = 7` )  colnames(before_applying$data) #>  [1] \"colour\"      \"ymin\"        \"lower\"       \"middle\"      \"upper\"       #>  [6] \"ymax\"        \"outliers\"    \"notchupper\"  \"notchlower\"  \"x\"           #> [11] \"flipped_aes\" \"PANEL\"       \"group\"       \"ymin_final\"  \"ymax_final\"  #> [16] \"xmin\"        \"xmax\"        \"xid\"         \"newx\"        \"new_width\"   colnames(after_applying$data) #>  [1] \"fill\"        \"colour\"      \"ymin\"        \"lower\"       \"middle\"      #>  [6] \"upper\"       \"ymax\"        \"outliers\"    \"notchupper\"  \"notchlower\"  #> [11] \"x\"           \"flipped_aes\" \"PANEL\"       \"group\"       \"ymin_final\"  #> [16] \"ymax_final\"  \"xmin\"        \"xmax\"        \"xid\"         \"newx\"        #> [21] \"new_width\"   \"weight\"      \"size\"        \"alpha\"       \"shape\"       #> [26] \"linetype\"     library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union  before_applying$data %>%   select(any_of(c(\"colour\", \"fill\"))) #>    colour #> 1 #F8766D #> 2 #C49A00 #> 3 #53B400 #> 4 #00C094 #> 5 #00B6EB #> 6 #A58AFF #> 7 #FB61D7 after_applying$data %>%   select(any_of(c(\"colour\", \"fill\"))) #>    colour      fill #> 1 #F8766D #F8766D66 #> 2 #C49A00 #C49A0066 #> 3 #53B400 #53B40066 #> 4 #00C094 #00C09466 #> 5 #00B6EB #00B6EB66 #> 6 #A58AFF #A58AFF66 #> 7 #FB61D7 #FB61D766  identical(   before_applying$data %>%     select(any_of(c(\"colour\", \"fill\"))) %>%     mutate(fill = alpha(colour, 0.4)),       #< after_scale() logic here   after_applying$data %>%     select(any_of(c(\"colour\", \"fill\"))) ) #> [1] TRUE"},{"path":"/reference/ggtrace_capture_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture_fn","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture_fn","text":"Returns ggproto method function arguments pre-filled values first called","code":""},{"path":"/reference/ggtrace_capture_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture_fn","text":"","code":"ggtrace_capture_fn(x, ...)"},{"path":"/reference/ggtrace_capture_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture_fn","text":"x ggplot object ... Passed ggtrace(). method capture specified .","code":""},{"path":"/reference/ggtrace_capture_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture_fn","text":"function","code":""},{"path":"/reference/ggtrace_capture_fn.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture_fn","text":"methods take ..., arguments passed ... runtime, captured promoted function arguments. captured values available inspection via formals().","code":""},{"path":"/reference/ggtrace_capture_fn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture_fn","text":"","code":"library(ggplot2)  set.seed(47) df <- as.data.frame(matrix(sample(5, 50, TRUE), ncol = 2)) df #>    V1 V2 #> 1   3  5 #> 2   1  5 #> 3   2  4 #> 4   4  1 #> 5   1  5 #> 6   2  5 #> 7   5  1 #> 8   1  5 #> 9   5  2 #> 10  4  1 #> 11  5  3 #> 12  5  5 #> 13  4  3 #> 14  3  3 #> 15  3  5 #> 16  4  3 #> 17  1  1 #> 18  5  2 #> 19  2  5 #> 20  5  2 #> 21  2  2 #> 22  5  3 #> 23  3  5 #> 24  3  2 #> 25  1  3  base <- ggplot(df, aes(x = V1, y = V2))  p1 <- base + stat_summary(orientation = \"x\") p1 #> No summary function supplied, defaulting to `mean_se()`   p1_compute_panel <- ggtrace_capture_fn(p1, method = StatSummary$compute_panel)  # `p1_compute_panel` is a copy of the ggproto method body(p1_compute_panel) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> } ggbody(StatSummary$compute_panel, as.list = FALSE) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> }  # Its arguments are pre-filled (captured at runtime) formals(p1_compute_panel) #> $data #>    x y PANEL group #> 1  3 5     1    -1 #> 2  1 5     1    -1 #> 3  2 4     1    -1 #> 4  4 1     1    -1 #> 5  1 5     1    -1 #> 6  2 5     1    -1 #> 7  5 1     1    -1 #> 8  1 5     1    -1 #> 9  5 2     1    -1 #> 10 4 1     1    -1 #> 11 5 3     1    -1 #> 12 5 5     1    -1 #> 13 4 3     1    -1 #> 14 3 3     1    -1 #> 15 3 5     1    -1 #> 16 4 3     1    -1 #> 17 1 1     1    -1 #> 18 5 2     1    -1 #> 19 2 5     1    -1 #> 20 5 2     1    -1 #> 21 2 2     1    -1 #> 22 5 3     1    -1 #> 23 3 5     1    -1 #> 24 3 2     1    -1 #> 25 1 3     1    -1 #>  #> $scales #> $scales$x #> <ScaleContinuousPosition> #>  Range:     1 --    5 #>  Limits:    1 --    5 #>  #> $scales$y #> <ScaleContinuousPosition> #>  Range:  1.42 -- 4.71 #>  Limits: 1.42 -- 4.71 #>  #>  #> $fun.data #> NULL #>  #> $fun #> NULL #>  #> $fun.max #> NULL #>  #> $fun.min #> NULL #>  #> $fun.args #> list() #>  #> $na.rm #> [1] FALSE #>  #> $flipped_aes #> [1] FALSE #>   # Runs as it should p1_compute_panel() #> No summary function supplied, defaulting to `mean_se()` #>   x group        y     ymin     ymax PANEL flipped_aes #> 1 1    -1 3.800000 3.000000 4.600000     1       FALSE #> 2 2    -1 4.000000 3.292893 4.707107     1       FALSE #> 3 3    -1 4.000000 3.367544 4.632456     1       FALSE #> 4 4    -1 2.000000 1.422650 2.577350     1       FALSE #> 5 5    -1 2.571429 2.090500 3.052357     1       FALSE  # You can inspect changes to its behavior outisde of ggplot # For example, see what happens when aes is flipped via `orientation = \"y\"` p1_compute_panel(flipped_aes = TRUE) #> No summary function supplied, defaulting to `mean_se()` #>   y group        x     xmin     xmax PANEL flipped_aes #> 1 1    -1 3.500000 2.633975 4.366025     1        TRUE #> 2 2    -1 4.000000 3.367544 4.632456     1        TRUE #> 3 3    -1 3.666667 3.052030 4.281303     1        TRUE #> 4 4    -1 2.000000       NA       NA     1        TRUE #> 5 5    -1 2.333333 1.892375 2.774292     1        TRUE  # We confirm this output to be true when `orientation = \"y\"` p2 <- base + stat_summary(orientation = \"y\") p2_compute_panel <- ggtrace_capture_fn(p2, method = StatSummary$compute_panel) #> Warning: Removed 1 rows containing missing values (geom_segment).  identical(p1_compute_panel(flipped_aes = TRUE), p2_compute_panel()) #> No summary function supplied, defaulting to `mean_se()` #> No summary function supplied, defaulting to `mean_se()` #> [1] TRUE  # You can interactively explore with `debugonce(p2_compute_panel)`   # Note that the captured method looks slightly different if the method takes `...` p3 <- base + stat_smooth() + geom_jitter() p3 #> `geom_smooth()` using method = 'loess' and formula 'y ~ x'   p3_compute_panel <- ggtrace_capture_fn(p3, method = Stat$compute_panel)  # For one, the body is different body(p3_compute_panel) #> { #>     cur_args <- mget(names(formals(rlang::current_fn()))) #>     specs <- names(cur_args) %in% names(formals(inner)) #>     do.call(inner, c(cur_args[specs], cur_args[!specs])) #> }  # The captured method is called internally, stored in the `\"inner\"` attribute attr(p3_compute_panel, \"inner\") #> function (self, data, scales, ...)  #> { #>     if (empty(data))  #>         return(new_data_frame()) #>     groups <- split(data, data$group) #>     stats <- lapply(groups, function(group) { #>         self$compute_group(data = group, scales = scales, ...) #>     }) #>     stats <- mapply(function(new, old) { #>         if (empty(new))  #>             return(new_data_frame()) #>         unique <- uniquecols(old) #>         missing <- !(names(unique) %in% names(new)) #>         cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #>     }, stats, groups, SIMPLIFY = FALSE) #>     rbind_dfs(stats) #> } #> <environment: 0x000000004de26e08>  # Captured argument defaults are again available for inspection via `formals()` # Note that arguments passed to the `...` are promoted to function arguments names(ggformals(Stat$compute_panel)) #> [1] \"self\"   \"data\"   \"scales\" \"...\"    names(formals(p3_compute_panel)) #>  [1] \"self\"        \"data\"        \"scales\"      \"method\"      \"formula\"     #>  [6] \"se\"          \"n\"           \"fullrange\"   \"level\"       \"na.rm\"       #> [11] \"method.args\" \"span\"        \"flipped_aes\"  # It works the same otherwise - plus you get the benefit of autocomplete head(p3_compute_panel()) #>          x        y     ymin     ymax        se flipped_aes PANEL group #> 1 1.000000 3.800000 2.456618 5.143382 0.6437060       FALSE     1    -1 #> 2 1.050633 3.814934 2.562634 5.067233 0.6000623       FALSE     1    -1 #> 3 1.101266 3.829354 2.645742 5.012967 0.5671495       FALSE     1    -1 #> 4 1.151899 3.843262 2.705881 4.980643 0.5449968       FALSE     1    -1 #> 5 1.202532 3.856658 2.744115 4.969200 0.5330951       FALSE     1    -1 #> 6 1.253165 3.869540 2.762657 4.976424 0.5303834       FALSE     1    -1 head(p3_compute_panel(level = .99)[, c(\"ymin\", \"ymax\")]) #>       ymin     ymax #> 1 1.967038 5.632962 #> 2 2.106247 5.523620 #> 3 2.214388 5.444321 #> 4 2.291376 5.395149 #> 5 2.338661 5.374654 #> 6 2.359266 5.379815 head(p3_compute_panel(flipped_aes = TRUE)) #>          y        x     xmin     xmax        se flipped_aes PANEL group #> 1 1.000000 3.486913 1.996579 4.977247 0.7148639        TRUE     1    -1 #> 2 1.050633 3.537510 2.136220 4.938801 0.6721527        TRUE     1    -1 #> 3 1.101266 3.585828 2.263181 4.908476 0.6344304        TRUE     1    -1 #> 4 1.151899 3.631850 2.377468 4.886232 0.6016854        TRUE     1    -1 #> 5 1.202532 3.675558 2.479204 4.871912 0.5738514        TRUE     1    -1 #> 6 1.253165 3.716935 2.568654 4.865215 0.5507921        TRUE     1    -1  # Interactively explore with `debugonce(attr(p3_compute_panel, \"inner\"))`"},{"path":"/reference/ggtrace_capture_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"Returns ggproto method function arguments pre-filled values upon entering function.","code":""},{"path":"/reference/ggtrace_capture_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"","code":"ggtrace_capture_method(x, ...)"},{"path":"/reference/ggtrace_capture_method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"x ggplot object ... Passed ggtrace(). usecases, suffices just provide ggproto method method argument.","code":""},{"path":"/reference/ggtrace_capture_method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"function","code":""},{"path":"/reference/ggtrace_capture_method.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"methods take ..., arguments passed ... runtime, captured stored .dots_captured argument returned function, accessible via formals(x)$.dots_captured. returned function also expose ..., defaults .dots_captured passed captured method unless also provided ...","code":""},{"path":"/reference/ggtrace_capture_method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"","code":"library(ggplot2)  set.seed(47) df <- as.data.frame(matrix(sample(5, 50, TRUE), ncol = 2)) df #>    V1 V2 #> 1   3  5 #> 2   1  5 #> 3   2  4 #> 4   4  1 #> 5   1  5 #> 6   2  5 #> 7   5  1 #> 8   1  5 #> 9   5  2 #> 10  4  1 #> 11  5  3 #> 12  5  5 #> 13  4  3 #> 14  3  3 #> 15  3  5 #> 16  4  3 #> 17  1  1 #> 18  5  2 #> 19  2  5 #> 20  5  2 #> 21  2  2 #> 22  5  3 #> 23  3  5 #> 24  3  2 #> 25  1  3  p1 <- ggplot(df, aes(x = V1, y = V2)) + stat_summary(orientation = \"x\") p1 #> No summary function supplied, defaulting to `mean_se()`   p1_compute_panel <- ggtrace_capture_method(p1, method = StatSummary$compute_panel)  # `p1_compute_panel` is a copy of the ggproto method body(p1_compute_panel) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> } ggbody(StatSummary$compute_panel, as.list = FALSE) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> }  # Its arguments are pre-filled (captured at runtime) formals(p1_compute_panel) #> $data #>    x y PANEL group #> 1  3 5     1    -1 #> 2  1 5     1    -1 #> 3  2 4     1    -1 #> 4  4 1     1    -1 #> 5  1 5     1    -1 #> 6  2 5     1    -1 #> 7  5 1     1    -1 #> 8  1 5     1    -1 #> 9  5 2     1    -1 #> 10 4 1     1    -1 #> 11 5 3     1    -1 #> 12 5 5     1    -1 #> 13 4 3     1    -1 #> 14 3 3     1    -1 #> 15 3 5     1    -1 #> 16 4 3     1    -1 #> 17 1 1     1    -1 #> 18 5 2     1    -1 #> 19 2 5     1    -1 #> 20 5 2     1    -1 #> 21 2 2     1    -1 #> 22 5 3     1    -1 #> 23 3 5     1    -1 #> 24 3 2     1    -1 #> 25 1 3     1    -1 #>  #> $scales #> $scales$x #> <ScaleContinuousPosition> #>  Range:     1 --    5 #>  Limits:    1 --    5 #>  #> $scales$y #> <ScaleContinuousPosition> #>  Range:  1.42 -- 4.71 #>  Limits: 1.42 -- 4.71 #>  #>  #> $fun.data #> NULL #>  #> $fun #> NULL #>  #> $fun.max #> NULL #>  #> $fun.min #> NULL #>  #> $fun.args #> list() #>  #> $na.rm #> [1] FALSE #>  #> $flipped_aes #> [1] FALSE #>   # Runs as it should p1_compute_panel() #> No summary function supplied, defaulting to `mean_se()` #>   x group        y     ymin     ymax PANEL flipped_aes #> 1 1    -1 3.800000 3.000000 4.600000     1       FALSE #> 2 2    -1 4.000000 3.292893 4.707107     1       FALSE #> 3 3    -1 4.000000 3.367544 4.632456     1       FALSE #> 4 4    -1 2.000000 1.422650 2.577350     1       FALSE #> 5 5    -1 2.571429 2.090500 3.052357     1       FALSE  # You can inspect changes to its behavior outisde of ggplot # For example, see what happens when aes is flipped via `orientation = \"y\"` p1_compute_panel(flipped_aes = TRUE) #> No summary function supplied, defaulting to `mean_se()` #>   y group        x     xmin     xmax PANEL flipped_aes #> 1 1    -1 3.500000 2.633975 4.366025     1        TRUE #> 2 2    -1 4.000000 3.367544 4.632456     1        TRUE #> 3 3    -1 3.666667 3.052030 4.281303     1        TRUE #> 4 4    -1 2.000000       NA       NA     1        TRUE #> 5 5    -1 2.333333 1.892375 2.774292     1        TRUE  # We confirm this output to be true when `orientation = \"y\"` p2 <- ggplot(df, aes(x = V1, y = V2)) + stat_summary(orientation = \"y\") p2_compute_panel <- ggtrace_capture_method(p2, method = StatSummary$compute_panel) #> Warning: Removed 1 rows containing missing values (geom_segment).  identical(p1_compute_panel(flipped_aes = TRUE), p2_compute_panel()) #> No summary function supplied, defaulting to `mean_se()` #> No summary function supplied, defaulting to `mean_se()` #> [1] TRUE   # Note that the captured method looks slightly different if the method takes `...` p3 <- ggplot(df, aes(x = V1, y = V2)) + stat_smooth() + geom_jitter() p3 #> `geom_smooth()` using method = 'loess' and formula 'y ~ x'   p3_compute_panel <- ggtrace_capture_method(p3, method = Stat$compute_panel)  # For one, the body is different body(p3_compute_panel) #> { #>     cur_args <- mget(names(formals(rlang::current_fn()))) #>     specs <- names(cur_args) %in% names(formals(inner)) #>     do.call(inner, c(cur_args[specs], cur_args[!specs])) #> }  # The captured method is called internally, stored in the `\"inner\"` attribute attr(p3_compute_panel, \"inner\") #> function (self, data, scales, ...)  #> { #>     if (empty(data))  #>         return(new_data_frame()) #>     groups <- split(data, data$group) #>     stats <- lapply(groups, function(group) { #>         self$compute_group(data = group, scales = scales, ...) #>     }) #>     stats <- mapply(function(new, old) { #>         if (empty(new))  #>             return(new_data_frame()) #>         unique <- uniquecols(old) #>         missing <- !(names(unique) %in% names(new)) #>         cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #>     }, stats, groups, SIMPLIFY = FALSE) #>     rbind_dfs(stats) #> } #> <environment: 0x00000000395196f0>  # Captured arguments are again stored in the formals of the function # Note that arguments passed to the `...` are promoted to function arguments names(formals(p3_compute_panel)) #>  [1] \"self\"        \"data\"        \"scales\"      \"method\"      \"formula\"     #>  [6] \"se\"          \"n\"           \"fullrange\"   \"level\"       \"na.rm\"       #> [11] \"method.args\" \"span\"        \"flipped_aes\" names(ggformals(Stat$compute_panel)) #> [1] \"self\"   \"data\"   \"scales\" \"...\"     # It works the same otherwise - plus you get the benefit of autocomplete head(p3_compute_panel()) #>          x        y     ymin     ymax        se flipped_aes PANEL group #> 1 1.000000 3.800000 2.456618 5.143382 0.6437060       FALSE     1    -1 #> 2 1.050633 3.814934 2.562634 5.067233 0.6000623       FALSE     1    -1 #> 3 1.101266 3.829354 2.645742 5.012967 0.5671495       FALSE     1    -1 #> 4 1.151899 3.843262 2.705881 4.980643 0.5449968       FALSE     1    -1 #> 5 1.202532 3.856658 2.744115 4.969200 0.5330951       FALSE     1    -1 #> 6 1.253165 3.869540 2.762657 4.976424 0.5303834       FALSE     1    -1 head(p3_compute_panel(level = .99)[, c(\"ymin\", \"ymax\")]) #>       ymin     ymax #> 1 1.967038 5.632962 #> 2 2.106247 5.523620 #> 3 2.214388 5.444321 #> 4 2.291376 5.395149 #> 5 2.338661 5.374654 #> 6 2.359266 5.379815 head(p3_compute_panel(flipped_aes = TRUE)) #>          y        x     xmin     xmax        se flipped_aes PANEL group #> 1 1.000000 3.486913 1.996579 4.977247 0.7148639        TRUE     1    -1 #> 2 1.050633 3.537510 2.136220 4.938801 0.6721527        TRUE     1    -1 #> 3 1.101266 3.585828 2.263181 4.908476 0.6344304        TRUE     1    -1 #> 4 1.151899 3.631850 2.377468 4.886232 0.6016854        TRUE     1    -1 #> 5 1.202532 3.675558 2.479204 4.871912 0.5738514        TRUE     1    -1 #> 6 1.253165 3.716935 2.568654 4.865215 0.5507921        TRUE     1    -1"},{"path":"/reference/ggtrace_inspect_return.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect the return value of a method — ggtrace_inspect_return","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"Inspect return value method","code":""},{"path":"/reference/ggtrace_inspect_return.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"","code":"ggtrace_inspect_return(x, method, cond = TRUE)"},{"path":"/reference/ggtrace_inspect_return.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond return value replaced. Defaults TRUE. Given one value returned ggtrace_inspect_return, default value return value first time method runs.","code":""},{"path":"/reference/ggtrace_inspect_return.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"return value method first called.","code":""},{"path":"/reference/ggtrace_inspect_return.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"value cond can quoted expression, gets evaluated every time method called evaluation x. cond evaluates TRUE multiple times (default case cond simply TRUE), function gives return value first time method runs. cond expression evaluated inside method's current execution environment, addition data-masked variable ._counter (.data$._counter), internally tracks current index method. example, ._counter == 3 targets third time method called. Additionally, quoted passed cond, function returnValue() accesses current return value method. example, unique(returnValue()$PANEL) == 2 Stat$compute_group targets method processing data second PANEL.","code":""},{"path":"/reference/ggtrace_modify_return.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify the return value of a method — ggtrace_modify_return","title":"Modify the return value of a method — ggtrace_modify_return","text":"Modify return value method","code":""},{"path":"/reference/ggtrace_modify_return.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify the return value of a method — ggtrace_modify_return","text":"","code":"ggtrace_modify_return(x, method, value, cond = TRUE, draw = TRUE)"},{"path":"/reference/ggtrace_modify_return.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify the return value of a method — ggtrace_modify_return","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method value Value method return called cond return value replaced draw Whether draw modified plot","code":""},{"path":"/reference/ggtrace_modify_return.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modify the return value of a method — ggtrace_modify_return","text":"gtable object class <ggtrace_modified>","code":""},{"path":"/reference/gguntrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove any existing traces — gguntrace","title":"Remove any existing traces — gguntrace","text":"Used explicitly calling untrace() ggproto object.","code":""},{"path":"/reference/gguntrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove any existing traces — gguntrace","text":"","code":"gguntrace(method, ...)"},{"path":"/reference/gguntrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove any existing traces — gguntrace","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Ignored. Designed ease calling function modifying call earlier {ggtrace} function interactive contexts.","code":""},{"path":"/reference/gguntrace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove any existing traces — gguntrace","text":"Unlike base::untrace(), adverse side effect repeatedly calling gguntrace() ggproto method. gguntrace() throw error method found. method valid, gguntrace() one two things: Inform successfully removed trace (untracing) Inform existing trace (nothing)","code":""},{"path":[]},{"path":"/reference/gguntrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove any existing traces — gguntrace","text":"","code":"library(ggplot2)  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` not currently being traced.  is_traced(Stat$compute_layer) #> [1] FALSE  ggtrace(Stat$compute_layer, 1) #> `Stat$compute_layer` now being traced.  is_traced(Stat$compute_layer) #> [1] TRUE  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` no longer being traced.  is_traced(Stat$compute_layer) #> [1] FALSE  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` not currently being traced."},{"path":"/reference/global_ggtrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"global_ggtrace() list trace dumps collected across multiple traces, recommended use ggtrace(= FALSE) expect trace independently triggered multiple times (example, tracing (compute/draw)_group method multiple groups, plot multiple layers call method traced).","code":""},{"path":"/reference/global_ggtrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"","code":"global_ggtrace()  set_global_ggtrace(value)  clear_global_ggtrace()  global_ggtrace_state(state)  global_ggtrace_on()  global_ggtrace_off()"},{"path":"/reference/global_ggtrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"state missing, returns whether global tracedump currently active. global tracedump inactive default (state FALSE). activated, every time trace created ggtrace() triggered tracedump added global tracedump storage, can inspected global_ggtrace(). global tracedump can turned /setting state TRUE/FALSE.","code":""},{"path":"/reference/global_ggtrace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"List logical indicating current state global trace dump. state provided, changes state first, returns state invisibly.","code":""},{"path":"/reference/global_ggtrace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"clear_global_ggtrace() sets value global_ggtrace() NULL returns NULL. can inspect state global trace dump global_ggtrace_state() activate deactivate global_ggtrace_on() global_ggtrace_off(), aliases global_ggtrace_state(TRUE) global_ggtrace_state(FALSE), respectively.","code":""},{"path":"/reference/global_ggtrace.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"trace dump pushed global_ggtrace(), gets named ggproto method hex code identifying method's runtime environment, e.g. \"Stat$compute_layer-00000267437FD3D8\".","code":""},{"path":[]},{"path":"/reference/global_ggtrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"","code":"library(ggplot2)  global_ggtrace_state() # global tracedump is inactive by default since v0.4.3 #> [1] FALSE global_ggtrace_on()    # alias for global_ggtrace_state(TRUE) #> Global tracedump activated. clear_global_ggtrace() #> Global tracedump cleared.  ggtrace(   GeomBoxplot$draw_group,   trace_steps = -1,   once = FALSE,   verbose = FALSE ) #> `GeomBoxplot$draw_group` now being traced. #> Creating a persistent trace. Remember to `gguntrace(GeomBoxplot$draw_group)`!  ggplot(mpg, aes(class, hwy)) + geom_boxplot() #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group`   gguntrace(GeomBoxplot$draw_group) #> `GeomBoxplot$draw_group` no longer being traced.  boxplot_group_tracedump <- global_ggtrace()  length(boxplot_group_tracedump) #> [1] 7  boxplot_group_tracedump <- unlist(   boxplot_group_tracedump,   recursive = FALSE,   use.names = FALSE )  patchwork::wrap_plots(boxplot_group_tracedump, nrow = 1)   clear_global_ggtrace() #> Global tracedump cleared. global_ggtrace() #> NULL  global_ggtrace_off() # alias for global_ggtrace_state(FALSE) #> Global tracedump deactivated."},{"path":"/reference/is_traced.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a method is being traced — is_traced","title":"Check if a method is being traced — is_traced","text":"Check method traced","code":""},{"path":"/reference/is_traced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a method is being traced — is_traced","text":"","code":"is_traced(method)"},{"path":"/reference/is_traced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a method is being traced — is_traced","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method","code":""},{"path":"/reference/is_traced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if a method is being traced — is_traced","text":"logical","code":""},{"path":"/reference/is_traced.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if a method is being traced — is_traced","text":"","code":"library(ggplot2)  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` not currently being traced.  is_traced(Stat$compute_layer) #> [1] FALSE  ggtrace(Stat$compute_layer, 1) #> `Stat$compute_layer` now being traced.  is_traced(Stat$compute_layer) #> [1] TRUE  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` no longer being traced.  is_traced(Stat$compute_layer) #> [1] FALSE  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` not currently being traced."},{"path":"/reference/last_ggtrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","title":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","text":"last_ggtrace() retrieves last trace dump created ggtrace() - .e., last time trace triggered.","code":""},{"path":"/reference/last_ggtrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","text":"","code":"last_ggtrace()  set_last_ggtrace(value)  clear_last_ggtrace()"},{"path":"/reference/last_ggtrace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","text":"List","code":""},{"path":"/reference/last_ggtrace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","text":"tracedump refers output expression evaluated inside traced function trace triggered. context ggtrace(), tracedump list long number step-expression pairs, element output expression (trace_exprs) evaluated step (trace_steps) inside execution environment function ggproto method. clear_last_ggtrace() sets value last_ggtrace() NULL returns NULL.","code":""},{"path":[]},{"path":"/reference/last_ggtrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","text":"","code":"library(ggplot2)  ggtrace(StatSmooth$compute_group, trace_steps = -1, trace_exprs = quote(head(prediction))) #> `StatSmooth$compute_group` now being traced.  ggplot(mtcars, aes(mpg, hp)) + geom_point() + geom_smooth(method = 'lm') #> `geom_smooth()` using formula 'y ~ x' #> Triggering trace on `StatSmooth$compute_group` #> Untracing `StatSmooth$compute_group` on exit.   last_ggtrace() #> [[1]] #>          x        y     ymin     ymax       se flipped_aes #> 1 10.40000 232.2531 201.8649 262.6414 14.87963       FALSE #> 2 10.69747 229.6265 199.9139 259.3392 14.54880       FALSE #> 3 10.99494 227.0000 197.9569 256.0430 14.22094       FALSE #> 4 11.29241 224.3734 195.9934 252.7534 13.89627       FALSE #> 5 11.58987 221.7468 194.0230 249.4707 13.57502       FALSE #> 6 11.88734 219.1203 192.0450 246.1956 13.25743       FALSE #>   ggtrace(   StatSmooth$compute_group,   trace_steps = -1,   trace_exprs = quote(prediction),   verbose = FALSE ) #> `StatSmooth$compute_group` now being traced.  ggplot(mtcars, aes(mpg, hp)) + geom_point() + geom_smooth(method = 'lm') #> `geom_smooth()` using formula 'y ~ x' #> Triggering trace on `StatSmooth$compute_group` #> Untracing `StatSmooth$compute_group` on exit.   head(last_ggtrace()[[1]]) #>          x        y     ymin     ymax       se flipped_aes #> 1 10.40000 232.2531 201.8649 262.6414 14.87963       FALSE #> 2 10.69747 229.6265 199.9139 259.3392 14.54880       FALSE #> 3 10.99494 227.0000 197.9569 256.0430 14.22094       FALSE #> 4 11.29241 224.3734 195.9934 252.7534 13.89627       FALSE #> 5 11.58987 221.7468 194.0230 249.4707 13.57502       FALSE #> 6 11.88734 219.1203 192.0450 246.1956 13.25743       FALSE"},{"path":"/reference/one-offs.html","id":null,"dir":"Reference","previous_headings":"","what":"Debugonce a ggproto method — one-offs","title":"Debugonce a ggproto method — one-offs","text":"Debugonce ggproto method Inspect call stack","code":""},{"path":"/reference/one-offs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Debugonce a ggproto method — one-offs","text":"","code":"ggdebugonce(method, ...)  ggtraceback(method, ...)"},{"path":"/reference/one-offs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Debugonce a ggproto method — one-offs","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Arguments passed rlang::trace_back top first frame environment included backtrace. becomes top backtrace tree represents oldest call backtrace. needed particular call trace_back() indirectly larger context, example tests inside RMarkdown document want knitr evaluation mechanisms appear backtrace. bottom last frame environment included backtrace. becomes rightmost leaf backtrace tree represents youngest call backtrace. Set like capture backtrace without capture context. Can also integer passed caller_env().","code":""},{"path":"/reference/one-offs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Debugonce a ggproto method — one-offs","text":"Calls rlang::trace_back() upon first entering function method. Note ggtraceback() ever prints back trace calls gguntrace() first time triggered. complex inspections call stack, ggedit() recommended.","code":""},{"path":"/reference/one-offs.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Debugonce a ggproto method — one-offs","text":"output rlang::trace_back() logged tracedumps (last_ggtrace() global_ggtrace())","code":""},{"path":"/reference/with_ggtrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a ggtrace call to a single ggplot object — with_ggtrace","title":"Apply a ggtrace call to a single ggplot object — with_ggtrace","text":"with_ggtrace() provides functional interface ggtrace(). takes ggplot object parameters passed ggtrace() returns immediate tracedump without side effects.","code":""},{"path":"/reference/with_ggtrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a ggtrace call to a single ggplot object — with_ggtrace","text":"","code":"with_ggtrace(x, ...)"},{"path":"/reference/with_ggtrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a ggtrace call to a single ggplot object — with_ggtrace","text":"x ggplot object whose evaluation triggers trace specified ... ... Arguments passed ggtrace trace_steps sorted numeric vector positions method's body trace. Negative indices reference steps last, -1 references last step body. trace_exprs list expressions evaluate position specified trace_steps. single expression provided, recycled match length trace_steps. simply run step return output, can use ~step keyword. step assign expression, value assigned variable returned. trace_exprs provided, ggtrace() called ~step default. Whether untrace() method exit. FALSE, creates persistent trace active gguntrace() called method. Defaults TRUE. use_names Whether trace dump use names trace_exprs. Defaults TRUE. print_output Whether print() output expression console. Defaults TRUE. verbose Whether logs printed trace triggered. Encompasses print_output, meaning verbose = FALSE also triggers effect print_output = FALSE consequence. Defaults FALSE. method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method","code":""},{"path":"/reference/with_ggtrace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a ggtrace call to a single ggplot object — with_ggtrace","text":"list","code":""},{"path":"/reference/with_ggtrace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply a ggtrace call to a single ggplot object — with_ggtrace","text":"lower-level function powers workflow functions {ggtrace}.","code":""},{"path":"/reference/with_ggtrace.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Apply a ggtrace call to a single ggplot object — with_ggtrace","text":"force evaluation x, ggeval_silent(x) called internally.","code":""},{"path":[]},{"path":"/reference/with_ggtrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a ggtrace call to a single ggplot object — with_ggtrace","text":"","code":"library(ggplot2)  # Long-form `ggtrace()` method: boxplot_plot <- ggplot(diamonds[1:500,], aes(cut, depth)) + geom_boxplot() ggtrace(  method = StatBoxplot$compute_group,  trace_steps = -1, trace_exprs = quote(~step) ) #> `StatBoxplot$compute_group` now being traced. boxplot_plot #> Triggering trace on `StatBoxplot$compute_group` #> Untracing `StatBoxplot$compute_group` on exit.  first_tracedump <- last_ggtrace()  # Short-form functional `with_ggtrace()` method: second_tracedump <- with_ggtrace(   x = boxplot_plot,   method = StatBoxplot$compute_group,   trace_steps = -1, trace_exprs = quote(~step) )  identical(first_tracedump, second_tracedump) #> [1] TRUE"},{"path":"/news/index.html","id":"ggtrace-development-version","dir":"Changelog","previous_headings":"","what":"ggtrace (development version)","title":"ggtrace (development version)","text":"ggtrace_capture_env() default value changed -1L, captures snapshot runtime environment right method returns. ggtrace_modify_return() exposes ._counter_ value argument","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-4-8","dir":"Changelog","previous_headings":"","what":"New Features","title":"ggtrace 0.4.8","text":"Added with_ggtrace() functional interface ggtrace() Added ggtrace_capture_fn() ggtrace_capture_env(), return snapshot function/environment ggproto method execution time Added ggtrace_inspect_return() ggtrace_modify_return() grab swap return values method’s execution","code":""},{"path":"/news/index.html","id":"miscellaneous-0-4-8","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"ggtrace 0.4.8","text":"Added workflows section docs/references","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-4-7","dir":"Changelog","previous_headings":"","what":"New Features","title":"ggtrace 0.4.7","text":"Added ggformals() returns formals() functions ggproto methods ggbody() gains .list argument control whether output body() turned list Exported set_last_ggtrace() set_global_ggtrace() tracedumps","code":""},{"path":"/news/index.html","id":"bug-fix-0-4-7","dir":"Changelog","previous_headings":"","what":"Bug Fix","title":"ggtrace 0.4.7","text":"Fixed compatibility issues {rlang} v1.0.0 new changes call expression API","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-4-6","dir":"Changelog","previous_headings":"","what":"New Features","title":"ggtrace 0.4.6","text":"Added get_method() returns ggproto methods functions Added wrappers one-workflows ggdebugonce() ggtraceback()","code":""},{"path":"/news/index.html","id":"improvements-0-4-6","dir":"Changelog","previous_headings":"","what":"Improvements","title":"ggtrace 0.4.6","text":"default value verbose argument ggtrace() changed FALSE.","code":""},{"path":[]},{"path":"/news/index.html","id":"improvements-0-4-6-1","dir":"Changelog","previous_headings":"ggtrace 0.4.5","what":"Improvements","title":"ggtrace 0.4.6","text":"Deparsed expressions printed messages now wrapped backticks (#57) ggedit() now works isTRUE(interactive()) (#62)","code":""},{"path":"/news/index.html","id":"new-features-0-4-6-1","dir":"Changelog","previous_headings":"ggtrace 0.4.5","what":"New Features","title":"ggtrace 0.4.6","text":"Added global_ggtrace_on/() aliases global_ggtrace_state(TRUE/FALSE) (#63)","code":""},{"path":"/news/index.html","id":"miscellaneous-0-4-6","dir":"Changelog","previous_headings":"ggtrace 0.4.5","what":"Miscellaneous","title":"ggtrace 0.4.6","text":"Added exploratory debugging case study vignette","code":""},{"path":[]},{"path":"/news/index.html","id":"improvements-0-4-6-2","dir":"Changelog","previous_headings":"ggtrace 0.4.4","what":"Improvements","title":"ggtrace 0.4.6","text":"clear_(last|global)_ggtrace() functions now print message saying trace dump cleared. Better error handling closures aren’t searchable environments","code":""},{"path":"/news/index.html","id":"bug-fix-0-4-6","dir":"Changelog","previous_headings":"ggtrace 0.4.4","what":"Bug Fix","title":"ggtrace 0.4.6","text":"Fixed methods class  treated bare functions. Now closures methods outside ggproto objects (e.g., R6 classes) can traced .","code":""},{"path":"/news/index.html","id":"miscellaneous-0-4-6-1","dir":"Changelog","previous_headings":"ggtrace 0.4.4","what":"Miscellaneous","title":"ggtrace 0.4.6","text":"Added FAQ vignette","code":""},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-4-6","dir":"Changelog","previous_headings":"ggtrace 0.4.3","what":"Breaking changes","title":"ggtrace 0.4.6","text":"Global tracedump turned default (global_ggtrace_state() FALSE load) must explicitly activated global_ggtrace_state(TRUE).","code":""},{"path":"/news/index.html","id":"improvements-0-4-6-3","dir":"Changelog","previous_headings":"ggtrace 0.4.3","what":"Improvements","title":"ggtrace 0.4.6","text":"Improved messages global_ggtrace_state()","code":""},{"path":[]},{"path":"/news/index.html","id":"bug-fixes-0-4-6","dir":"Changelog","previous_headings":"ggtrace 0.4.2","what":"Bug Fixes","title":"ggtrace 0.4.6","text":"Fixed bug print_output = TRUE evaluate expression twice (problematic Inject workflows causing general slowdowns)","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-4-6-2","dir":"Changelog","previous_headings":"ggtrace 0.4.1","what":"New Features","title":"ggtrace 0.4.6","text":"Global collection tracedumps can turned /global_ggtrace_state(). still active default memory become concern, can turned global_ggtrace_state(state = FALSE).","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-4-6-3","dir":"Changelog","previous_headings":"ggtrace 0.4.0","what":"New Features","title":"ggtrace 0.4.6","text":"functions package now support tracing/untracing arbitrary functions (exported, unexported, user-defined, etc.). also includes S3/S4 methods like ggplo2:::ggplot_build.ggplot ggplot2:::ggplot_add.Layer. examples ’s now possible.","code":""},{"path":"/news/index.html","id":"improvements-0-4-6-4","dir":"Changelog","previous_headings":"ggtrace 0.4.0","what":"Improvements","title":"ggtrace 0.4.6","text":"ggtrace() gains ... extensibility future updates. ggedit() gains remove_trace argument. TRUE, untraces first editing. Improved error messages invalid expressions passed method argument ggbody()","code":""},{"path":"/news/index.html","id":"bug-fixes-0-4-6-1","dir":"Changelog","previous_headings":"ggtrace 0.4.0","what":"Bug Fixes","title":"ggtrace 0.4.6","text":"Fix bug ggtrace() fails evaluate first line ’s reachable line (#44)","code":""},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"bug-fixes-0-3","dir":"Changelog","previous_headings":"ggtrace 0.3.7","what":"Bug Fixes","title":"ggtrace 0.3.x","text":"Fixed bug incomplete traces due early returns logged without special warning. ggtrace() now throws warning actual number traced steps match expected number traced steps (.e., length trace_steps) logs incomplete tracedumps (#44)","code":""},{"path":[]},{"path":"/news/index.html","id":"improvements-0-3","dir":"Changelog","previous_headings":"ggtrace 0.3.6","what":"Improvements","title":"ggtrace 0.3.x","text":"ggtrace(..., = TRUE) less noisy persistent trace. now sends line message saying persistent trace created. ’s triggered, ’ll tell persistent trace methodbut remind untrace later print corresponding gguntrace() code .","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-1","dir":"Changelog","previous_headings":"ggtrace 0.3.6","what":"Bug Fixes","title":"ggtrace 0.3.x","text":"Fixed bug trace_exprs evaluating NULL removed tracedump (#38)","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-3","dir":"Changelog","previous_headings":"ggtrace 0.3.5","what":"New features","title":"ggtrace 0.3.x","text":"New function is_traced() checks whether method currently traced","code":""},{"path":"/news/index.html","id":"improvements-0-3-1","dir":"Changelog","previous_headings":"ggtrace 0.3.5","what":"Improvements","title":"ggtrace 0.3.x","text":"ggtrace() now breaks early informative message method function (ex: Stat$extra_params, 1-length character vector \"na.rm\") ggbody() now warns ’s returning body method ’s currently traced (#35) ggedit() now informs ’re editing top existing trace/edit.","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-2","dir":"Changelog","previous_headings":"ggtrace 0.3.5","what":"Bug Fixes","title":"ggtrace 0.3.x","text":"Fixed bug trace_exprs fail recycled list length-1. Now 1-length list expression well expression get recycled match number steps passed trace_steps. Fixed bug ggtrace() wouldn’t loop trace_exprs first time ’s triggered persistent tracing (= TRUE). Issue due failing reset internal counter time trace triggered.","code":""},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-3","dir":"Changelog","previous_headings":"ggtrace 0.3.4","what":"Breaking changes","title":"ggtrace 0.3.x","text":".print argument ggtrace() renamed print_output make functionality transparent.","code":""},{"path":"/news/index.html","id":"new-features-0-3-1","dir":"Changelog","previous_headings":"ggtrace 0.3.4","what":"New features","title":"ggtrace 0.3.x","text":"Several options finer control printing formatting output ggtrace(), addition existing .print argument: ggtrace() gets use_names argument. TRUE, uses names list expressions passed trace_exprs names tracedump set last_ggtrace() added global_ggtrace(). ggtrace() gets verbose argument. FALSE, suppresses display non-message() information, including information expression evaluated , well output expressions evaluated (can selectively suppressed .print finer control). verbose TRUE default. Setting options(ggtrace.suppressMessages = TRUE) also suppress messages()s method traced, whether trace triggered method, whether exists persistent trace, etc. information important using option recommended, made available. option set FALSE package load. Setting options(ggtrace.as_tibble = TRUE) return evaluated expressions tibbles output data frame. Using option may convenient interactive inspections recommended testing debugging (see related {ggplot2} Github issue). option set FALSE package load.","code":""},{"path":"/news/index.html","id":"improvements-0-3-2","dir":"Changelog","previous_headings":"ggtrace 0.3.4","what":"Improvements","title":"ggtrace 0.3.x","text":"Tracedumps accumulated global_ggtrace() named method (+ hexadecimal ID) ease searching. (#31) Triggering trace now informed via message() instead cat() (#29)","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-3","dir":"Changelog","previous_headings":"ggtrace 0.3.4","what":"Bug Fixes","title":"ggtrace 0.3.x","text":"ggtrace() correctly throws error trace_steps ordered. checked negative index conversion, something like trace_steps = c(1, -1) still works fine).","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-3-2","dir":"Changelog","previous_headings":"ggtrace 0.3.3","what":"New features","title":"ggtrace 0.3.x","text":"New function global_ggtrace() returns accumulated tracedumps ggtrace(). useful conjunction ggtrace(= FALSE) tracing method expect called multiple times (ex: Stat$compute_group gets triggered number times number groups panel). New function clear_global_ggtrace() clears global_ggtrace() setting NULL.","code":""},{"path":"/news/index.html","id":"improvements-0-3-3","dir":"Changelog","previous_headings":"ggtrace 0.3.3","what":"Improvements","title":"ggtrace 0.3.x","text":"Functions now pass around quosures instead expressions (#29) Testing setup (#28)","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-4","dir":"Changelog","previous_headings":"ggtrace 0.3.3","what":"Bug Fixes","title":"ggtrace 0.3.x","text":"Fixed bug number expressions passed trace_exprs allowed different number trace_steps, causing ggtrace() silently fail. now throws error.","code":""},{"path":[]},{"path":"/news/index.html","id":"improvements-0-3-4","dir":"Changelog","previous_headings":"ggtrace 0.3.2","what":"Improvements","title":"ggtrace 0.3.x","text":"trace_exprs argument can now take named list expressions (#21) Improved documentation ggbody() informative messages ggtrace() gguntrace()","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-5","dir":"Changelog","previous_headings":"ggtrace 0.3.2","what":"Bug fixes","title":"ggtrace 0.3.x","text":"longer errors exit creating persistence trace = FALSE","code":""},{"path":[]},{"path":"/news/index.html","id":"improvements-0-3-5","dir":"Changelog","previous_headings":"ggtrace 0.3.1","what":"Improvements","title":"ggtrace 0.3.x","text":"unary functions ggedit() gguntrace() gain dynamic dots ... second argument, gets ignored. now makes easy call function modifying call earlierggtrace function console interactive contexts. Significant re-write ggbody() better error handling (#23) Aborts method call accepted form, specific error messages . method doesn’t exist parent, directs users call ggbody(, inherit = TRUE) recursive search inherit = TRUE fails, directs users load relevant packages Notifies inherit = TRUE method defined object, inherited Better error handling gguntrace() method longer traced (#24) Uses re-written ggbody() validate method Unlike base::untrace(), longer errors given method currently traced. now prints message saying instead Standardization messages printed ggtrace functions. Messages now informative refer ggproto method callable format ggproto$method.","code":""},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-3-1","dir":"Changelog","previous_headings":"ggtrace 0.3.0","what":"Breaking changes","title":"ggtrace 0.3.x","text":"obj argument completely removed functions package. constraint supplying methods expressions forces users intentional tracing ggproto methods provide code. also allows functions return informative messages, main motivation breaking change. obj argument designed compatibility get(\"method\", ggproto) syntax retrieving function body ggproto methods, affect interactive workflows. fact, shortform method = ggproto$method convenient always recommended passing ggproto method ggtrace functions. reminder, functions take ggproto method method argument expects expression following forms (part hasn’t changed): ggproto$method namespace::ggproto$method namespace:::ggproto$method","code":""},{"path":"/news/index.html","id":"improvements-0-3-6","dir":"Changelog","previous_headings":"ggtrace 0.3.0","what":"Improvements","title":"ggtrace 0.3.x","text":"Accurate string conversion ggproto objects (#9), made possible breaking change. trace_steps argument can now take negative indices (#22) better error handling range indices. Better deparsing split_ggproto_method() internal. Added Tips & Tricks section documentation ggtrace().","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-6","dir":"Changelog","previous_headings":"ggtrace 0.3.0","what":"Bug fixes","title":"ggtrace 0.3.x","text":"Internal variable .store renamed .ggtrace_storage prevent overriding ggplot2::.store (#18)","code":""},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-2","dir":"Changelog","previous_headings":"ggtrace 0.2.0","what":"Breaking changes","title":"ggtrace 0.2.x","text":"~line keyword ggtrace() renamed ~step consistency argument name trace_steps (#14) safety reasons, ~step keyword now substituted expression current step ~step (.e., exact match) (#16, #11). example, ~step substituted quote(head(~step)) passed trace_exprs. Users encouraged return method’s environment quote(environment()) interactively debug ggedit() want manipulate expression. position obj argument ggtrace() moved second fourth, allow shortcuts like ggtrace(method = ..., 2:3, quote(data)), evaluate store output data variable second third steps method body. (#15)","code":""},{"path":"/news/index.html","id":"new-features-0-2","dir":"Changelog","previous_headings":"ggtrace 0.2.0","what":"New features","title":"ggtrace 0.2.x","text":"trace_exprs argument ggtrace() now optional. provided, defaults ~step (#13) can now tell ggbody() (recursively) search method parents inherit = TRUE (#12)","code":""},{"path":"/news/index.html","id":"improvements-0-2","dir":"Changelog","previous_headings":"ggtrace 0.2.0","what":"Improvements","title":"ggtrace 0.2.x","text":"Documentation functions now contain Gotchas section explanations / solutions common problems (#10)","code":""},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"new-features-0-1","dir":"Changelog","previous_headings":"ggtrace 0.1.2","what":"New features","title":"ggtrace 0.1.x","text":"New function gguntrace() syntax specifying ggproto method. ggtrace() gains = TRUE argument, can set FALSE persistent tracing","code":""},{"path":"/news/index.html","id":"bug-fixes-0-1","dir":"Changelog","previous_headings":"ggtrace 0.1.2","what":"Bug fixes","title":"ggtrace 0.1.x","text":"Fix bug ggtrace() step_deparsed returned multi-length vector","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-1-1","dir":"Changelog","previous_headings":"ggtrace 0.1.1","what":"New features","title":"ggtrace 0.1.x","text":"New function ggedit() interactive debugging via directly editing source code.","code":""},{"path":"/news/index.html","id":"improvements-0-1","dir":"Changelog","previous_headings":"ggtrace 0.1.1","what":"Improvements","title":"ggtrace 0.1.x","text":"Refactored ggtrace(). package now depends rlang. Significant re-write readme / documentation","code":""},{"path":[]},{"path":"/news/index.html","id":"initial-release-0-1","dir":"Changelog","previous_headings":"ggtrace 0.1.0","what":"Initial release","title":"ggtrace 0.1.x","text":"pkgdown site: https://yjunechoe.github.io/ggtrace Functions: ggtrace() ggbody() last_ggtrace()","code":""}]
