[{"path":"/articles/casestudy-after_scale.html","id":"motivating-thing","dir":"Articles","previous_headings":"","what":"Motivating thing","title":"Case Study: inspecting aes evaluation with `after_scale()`","text":"vignette starts question - happens ggplot internals something? Often times can make inferences surface form, surface form shares thing? ’ve hit roadblock traditional tools users, develop mental models. vignette shows can test hypotheses competing (mental) models ggplot internals make predictions (.e., plots “look” ). Going approach like scientific endeavor - fancy way saying kind trial--error way self-learning many useRs comfortable ","code":""},{"path":"/articles/casestudy-after_scale.html","id":"the-research-question","dir":"Articles","previous_headings":"","what":"The research question","title":"Case Study: inspecting aes evaluation with `after_scale()`","text":"know can map variable aesthetic. – plot also know taht can grab mapped aesthetics statistical transofmration scaling applied, after_stat() after_scale() respectivelyt. – plots also know can override aes constant supplied directly aes. (2-layer plot global aes inheritance)","code":""},{"path":"/articles/casestudy-after_scale.html","id":"under-construction","dir":"Articles","previous_headings":"","what":"Under construction","title":"Case Study: inspecting aes evaluation with `after_scale()`","text":"Slides ggplot internals / {ggtrace} talk December 4th 2021: https://yjunechoe.github.io/ggtrace-talk","code":"library(ggtrace)"},{"path":"/articles/casestudy-ggxmean.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Debugging an extension package","text":"like follow along, can install version {ggxmean} package containing bug vignette address. use devtools::dev_mode() install inspect version {ggxmean} development mode (except skip installation already version dev directory). ’ve also attached code relevant issue hand , like familiarize begin (though assume prior knowledge ).","code":"library(ggtrace) library(ggplot2) theme_set(theme_minimal()) library(devtools) #> Loading required package: usethis  # Current installation version devtools::package_info(\"ggxmean\", FALSE, FALSE)$source #> [1] \"local\"  # Activate development mode devtools::dev_mode(on = TRUE, path = getOption(\"devtools.path\")) #> ✔ Dev mode: ON  # devtools::install_github(\"EvaMaeRey/ggxmean@cbb909c\")  # Prior version installed for dev mode devtools::package_info(\"ggxmean\", FALSE, FALSE)$source #> [1] \"Github (EvaMaeRey/ggxmean@cbb909cee7d4f0a4395722020a75330641e5f54c)\"  library(ggxmean) # https://github.com/EvaMaeRey/ggxmean/blob/cbb909cee7d4f0a4395722020a75330641e5f54c/R/geom_x_line.R  GeomXline <- ggplot2::ggproto(\"GeomXline\", ggplot2::Geom,                      draw_panel = function(data, panel_params, coord) {                        ranges <- coord$backtransform_range(panel_params)                        data$x    <- data$x                        data$xend <- data$x                        data$y    <- ranges$y[1]                        data$yend <- ranges$y[2]                        GeomSegment$draw_panel(unique(data), panel_params, coord)                      },                      default_aes = ggplot2::aes(colour = \"black\", size = 0.5,                                        linetype = 1, alpha = NA),                      required_aes = \"x\",                      draw_key = ggplot2::draw_key_vline )  # https://github.com/EvaMaeRey/ggxmean/blob/cbb909cee7d4f0a4395722020a75330641e5f54c/R/geom_x_mean.R StatXmean <- ggplot2::ggproto(\"StatXmean\",                               ggplot2::Stat,                               compute_group = function(data, scales) {                                 data.frame(x = mean(data$x))                               },                               required_aes = c(\"x\") )  geom_x_mean <- function(mapping = NULL, data = NULL,                         position = \"identity\", na.rm = FALSE, show.legend = NA,                         inherit.aes = TRUE, ...) {   ggplot2::layer(     stat = StatXmean, geom = GeomXline, data = data, mapping = mapping,     position = position, show.legend = show.legend, inherit.aes = inherit.aes,     params = list(na.rm = na.rm, ...)   ) }"},{"path":"/articles/casestudy-ggxmean.html","id":"introduction-of-the-issue","dir":"Articles","previous_headings":"","what":"Introduction of the issue","title":"Debugging an extension package","text":"{ggxmean} {ggplot2} extension package offers many features, including layer geom_x_mean() can used draw line mean value variable represented x-axis.  geom_x_mean() works smoothly groups facets, might expect experience ggplot.  However, something somewhat unexpected happens pass map discrete variable aesthetic understandable geom_x_mean(). Despite fact lines understand fill aesthetic, aesthetic mapping fill = drv nevertheless highjacks calculation grouping geom_x_mean().","code":"ggplot(mpg, aes(x = hwy)) +   geom_histogram() +   geom_x_mean() #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(mpg, aes(x = hwy, group = drv)) +   geom_histogram() +   geom_x_mean() +   facet_wrap(~drv) #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(mpg, aes(x = hwy, fill = drv)) +   geom_histogram() +   geom_x_mean() #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`."},{"path":"/articles/casestudy-ggxmean.html","id":"making-a-reprex","dir":"Articles","previous_headings":"Introduction of the issue","what":"Making a reprex","title":"Debugging an extension package","text":"isolate problem, let’s remove geom_histogram() examples. minimal reprex (reproducible example) issue:  can pinpoint formalize issue help layer_data(). see expected group = drv unexpected fill = drv cases, end three unique groups (lines) indicated values group column.","code":"ggplot(mpg) +   aes(x = hwy, fill = drv) +   geom_x_mean() p <- ggplot(mpg) +   aes(x = hwy) +   geom_x_mean() layer_data(p + aes(group = drv)) #>          x group PANEL colour size linetype alpha #> 1 19.17476     1     1  black  0.5        1    NA #> 2 28.16038     2     1  black  0.5        1    NA #> 3 21.00000     3     1  black  0.5        1    NA layer_data(p + aes(fill = drv)) #>      fill        x PANEL group colour size linetype alpha #> 1 #F8766D 19.17476     1     1  black  0.5        1    NA #> 2 #00BA38 28.16038     1     2  black  0.5        1    NA #> 3 #619CFF 21.00000     1     3  black  0.5        1    NA"},{"path":"/articles/casestudy-ggxmean.html","id":"expected-cases","dir":"Articles","previous_headings":"Introduction of the issue","what":"Expected cases","title":"Debugging an extension package","text":", correctly get groups category drv lines understand color aesthetic.  also correctly get groups category drv set group aesthetic explicitly.","code":"p + aes(color = drv) layer_data(p + aes(color = drv))$group #> [1] 1 2 3 p + aes(group = drv) layer_data(p + aes(group = drv))$group #> [1] 1 2 3"},{"path":"/articles/casestudy-ggxmean.html","id":"unexpected-cases","dir":"Articles","previous_headings":"Introduction of the issue","what":"Unexpected cases","title":"Debugging an extension package","text":", ’d like 1 group/line lines don’t understand shape aesthetic  , ’d like 3 groups drv mapped color. Categories fl variable interact drv creation groups lines don’t understand fill aesthetic.","code":"p + aes(shape = drv) layer_data(p + aes(shape = drv))$group #> [1] 1 2 3 p + aes(fill = fl, color = drv) layer_data(p + aes(fill = fl, color = drv))$group #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12"},{"path":[]},{"path":[]},{"path":"/articles/casestudy-ggxmean.html","id":"starting-at-ggplot_build","dir":"Articles","previous_headings":"Debugging the issue with {ggtrace} > Step 1 - Locating the problem","what":"1.1 Starting at ggplot_build()","title":"Debugging an extension package","text":"first step, let’s see groups calculated added data inspecting ggplot_build(), main engine behind ggplot. exploratory debugging ggplot internals, inspecting data transformation pipeline ggplot_build() often best place start. first exposure ggplot_build(), just need know output basically ’s returned layer_data() function demoed . use ggbody() function {ggtrace} grab body ggplot_build() list, , metaprogramming rlang, pick steps data gets transformed. Note syntax ggplot2:::ggplot_build.ggplot reflects fact ggplot_build() S3 generic defined class <<ggplot>>. can inspect source code ggplot_build() ggplot2 Github repo, output ggbody(ggplot2:::ggplot_build.ggplot) also available : data transformation step (steps + 1L), let’s log data first () layer reprex plot. , tracedump1 list data looked like data-transformation step inside ggplot_build(). ’s list data frames ’s lot , ’s looks like ’s cleaned tibble::as_tibble() can now map every element list see group column first present. Step 12 ggplot_build() group first appears. suspect ’s group computed assigned code Step 12 ggplot_build() calls compute_aesthetics method layer l. by_layer() function defined Step 7 ggplot_build() ’s .","code":"layer_data #> function (plot, i = 1L)  #> { #>     ggplot_build(plot)$data[[i]] #> } #> <bytecode: 0x0000020c05f5ffe8> #> <environment: namespace:ggplot2> build_pipeline <- ggbody(ggplot2:::ggplot_build.ggplot) data_assigns <- sapply(build_pipeline,   function(x) {     rlang::is_call(x) &&       !is.null(rlang::call_name(x)) &&        rlang::call_name(x) == \"<-\" &&       rlang::call_args(x)[[1]] == \"data\"   } ) which(data_assigns) # Steps of the build pipeline where data is transformed #>  [1]  8  9 11 12 13 17 18 19 21 22 26 29 30 31 ggbody(ggplot2:::ggplot_build.ggplot) #> [[1]] #> `{` #>  #> [[2]] #> plot <- plot_clone(plot) #>  #> [[3]] #> if (length(plot$layers) == 0) { #>     plot <- plot + geom_blank() #> } #>  #> [[4]] #> layers <- plot$layers #>  #> [[5]] #> layer_data <- lapply(layers, function(y) y$layer_data(plot$data)) #>  #> [[6]] #> scales <- plot$scales #>  #> [[7]] #> by_layer <- function(f) { #>     out <- vector(\"list\", length(data)) #>     for (i in seq_along(data)) { #>         out[[i]] <- f(l = layers[[i]], d = data[[i]]) #>     } #>     out #> } #>  #> [[8]] #> data <- layer_data #>  #> [[9]] #> data <- by_layer(function(l, d) l$setup_layer(d, plot)) #>  #> [[10]] #> layout <- create_layout(plot$facet, plot$coordinates) #>  #> [[11]] #> data <- layout$setup(data, plot$data, plot$plot_env) #>  #> [[12]] #> data <- by_layer(function(l, d) l$compute_aesthetics(d, plot)) #>  #> [[13]] #> data <- lapply(data, scales_transform_df, scales = scales) #>  #> [[14]] #> scale_x <- function() scales$get_scales(\"x\") #>  #> [[15]] #> scale_y <- function() scales$get_scales(\"y\") #>  #> [[16]] #> layout$train_position(data, scale_x(), scale_y()) #>  #> [[17]] #> data <- layout$map_position(data) #>  #> [[18]] #> data <- by_layer(function(l, d) l$compute_statistic(d, layout)) #>  #> [[19]] #> data <- by_layer(function(l, d) l$map_statistic(d, plot)) #>  #> [[20]] #> scales_add_missing(plot, c(\"x\", \"y\"), plot$plot_env) #>  #> [[21]] #> data <- by_layer(function(l, d) l$compute_geom_1(d)) #>  #> [[22]] #> data <- by_layer(function(l, d) l$compute_position(d, layout)) #>  #> [[23]] #> layout$reset_scales() #>  #> [[24]] #> layout$train_position(data, scale_x(), scale_y()) #>  #> [[25]] #> layout$setup_panel_params() #>  #> [[26]] #> data <- layout$map_position(data) #>  #> [[27]] #> npscales <- scales$non_position_scales() #>  #> [[28]] #> if (npscales$n() > 0) { #>     lapply(data, scales_train_df, scales = npscales) #>     data <- lapply(data, scales_map_df, scales = npscales) #> } #>  #> [[29]] #> data <- by_layer(function(l, d) l$compute_geom_2(d)) #>  #> [[30]] #> data <- by_layer(function(l, d) l$finish_statistics(d)) #>  #> [[31]] #> data <- layout$finish_data(data) #>  #> [[32]] #> plot$labels$alt <- get_alt_text(plot) #>  #> [[33]] #> structure(list(data = data, layout = layout, plot = plot), class = \"ggplot_built\") ggtrace(   method = ggplot2:::ggplot_build.ggplot,   trace_steps = which(data_assigns) + 1, # After each data transformation step ...   trace_exprs = quote(data[[1]]),        # ... return the data for the first layer   verbose = FALSE ) #> `ggplot2:::ggplot_build.ggplot` now being traced.  # plot not printed for space p + aes(fill = drv) #> Triggering trace on `ggplot2:::ggplot_build.ggplot` #> Untracing `ggplot2:::ggplot_build.ggplot` on exit.  tracedump1 <- last_ggtrace() lapply(tracedump1, tibble::as_tibble) #> [[1]] #> # A tibble: 234 × 11 #>    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class #>    <chr>        <chr>      <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> #>  1 audi         a4           1.8  1999     4 auto… f        18    29 p     comp… #>  2 audi         a4           1.8  1999     4 manu… f        21    29 p     comp… #>  3 audi         a4           2    2008     4 manu… f        20    31 p     comp… #>  4 audi         a4           2    2008     4 auto… f        21    30 p     comp… #>  5 audi         a4           2.8  1999     6 auto… f        16    26 p     comp… #>  6 audi         a4           2.8  1999     6 manu… f        18    26 p     comp… #>  7 audi         a4           3.1  2008     6 auto… f        18    27 p     comp… #>  8 audi         a4 quattro   1.8  1999     4 manu… 4        18    26 p     comp… #>  9 audi         a4 quattro   1.8  1999     4 auto… 4        16    25 p     comp… #> 10 audi         a4 quattro   2    2008     4 manu… 4        20    28 p     comp… #> # … with 224 more rows #> # ℹ Use `print(n = ...)` to see more rows #>  #> [[2]] #> # A tibble: 234 × 11 #>    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class #>    <chr>        <chr>      <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> #>  1 audi         a4           1.8  1999     4 auto… f        18    29 p     comp… #>  2 audi         a4           1.8  1999     4 manu… f        21    29 p     comp… #>  3 audi         a4           2    2008     4 manu… f        20    31 p     comp… #>  4 audi         a4           2    2008     4 auto… f        21    30 p     comp… #>  5 audi         a4           2.8  1999     6 auto… f        16    26 p     comp… #>  6 audi         a4           2.8  1999     6 manu… f        18    26 p     comp… #>  7 audi         a4           3.1  2008     6 auto… f        18    27 p     comp… #>  8 audi         a4 quattro   1.8  1999     4 manu… 4        18    26 p     comp… #>  9 audi         a4 quattro   1.8  1999     4 auto… 4        16    25 p     comp… #> 10 audi         a4 quattro   2    2008     4 manu… 4        20    28 p     comp… #> # … with 224 more rows #> # ℹ Use `print(n = ...)` to see more rows #>  #> [[3]] #> # A tibble: 234 × 12 #>    manufactu…¹ model displ  year   cyl trans drv     cty   hwy fl    class PANEL #>    <chr>       <chr> <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> <fct> #>  1 audi        a4      1.8  1999     4 auto… f        18    29 p     comp… 1     #>  2 audi        a4      1.8  1999     4 manu… f        21    29 p     comp… 1     #>  3 audi        a4      2    2008     4 manu… f        20    31 p     comp… 1     #>  4 audi        a4      2    2008     4 auto… f        21    30 p     comp… 1     #>  5 audi        a4      2.8  1999     6 auto… f        16    26 p     comp… 1     #>  6 audi        a4      2.8  1999     6 manu… f        18    26 p     comp… 1     #>  7 audi        a4      3.1  2008     6 auto… f        18    27 p     comp… 1     #>  8 audi        a4 q…   1.8  1999     4 manu… 4        18    26 p     comp… 1     #>  9 audi        a4 q…   1.8  1999     4 auto… 4        16    25 p     comp… 1     #> 10 audi        a4 q…   2    2008     4 manu… 4        20    28 p     comp… 1     #> # … with 224 more rows, and abbreviated variable name ¹​manufacturer #> # ℹ Use `print(n = ...)` to see more rows #>  #> [[4]] #> # A tibble: 234 × 4 #>    fill      x PANEL group #>    <chr> <int> <fct> <int> #>  1 f        29 1         2 #>  2 f        29 1         2 #>  3 f        31 1         2 #>  4 f        30 1         2 #>  5 f        26 1         2 #>  6 f        26 1         2 #>  7 f        27 1         2 #>  8 4        26 1         1 #>  9 4        25 1         1 #> 10 4        28 1         1 #> # … with 224 more rows #> # ℹ Use `print(n = ...)` to see more rows #>  #> [[5]] #> # A tibble: 234 × 4 #>    fill      x PANEL group #>    <chr> <int> <fct> <int> #>  1 f        29 1         2 #>  2 f        29 1         2 #>  3 f        31 1         2 #>  4 f        30 1         2 #>  5 f        26 1         2 #>  6 f        26 1         2 #>  7 f        27 1         2 #>  8 4        26 1         1 #>  9 4        25 1         1 #> 10 4        28 1         1 #> # … with 224 more rows #> # ℹ Use `print(n = ...)` to see more rows #>  #> [[6]] #> # A tibble: 234 × 4 #>    fill      x PANEL group #>    <chr> <dbl> <fct> <int> #>  1 f        29 1         2 #>  2 f        29 1         2 #>  3 f        31 1         2 #>  4 f        30 1         2 #>  5 f        26 1         2 #>  6 f        26 1         2 #>  7 f        27 1         2 #>  8 4        26 1         1 #>  9 4        25 1         1 #> 10 4        28 1         1 #> # … with 224 more rows #> # ℹ Use `print(n = ...)` to see more rows #>  #> [[7]] #> # A tibble: 3 × 4 #>       x fill  PANEL group #>   <dbl> <chr> <fct> <int> #> 1  19.2 4     1         1 #> 2  28.2 f     1         2 #> 3  21   r     1         3 #>  #> [[8]] #> # A tibble: 3 × 4 #>       x fill  PANEL group #>   <dbl> <chr> <fct> <int> #> 1  19.2 4     1         1 #> 2  28.2 f     1         2 #> 3  21   r     1         3 #>  #> [[9]] #> # A tibble: 3 × 4 #>       x fill  PANEL group #>   <dbl> <chr> <fct> <int> #> 1  19.2 4     1         1 #> 2  28.2 f     1         2 #> 3  21   r     1         3 #>  #> [[10]] #> # A tibble: 3 × 4 #>       x fill  PANEL group #>   <dbl> <chr> <fct> <int> #> 1  19.2 4     1         1 #> 2  28.2 f     1         2 #> 3  21   r     1         3 #>  #> [[11]] #> # A tibble: 3 × 4 #>       x fill  PANEL group #>   <dbl> <chr> <fct> <int> #> 1  19.2 4     1         1 #> 2  28.2 f     1         2 #> 3  21   r     1         3 #>  #> [[12]] #> # A tibble: 3 × 8 #>   fill        x PANEL group colour  size linetype alpha #>   <chr>   <dbl> <fct> <int> <chr>  <dbl>    <dbl> <lgl> #> 1 #F8766D  19.2 1         1 black    0.5        1 NA    #> 2 #00BA38  28.2 1         2 black    0.5        1 NA    #> 3 #619CFF  21   1         3 black    0.5        1 NA    #>  #> [[13]] #> # A tibble: 3 × 8 #>   fill        x PANEL group colour  size linetype alpha #>   <chr>   <dbl> <fct> <int> <chr>  <dbl>    <dbl> <lgl> #> 1 #F8766D  19.2 1         1 black    0.5        1 NA    #> 2 #00BA38  28.2 1         2 black    0.5        1 NA    #> 3 #619CFF  21   1         3 black    0.5        1 NA    #>  #> [[14]] #> # A tibble: 3 × 8 #>   fill        x PANEL group colour  size linetype alpha #>   <chr>   <dbl> <fct> <int> <chr>  <dbl>    <dbl> <lgl> #> 1 #F8766D  19.2 1         1 black    0.5        1 NA    #> 2 #00BA38  28.2 1         2 black    0.5        1 NA    #> 3 #619CFF  21   1         3 black    0.5        1 NA group_present1 <- sapply(tracedump1, function(x) {   \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3 }) #> Warning in \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3: 'length(x) #> = 3 > 1' in coercion to 'logical(1)'  #> Warning in \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3: 'length(x) #> = 3 > 1' in coercion to 'logical(1)'  #> Warning in \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3: 'length(x) #> = 3 > 1' in coercion to 'logical(1)'  #> Warning in \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3: 'length(x) #> = 3 > 1' in coercion to 'logical(1)'  #> Warning in \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3: 'length(x) #> = 3 > 1' in coercion to 'logical(1)'  #> Warning in \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3: 'length(x) #> = 3 > 1' in coercion to 'logical(1)'  #> Warning in \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3: 'length(x) #> = 3 > 1' in coercion to 'logical(1)'  #> Warning in \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3: 'length(x) #> = 3 > 1' in coercion to 'logical(1)'  #> Warning in \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3: 'length(x) #> = 3 > 1' in coercion to 'logical(1)'  #> Warning in \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3: 'length(x) #> = 3 > 1' in coercion to 'logical(1)'  #> Warning in \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3: 'length(x) #> = 3 > 1' in coercion to 'logical(1)' group_present1 #>  [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE #> [13]  TRUE  TRUE which(data_assigns)[min(which(group_present1))] #> [1] 12 ggbody(ggplot2:::ggplot_build.ggplot)[[12]] #> data <- by_layer(function(l, d) l$compute_aesthetics(d, plot)) ggbody(ggplot2:::ggplot_build.ggplot)[[7]] #> by_layer <- function(f) { #>     out <- vector(\"list\", length(data)) #>     for (i in seq_along(data)) { #>         out[[i]] <- f(l = layers[[i]], d = data[[i]]) #>     } #>     out #> }"},{"path":"/articles/casestudy-ggxmean.html","id":"digging-deeper-into-layercompute_aesthetics","dir":"Articles","previous_headings":"Debugging the issue with {ggtrace} > Step 1 - Locating the problem","what":"1.2 Digging deeper into Layer$compute_aesthetics()","title":"Debugging an extension package","text":"point realize go little deeper ggplot_build(). need inspect Layer$compute_aesthetics - compute_aesthetics method Layer ggproto. (Check quick aside Layer ggproto first time encountering , purposes vignette just need know Layer$compute_aesthetics function called inside ggplot_build() think group calculated.) Layer object returned ggplot2::layer(). don’t see function often, ’s gets returned geom_*() stat_*() functions, ’ve actually seen lot. example, call geom_bar() , ’ll get back object class LayerInstance/Layer body geom_bar() just calls layer() defaults optimized drawing bar plots. two practically : Layer objects various properties methods, including compute_aesthetics. compute_aesthetics method defined parent Layer ggproto unexported. layer returned geom_bar() simply inherits method, reflected fact class LayerInstance, also . Let’s now repeat know-nothing, brute-force exploratory process inside Layer$compute_aesthetics. , inspect output every line using ~step keyword inside trace_exprs argument locate group get computed. Step 21 Layer$compute_aesthetics seems happens. , calls unexported internal utility function called add_group(), look source code can confirm indeed located group calculated assigned. gets us half-way solving issue can’t/shouldn’t modify Layer ggproto extension packages - ’s unexported! Plus, want change behavior geom_x_mean() specifically, aesthetics can’t understand ignored calculation groups, groups layers.","code":"geom_bar() #> geom_bar: width = NULL, na.rm = FALSE, orientation = NA #> stat_count: width = NULL, na.rm = FALSE, orientation = NA #> position_stack class(geom_bar()) #> [1] \"LayerInstance\" \"Layer\"         \"ggproto\"       \"gg\" body(geom_bar) #> { #>     layer(data = data, mapping = mapping, stat = stat, geom = GeomBar,  #>         position = position, show.legend = show.legend, inherit.aes = inherit.aes,  #>         params = list(width = width, na.rm = na.rm, orientation = orientation,  #>             ...)) #> } geom_bar() #> geom_bar: width = NULL, na.rm = FALSE, orientation = NA #> stat_count: width = NULL, na.rm = FALSE, orientation = NA #> position_stack layer(   geom = GeomBar, stat = StatCount, position = PositionStack,   params = list(width = NULL, na.rm = FALSE, orientation = NA) ) #> geom_bar: width = NULL, na.rm = FALSE, orientation = NA #> stat_count: width = NULL, na.rm = FALSE, orientation = NA #> position_stack names(as.list(geom_bar())) #>  [1] \"mapping\"              \"geom_params\"          \"layer_data\"           #>  [4] \"compute_statistic\"    \"computed_mapping\"     \"compute_aesthetics\"   #>  [7] \"stat_params\"          \"map_statistic\"        \"draw_geom\"            #> [10] \"stat\"                 \"setup_layer\"          \"inherit.aes\"          #> [13] \"finish_statistics\"    \"geom\"                 \"compute_position\"     #> [16] \"position\"             \"print\"                \"data\"                 #> [19] \"aes_params\"           \"computed_stat_params\" \"computed_geom_params\" #> [22] \"compute_geom_1\"       \"compute_geom_2\"       \"show.legend\" class(ggplot2:::Layer) #> [1] \"Layer\"   \"ggproto\" \"gg\" class(geom_bar()) #> [1] \"LayerInstance\" \"Layer\"         \"ggproto\"       \"gg\" ggbody(ggplot2:::Layer$compute_aesthetics) #> [[1]] #> `{` #>  #> [[2]] #> aesthetics <- self$computed_mapping #>  #> [[3]] #> set <- names(aesthetics) %in% names(self$aes_params) #>  #> [[4]] #> calculated <- is_calculated_aes(aesthetics) #>  #> [[5]] #> modifiers <- is_scaled_aes(aesthetics) #>  #> [[6]] #> aesthetics <- aesthetics[!set & !calculated & !modifiers] #>  #> [[7]] #> if (!is.null(self$geom_params$group)) { #>     aesthetics[[\"group\"]] <- self$aes_params$group #> } #>  #> [[8]] #> scales_add_defaults(plot$scales, data, aesthetics, plot$plot_env) #>  #> [[9]] #> env <- child_env(baseenv(), stage = stage) #>  #> [[10]] #> evaled <- lapply(aesthetics, eval_tidy, data = data, env = env) #>  #> [[11]] #> evaled <- compact(evaled) #>  #> [[12]] #> warn_for_aes_extract_usage(aesthetics, data[setdiff(names(data),  #>     \"PANEL\")]) #>  #> [[13]] #> nondata_cols <- check_nondata_cols(evaled) #>  #> [[14]] #> if (length(nondata_cols) > 0) { #>     msg <- paste0(\"Aesthetics must be valid data columns. Problematic aesthetic(s): \",  #>         paste0(vapply(nondata_cols, function(x) { #>             paste0(x, \" = \", as_label(aesthetics[[x]])) #>         }, character(1)), collapse = \", \"), \". \\nDid you mistype the name of a data column or forget to add after_stat()?\") #>     abort(msg) #> } #>  #> [[15]] #> n <- nrow(data) #>  #> [[16]] #> if (n == 0) { #>     if (length(evaled) == 0) { #>         n <- 0 #>     } #>     else { #>         n <- max(vapply(evaled, length, integer(1))) #>     } #> } #>  #> [[17]] #> check_aesthetics(evaled, n) #>  #> [[18]] #> if (empty(data) && n > 0) { #>     evaled$PANEL <- 1 #> } else { #>     evaled$PANEL <- data$PANEL #> } #>  #> [[19]] #> evaled <- lapply(evaled, unname) #>  #> [[20]] #> evaled <- as_gg_data_frame(evaled) #>  #> [[21]] #> evaled <- add_group(evaled) #>  #> [[22]] #> evaled ggtrace(   method = ggplot2:::Layer$compute_aesthetics,   trace_steps = seq_along(ggbody(ggplot2:::Layer$compute_aesthetics)),   trace_exprs = quote(~step),   verbose = FALSE ) #> `ggplot2:::Layer$compute_aesthetics` now being traced.  # plot not printed for space p + aes(fill = drv) #> Triggering trace on `ggplot2:::Layer$compute_aesthetics` #> Untracing `ggplot2:::Layer$compute_aesthetics` on exit.  tracedump2 <- last_ggtrace()  group_present2 <- sapply(tracedump2, function(x) {   \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3 }) #> Warning in \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3: 'length(x) #> = 3 > 1' in coercion to 'logical(1)'  #> Warning in \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3: 'length(x) #> = 3 > 1' in coercion to 'logical(1)' length(group_present2) #> [1] 22 which(group_present2) #> [1] 21 22 min(which(group_present2)) #> [1] 21 ggbody(ggplot2:::Layer$compute_aesthetics)[[21]] #> evaled <- add_group(evaled)"},{"path":"/articles/casestudy-ggxmean.html","id":"step-2---identifying-the-extension-point","dir":"Articles","previous_headings":"Debugging the issue with {ggtrace}","what":"Step 2 - Identifying the extension point","title":"Debugging an extension package","text":"point, hunt next time Layer dispatches Stat Geom ggproto method transformed data group calculated, can undo grouping calculation inside Stat/Geom necessary (since Stat Geom exported recommended extension points). Going back ggplot_build(), next l$<method> call l$compute_aesthetics compute_statistic method Step 18 Let’s see happens inside Layer$compute_statistic method see next time data gets transformed passed Layer$compute_statistic setup_data method layer’s Stat ggproto Step 4. Let’s see kind information stage, whether information sufficient us implement desired design change geom_x_mean()","code":"ggbody(ggplot2:::ggplot_build.ggplot)[[18]] #> data <- by_layer(function(l, d) l$compute_statistic(d, layout)) ggbody(ggplot2:::Layer$compute_statistic) #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(new_data_frame()) #>  #> [[3]] #> self$computed_stat_params <- self$stat$setup_params(data, self$stat_params) #>  #> [[4]] #> data <- self$stat$setup_data(data, self$computed_stat_params) #>  #> [[5]] #> self$stat$compute_layer(data, self$computed_stat_params, layout) ggbody(ggplot2:::Layer$compute_statistic)[[4]] #> data <- self$stat$setup_data(data, self$computed_stat_params)"},{"path":"/articles/casestudy-ggxmean.html","id":"step-2-1---inspecting-the-setup_data-method","dir":"Articles","previous_headings":"Debugging the issue with {ggtrace} > Step 2 - Identifying the extension point","what":"Step 2.1 - Inspecting the setup_data method","title":"Debugging an extension package","text":"First, let’s figure Stat ggproto associated geom_x_mean() let’s inspect setup_data method looks like setup_data inherited parent ggproto. candidate looking class() Stat parent ggproto. decide change behavior setup_data StatXmean, ’ll need define version method, instead simlpy inherit Stat$setup_data. now, let’s grab inherited method Stat proceed inspecting behavior. inherit = TRUE argument inside ggbody(), confirm StatXmean indeed inherits Stat$setup_data Okay method just returns data default. data look like practice?","code":"class(geom_x_mean()$stat)[1] #> [1] \"StatXmean\" ggbody(ggxmean:::StatXmean$setup_data) # errors! #> Error: #> ! Method 'setup_data' is not defined for `ggxmean:::StatXmean` #> Check inheritance with `get_method_inheritance(ggxmean:::StatXmean)` class(ggxmean:::StatXmean) #> [1] \"StatXmean\" \"Stat\"      \"ggproto\"   \"gg\" ggbody(ggxmean:::StatXmean$setup_data, inherit = TRUE) #> Method inherited from `Stat$setup_data` #> [[1]] #> `{` #>  #> [[2]] #> data"},{"path":"/articles/casestudy-ggxmean.html","id":"step-2-2---logging-the-execution-of-statsetup_data","dir":"Articles","previous_headings":"Debugging the issue with {ggtrace} > Step 2 - Identifying the extension point","what":"Step 2.2 - Logging the execution of Stat$setup_data","title":"Debugging an extension package","text":"following ggtrace() code shorthand inserting trace simply returns output last step (-1) method: see data contains information supplied aesthetics calculated PANEL group information. sufficient information purposes.","code":"ggtrace(Stat$setup_data, -1, verbose = FALSE) #> `Stat$setup_data` now being traced.  # plot not printed for space p + aes(fill = drv) #> Triggering trace on `Stat$setup_data` #> Untracing `Stat$setup_data` on exit. tibble::as_tibble(last_ggtrace()[[1]]) #> # A tibble: 234 × 4 #>    fill      x PANEL group #>    <chr> <dbl> <fct> <int> #>  1 f        29 1         2 #>  2 f        29 1         2 #>  3 f        31 1         2 #>  4 f        30 1         2 #>  5 f        26 1         2 #>  6 f        26 1         2 #>  7 f        27 1         2 #>  8 4        26 1         1 #>  9 4        25 1         1 #> 10 4        28 1         1 #> # … with 224 more rows #> # ℹ Use `print(n = ...)` to see more rows"},{"path":[]},{"path":"/articles/casestudy-ggxmean.html","id":"step-3-1---devising-a-plan-pseudo-code-outline","dir":"Articles","previous_headings":"Debugging the issue with {ggtrace} > Step 3 - Developing a solution","what":"Step 3.1 - Devising a plan (pseudo-code outline)","title":"Debugging an extension package","text":"’s plan. Instead setup_data method just return data receives, let’s check two conditions: , leave data alone. Otherwise… , leave data alone. Otherwise, re-calculate groups dropping extraneous variables passing data ggplot2:::add_group() .","code":""},{"path":"/articles/casestudy-ggxmean.html","id":"step-3-2---setting-up-for-testing","dir":"Articles","previous_headings":"Debugging the issue with {ggtrace} > Step 3 - Developing a solution","what":"Step 3.2 - Setting up for testing","title":"Debugging an extension package","text":"One biggest perks {ggtrace} ability log output triggered traces. ’ve seeing bit last_ggtrace() can scale . Using global_ggtrace() persistent tracing ggtrace(= FALSE), can capture data looks like inside setup_data method across two expected two unexpected cases reprex. Now tracedump3 holds value data inside setup_data method four plots interest.","code":"# Turn the global tracedump on global_ggtrace_on() #> Global tracedump activated.  ggtrace(Stat$setup_data, -1, once = FALSE, verbose = FALSE) #> `Stat$setup_data` now being traced. #> Creating a persistent trace. Remember to `gguntrace(Stat$setup_data)`!  # plots not printed for space p + aes(color = drv) #> Triggering persistent trace on `Stat$setup_data` p + aes(group = drv) #> Triggering persistent trace on `Stat$setup_data` p + aes(shape = drv) #> Triggering persistent trace on `Stat$setup_data` p + aes(fill = fl, color = drv) #> Triggering persistent trace on `Stat$setup_data`  tracedump3 <- global_ggtrace() tracedump3 <- lapply(tracedump3, `[[`, 1) # simplify  # Clean up and turn the global tracedump back off gguntrace(Stat$setup_data) #> `Stat$setup_data` no longer being traced. clear_global_ggtrace() #> Global tracedump cleared. global_ggtrace_off() #> Global tracedump deactivated.  # Label the trace dumps names(tracedump3) <- c(paste0(\"expected\", 1:2), paste0(\"unexpected\", 1:2)) names(tracedump3) #> [1] \"expected1\"   \"expected2\"   \"unexpected1\" \"unexpected2\" lapply(tracedump3, tibble::as_tibble) #> $expected1 #> # A tibble: 234 × 4 #>    colour     x PANEL group #>    <chr>  <dbl> <fct> <int> #>  1 f         29 1         2 #>  2 f         29 1         2 #>  3 f         31 1         2 #>  4 f         30 1         2 #>  5 f         26 1         2 #>  6 f         26 1         2 #>  7 f         27 1         2 #>  8 4         26 1         1 #>  9 4         25 1         1 #> 10 4         28 1         1 #> # … with 224 more rows #> # ℹ Use `print(n = ...)` to see more rows #>  #> $expected2 #> # A tibble: 234 × 3 #>        x group PANEL #>    <dbl> <int> <fct> #>  1    29     2 1     #>  2    29     2 1     #>  3    31     2 1     #>  4    30     2 1     #>  5    26     2 1     #>  6    26     2 1     #>  7    27     2 1     #>  8    26     1 1     #>  9    25     1 1     #> 10    28     1 1     #> # … with 224 more rows #> # ℹ Use `print(n = ...)` to see more rows #>  #> $unexpected1 #> # A tibble: 234 × 4 #>    shape     x PANEL group #>    <chr> <dbl> <fct> <int> #>  1 f        29 1         2 #>  2 f        29 1         2 #>  3 f        31 1         2 #>  4 f        30 1         2 #>  5 f        26 1         2 #>  6 f        26 1         2 #>  7 f        27 1         2 #>  8 4        26 1         1 #>  9 4        25 1         1 #> 10 4        28 1         1 #> # … with 224 more rows #> # ℹ Use `print(n = ...)` to see more rows #>  #> $unexpected2 #> # A tibble: 234 × 5 #>    fill  colour     x PANEL group #>    <chr> <chr>  <dbl> <fct> <int> #>  1 p     f         29 1         8 #>  2 p     f         29 1         8 #>  3 p     f         31 1         8 #>  4 p     f         30 1         8 #>  5 p     f         26 1         8 #>  6 p     f         26 1         8 #>  7 p     f         27 1         8 #>  8 p     4         26 1         7 #>  9 p     4         25 1         7 #> 10 p     4         28 1         7 #> # … with 224 more rows #> # ℹ Use `print(n = ...)` to see more rows"},{"path":[]},{"path":"/articles/casestudy-ggxmean.html","id":"part-1---check-if-group-is-derived","dir":"Articles","previous_headings":"Debugging the issue with {ggtrace} > Step 3 - Developing a solution > Step 3.3 - Tackling the problem piece by piece","what":"Part 1 - Check if group is derived","title":"Debugging an extension package","text":"first condition checking whether group explicitly supplied actually easy implement. Going back Layer$compute_aesthetics, can see PANEL column assigned first group column assigned afterwards. means group already exist, ’d appear right PANEL. exist , ’d just modified original position appear left PANEL (since PANEL can never exist ). can confirm two expected cases: can make function checks position group column relative PANEL column, use tracedump validate ","code":"colnames(tracedump3$expected1) # `aes(color = drv)` #> [1] \"colour\" \"x\"      \"PANEL\"  \"group\" colnames(tracedump3$expected2) # `aes(group = drv)` #> [1] \"x\"     \"group\" \"PANEL\" group_is_derived <- function(data) {   # Do \"group\" and \"PANEL\" appear out of order?   is.unsorted(match(c(\"group\", \"PANEL\"), colnames(data))) } group_is_derived(tracedump3$expected1) #> [1] TRUE group_is_derived(tracedump3$expected2) #> [1] FALSE"},{"path":"/articles/casestudy-ggxmean.html","id":"part-2---check-if-the-geom-can-understand-all-discrete-aesthetics","dir":"Articles","previous_headings":"Debugging the issue with {ggtrace} > Step 3 - Developing a solution > Step 3.3 - Tackling the problem piece by piece","what":"Part 2 - Check if the geom can understand all discrete aesthetics","title":"Debugging an extension package","text":"second condition, need figure aesthetics geom can understand. First, check geom geom_x_mean() uses. see uses unexported geom ggxmean:::GeomXline. gather aesthetics can handle just want check among non-positional aesthetics, set want: can now write function returns discrete variables data understood GeomXline. validate function tracedump","code":"class(geom_x_mean()$geom)[1] #> [1] \"GeomXline\" understandable_aes <- unique(c(   ggxmean:::GeomXline$required_aes,   names(ggxmean:::GeomXline$default_aes),   ggxmean:::GeomXline$optional_aes )) understandable_aes #> [1] \"x\"        \"colour\"   \"size\"     \"linetype\" \"alpha\" understandable_aes[!understandable_aes %in% c(\"x\", \"y\")] #> [1] \"colour\"   \"size\"     \"linetype\" \"alpha\" not_understandable_aes <- function(data) {   discretes <- colnames(data)[sapply(data, ggplot2:::is.discrete)]   discretes <- discretes[!discretes %in% c(\"group\", \"PANEL\")]   discretes[!discretes %in% c(\"colour\", \"size\", \"linetype\", \"alpha\")] } lengths(lapply(tracedump3, not_understandable_aes)) > 0 #>   expected1   expected2 unexpected1 unexpected2  #>       FALSE       FALSE        TRUE        TRUE not_understandable_aes(tracedump3$unexpected1) #> [1] \"shape\" not_understandable_aes(tracedump3$unexpected2) #> [1] \"fill\""},{"path":"/articles/casestudy-ggxmean.html","id":"part-3---handle-the-exception","dir":"Articles","previous_headings":"Debugging the issue with {ggtrace} > Step 3 - Developing a solution > Step 3.3 - Tackling the problem piece by piece","what":"Part 3 - Handle the exception","title":"Debugging an extension package","text":"Lastly, case groups computed using discrete variables mapped aesthetics GeomXline doesn’t understand, want re-assign groups. following function takes data, strips offending variables/columns, returns vector new groupings. returns us expected number groups unexpected reprex cases (recall unexpected2 used 12 groups now 3 ’s correctly ignoring interaction fill = fl).","code":"retrained_groups <- function(data) {   not_understandables <- not_understandable_aes(data)   data <- data[!colnames(data) %in% c(\"group\", not_understandables)]   ggplot2:::add_group(data)$group } lapply(tracedump3[3:4], function(x) { sort(unique(retrained_groups(x))) }) #> $unexpected1 #> [1] -1 #>  #> $unexpected2 #> [1] 1 2 3"},{"path":"/articles/casestudy-ggxmean.html","id":"part-4---bring-it-together","dir":"Articles","previous_headings":"Debugging the issue with {ggtrace} > Step 3 - Developing a solution > Step 3.3 - Tackling the problem piece by piece","what":"Part 4 - Bring it together","title":"Debugging an extension package","text":"Now melt functions Parts 1-3 single function become new setup_data method StatXmean. validate expected unexpected cases see indeed works! *Note ’re still using unexported ggplot2 functions like .discrete add_group. ’d normally refactor copy releasing fix, ’ll skip sake time.","code":"setup_data_new <- function(data) {   if (is.unsorted(match(c(\"group\", \"PANEL\"), colnames(data)))) {     discretes <- colnames(data)[sapply(data, ggplot2:::is.discrete)]     discretes <- discretes[!discretes %in% c(\"group\", \"PANEL\")]     not_understandables <- discretes[!discretes %in% c(\"colour\", \"size\", \"linetype\", \"alpha\")]     if (length(not_understandables) > 0) {       dummy_data <- data[!colnames(data) %in% c(\"group\", not_understandables)]       data$group <- ggplot2:::add_group(dummy_data)$group     }   }   data } tracedump3_modified <- lapply(tracedump3, setup_data_new) lapply(tracedump3_modified, function(x) sort(unique(x$group) )) #> $expected1 #> [1] 1 2 3 #>  #> $expected2 #> [1] 1 2 3 #>  #> $unexpected1 #> [1] -1 #>  #> $unexpected2 #> [1] 1 2 3"},{"path":"/articles/casestudy-ggxmean.html","id":"step-3-4---implementing-the-solution","dir":"Articles","previous_headings":"Debugging the issue with {ggtrace} > Step 3 - Developing a solution","what":"Step 3.4 - Implementing the solution","title":"Debugging an extension package","text":"’d like test whole solution user-facing layer call day. just two important pieces : create ggproto class called StatXmean2 exact copy StatXmean except also defines setup_data method defined . create layer called geom_x_mean2() exact copy geom_x_mean() except stat argument ofggplot2::layer() StatXmean2 final check original reprexes shows works intended","code":"StatXmean2 <- ggplot2::ggproto(   \"StatXmean2\",   ggplot2::Stat,   setup_data = function(data, params) {     if (is.unsorted(match(c(\"group\", \"PANEL\"), colnames(data)))) {       discretes <- colnames(data)[sapply(data, ggplot2:::is.discrete)]       discretes <- discretes[!discretes %in% c(\"group\", \"PANEL\")]       not_understandables <- discretes[!discretes %in% c(\"colour\", \"size\", \"linetype\", \"alpha\")]       if (length(not_understandables) > 0) {         dummy_data <- data[!colnames(data) %in% c(\"group\", not_understandables)]         data$group <- ggplot2:::add_group(dummy_data)$group       }     }     data   },   compute_group = function(data, scales) {     data.frame(x = mean(data$x))   },   required_aes = c(\"x\") )  geom_x_mean2 <- function(mapping = NULL, data = NULL,                         position = \"identity\", na.rm = FALSE, show.legend = NA,                         inherit.aes = TRUE, ...) {   ggplot2::layer(     stat = StatXmean2, geom = ggxmean:::GeomXline, data = data, mapping = mapping,     position = position, show.legend = show.legend, inherit.aes = inherit.aes,     params = list(na.rm = na.rm, ...)   ) } p2 <- ggplot(mpg) +   aes(x = hwy) +   geom_x_mean2()  p2 + aes(color = drv) p2 + aes(group = drv) p2 + aes(shape = drv) p2 + aes(fill = fl, color = drv)"},{"path":"/articles/casestudy-ggxmean.html","id":"step-3-5---testing-the-solution","dir":"Articles","previous_headings":"Debugging the issue with {ggtrace} > Step 3 - Developing a solution","what":"Step 3.5 - Testing the solution","title":"Debugging an extension package","text":"want write tests, can also check whether solution generalizes cases. , can see correctly works facets even groups missing facet, ’s good  can also see fails way ’s supplied explicit group aesthetic also receives another discrete mapping color  ’s one unique match fl == \"c\" drv== \"f\", unique value drv four fl categories. color scale assigns color one lines four lines just gives returns NAs (colored grey default)","code":"p2 +   aes(color = drv) +   facet_wrap(~fl) p2 + aes(group = fl, color = drv) table(mpg$drv, mpg$fl) #>     #>      c  d  e  p  r #>   4  0  2  6 20 75 #>   f  1  3  1 25 76 #>   r  0  0  1  7 17 p2 +   aes(group = fl, color = drv) +   geom_label(aes(label = fl, y = 0), stat = StatXmean2)"},{"path":"/articles/casestudy-ggxmean.html","id":"wrapping-up","dir":"Articles","previous_headings":"Debugging the issue with {ggtrace}","what":"Wrapping up","title":"Debugging an extension package","text":"’re satisfied can now turn development mode , lets us access current installation {ggxmean} . can now also test solution current version package see whether ’d still work (although skip step ). Finally, since vignette covered real-world debugging scenario, solution submitted PR! Many thanks Gina allowing use {ggxmean} case study exploratory debugging {ggtrace}!","code":"devtools::dev_mode(on = FALSE) #> ✔ Dev mode: OFF devtools::package_info(\"ggxmean\", FALSE, FALSE)$source #> [1] \"local\""},{"path":[]},{"path":"/articles/comparisons.html","id":"sneak-peak","dir":"Articles","previous_headings":"Under construction","what":"Sneak peak:","title":"Comparison of debugging methods","text":"debug()/debugonce() browser() + load_all() layer_data() trace() Hiroaki Yutani’s blog post {ggplot2} + browser() Pedro J. Aphalo’s {gginnards} Brodie Gaslam’s {ggbg} ggplot2 internals reference document Dewey Dunnington’s {ggdebug}, also features function name ggdebug::ggtrace use trace(). Maybe things changed last 2-3 years, trace() untrace() work ggproto methods, package shows!","code":""},{"path":"/articles/FAQ.html","id":"is-ggtrace-safe","dir":"Articles","previous_headings":"","what":"Is ggtrace() safe?","title":"Frequently asked questions","text":"ggtrace() essentially just wrapper around base::trace() designed make easy safe programmatically trace/untrace functions methods. short answer ggtrace() least safe trace(). safe trace()? beauty trace() modified function traced masks original function without overwriting . allows non-destructive modifications execution behavior. simple example, add trace replace() multiples value x 10 function enters last step. traced function looks strange runs different behavior , non-destructive. original function body safely stored away \"original\" attribute traced function original function can recovered removing trace call untrace() Beyond , ggtrace also offers extra built-safety measures: Cleans untracing exit (default behavior = TRUE) Always untraces tracing, prevents nested traces created Provides ample messages whethere existing trace (can also check is_traced()) Exits early possible method expression ill-formed informative error messages can actually act Prevents traces created functions aren’t bound variable way (.e., prevents creating traces can’t trigger) However, expression pass ggtrace() delayed evaluation without consequences. need careful running functions side effects making assignments environments (ex: self$method <- ... modify place). isn’t problem ggtrace - follow general rules reference semantics R.","code":"body(replace) #> { #>     x[list] <- values #>     x #> }  replace(1:5, 3, 30) #> [1]  1  2 30  4  5  as.list(body(replace)) #> [[1]] #> `{` #>  #> [[2]] #> x[list] <- values #>  #> [[3]] #> x  trace(replace, tracer = quote(x <- x * 10), at = 3) #> Tracing function \"replace\" in package \"base\" #> [1] \"replace\" class(replace) #> [1] \"functionWithTrace\" #> attr(,\"package\") #> [1] \"methods\"  body(replace) #> { #>     x[list] <- values #>     { #>         .doTrace(x <- x * 10, \"step 3\") #>         x #>     } #> }  replace(1:5, 3, 30) #> Tracing replace(1:5, 3, 30) step 3 #> [1]  10  20 300  40  50 attr(replace, \"original\") #> function (x, list, values)  #> { #>     x[list] <- values #>     x #> } #> <bytecode: 0x00000246b9b6f430> #> <environment: namespace:base> untrace(replace) #> Untracing function \"replace\" in package \"base\"  body(replace) #> { #>     x[list] <- values #>     x #> }  replace(1:5, 3, 30) #> [1]  1  2 30  4  5"},{"path":[]},{"path":"/articles/FAQ.html","id":"functions","dir":"Articles","previous_headings":"What can you ggtrace()?","what":"Functions","title":"Frequently asked questions","text":"{base} functions Imported functions Custom functions","code":"sample(letters, 5) #> [1] \"g\" \"f\" \"n\" \"z\" \"l\" ggtrace(sample, 1, quote(x <- LETTERS), verbose = FALSE) #> `sample` now being traced. sample(letters, 5) #> Triggering trace on `sample` #> Untracing `sample` on exit. #> [1] \"T\" \"F\" \"Y\" \"X\" \"N\" sample(letters, 5) #> [1] \"e\" \"o\" \"g\" \"i\" \"l\" ggtrace(ggplot2::mean_se, 1, quote(cat(\"Running...\\n\")), verbose = FALSE) #> `ggplot2::mean_se` now being traced. ggplot2::mean_se(mtcars$mpg) #> Triggering trace on `ggplot2::mean_se` #> Running... #> Untracing `ggplot2::mean_se` on exit. #>          y    ymin     ymax #> 1 20.09062 19.0252 21.15605 please_return_number <- function() {   result <- runif(1)   result } please_return_number() #> [1] 0.5456977  ggtrace(please_return_number, -1, quote(result <- \"no\"), verbose = FALSE) #> `please_return_number` now being traced. please_return_number() #> Triggering trace on `please_return_number` #> Untracing `please_return_number` on exit. #> [1] \"no\""},{"path":"/articles/FAQ.html","id":"ggproto-methods","dir":"Articles","previous_headings":"What can you ggtrace()?","what":"ggproto methods","title":"Frequently asked questions","text":"Default tracing behavior untracing exit Persistent trace = FALSE explicit untracing gguntrace()","code":"library(ggplot2) boxplot_plot <- ggplot(mpg, aes(drv, hwy)) +   geom_boxplot()  boxplot_plot ggtrace(StatBoxplot$compute_group, -1, verbose = FALSE) #> `StatBoxplot$compute_group` now being traced.  # Plot not printed to save space boxplot_plot #> Triggering trace on `StatBoxplot$compute_group` #> Untracing `StatBoxplot$compute_group` on exit.  last_ggtrace() #> [[1]] #>   ymin lower middle upper ymax outliers notchupper notchlower x width #> 1   12    17     18    22   28            18.77841   17.22159 1  0.75 #>   relvarwidth flipped_aes #> 1    10.14889       FALSE global_ggtrace_state() #> [1] FALSE global_ggtrace_state(TRUE) #> Global tracedump activated. clear_global_ggtrace() #> Global tracedump cleared.  ggtrace(StatBoxplot$compute_group, -1, once = FALSE, verbose = FALSE) #> `StatBoxplot$compute_group` now being traced. #> Creating a persistent trace. Remember to `gguntrace(StatBoxplot$compute_group)`!  # Plot not printed to save space boxplot_plot #> Triggering persistent trace on `StatBoxplot$compute_group` #> Triggering persistent trace on `StatBoxplot$compute_group` #> Triggering persistent trace on `StatBoxplot$compute_group`  gguntrace(StatBoxplot$compute_group) #> `StatBoxplot$compute_group` no longer being traced.  global_ggtrace() #> $`StatBoxplot$compute_group-0x00000246bbf592d8` #> $`StatBoxplot$compute_group-0x00000246bbf592d8`[[1]] #>   ymin lower middle upper ymax outliers notchupper notchlower x width #> 1   12    17     18    22   28            18.77841   17.22159 1  0.75 #>   relvarwidth flipped_aes #> 1    10.14889       FALSE #>  #>  #> $`StatBoxplot$compute_group-0x00000246c1ca76c8` #> $`StatBoxplot$compute_group-0x00000246c1ca76c8`[[1]] #>   ymin lower middle upper ymax                                   outliers #> 1   22    26     28    29   33 17, 21, 34, 36, 36, 35, 37, 35, 44, 44, 41 #>   notchupper notchlower x width relvarwidth flipped_aes #> 1   28.46039   27.53961 2  0.75    10.29563       FALSE #>  #>  #> $`StatBoxplot$compute_group-0x00000246c23f1d40` #> $`StatBoxplot$compute_group-0x00000246c23f1d40`[[1]] #>   ymin lower middle upper ymax outliers notchupper notchlower x width #> 1   15    17     21    24   26              23.212     18.788 3  0.75 #>   relvarwidth flipped_aes #> 1           5       FALSE  global_ggtrace_state(FALSE) #> Global tracedump deactivated."},{"path":"/articles/FAQ.html","id":"s3s4-generics","dir":"Articles","previous_headings":"What can you ggtrace()?","what":"S3/S4 generics","title":"Frequently asked questions","text":"exported generic function ggplot_build() ggplot2 meaningful, unexported method <ggplot> class ggplot_build.ggplot() contains actual data transformation pipeline. can trace ggplot_build() method defined <ggplot> way functions","code":"body(ggplot_build) #> { #>     attach_plot_env(plot$plot_env) #>     UseMethod(\"ggplot_build\") #> }  attr(utils::methods(\"ggplot_build\"), \"info\") #>                     visible                                 from      generic #> ggplot_build.ggplot   FALSE registered S3method for ggplot_build ggplot_build #>                      isS4 #> ggplot_build.ggplot FALSE ggtrace(ggplot2:::ggplot_build.ggplot, -1, verbose = FALSE) #> `ggplot2:::ggplot_build.ggplot` now being traced.  boxplot_plot #> Triggering trace on `ggplot2:::ggplot_build.ggplot` #> Untracing `ggplot2:::ggplot_build.ggplot` on exit. last_ggtrace()[[1]]$data[[1]] #>   ymin lower middle upper ymax                                   outliers #> 1   12    17     18    22   28                                            #> 2   22    26     28    29   33 17, 21, 34, 36, 36, 35, 37, 35, 44, 44, 41 #> 3   15    17     21    24   26                                            #>   notchupper notchlower x flipped_aes PANEL group ymin_final ymax_final  xmin #> 1   18.77841   17.22159 1       FALSE     1     1         12         28 0.625 #> 2   28.46039   27.53961 2       FALSE     1     2         17         44 1.625 #> 3   23.21200   18.78800 3       FALSE     1     3         15         26 2.625 #>    xmax xid newx new_width weight colour  fill alpha shape linetype linewidth #> 1 1.375   1    1      0.75      1 grey20 white    NA    19    solid       0.5 #> 2 2.375   2    2      0.75      1 grey20 white    NA    19    solid       0.5 #> 3 3.375   3    3      0.75      1 grey20 white    NA    19    solid       0.5  identical(last_ggtrace()[[1]]$data[[1]], layer_data(boxplot_plot, 1)) #> [1] TRUE"},{"path":"/articles/FAQ.html","id":"r6-methods","dir":"Articles","previous_headings":"What can you ggtrace()?","what":"R6 methods","title":"Frequently asked questions","text":"Adopted Advanced R Ch. 14.2","code":"library(R6) Accumulator <- R6Class(\"Accumulator\", list(   sum = 0,   add = function(x = 1) {     self$sum <- self$sum + x      invisible(self)   }) ) x <- Accumulator$new() x$add(1) x$sum #> [1] 1 ggtrace(   method = x$add,   trace_steps = c(1, -1),   trace_exprs = list(     before = quote(self$sum),     after = quote(self$sum)   ),   once = FALSE,   verbose = FALSE ) #> `x$add` now being traced. #> Creating a persistent trace. Remember to `gguntrace(x$add)`! x$add(10) #> Triggering persistent trace on `x$add` last_ggtrace() #> $before #> [1] 1 #>  #> $after #> [1] 11 x$add(100) #> Triggering persistent trace on `x$add` last_ggtrace() #> $before #> [1] 11 #>  #> $after #> [1] 111 gguntrace(x$add) #> `x$add` no longer being traced. x$add(1000) x$sum #> [1] 1111"},{"path":"/articles/FAQ.html","id":"what-cant-you-ggtrace","dir":"Articles","previous_headings":"","what":"What can’t you ggtrace()?","title":"Frequently asked questions","text":"Non-functions (ex: constants, object properties). can still inspect values ggbody() Functions defined environment (ex: can’t define function trace --spot inside ggtrace()) Limited support closures (LHS $ must environment function can searched )","code":""},{"path":"/articles/FAQ.html","id":"how-can-i-save-a-modified-ggplot","dir":"Articles","previous_headings":"","what":"How can I save a modified ggplot?","title":"Frequently asked questions","text":"trace internals ggplot, doesn’t directly modify instructions plotting. Instead, changes certain components behave executed. means get different ggplot following code original_plot traced modifications, since original_plot executed . looks like worked first print …  variable modified_pot doesn’t hold modified code generating plot. Instead, just happened trigger trace ggplot_build.ggplot(). next time runs, ’s ran normal behavior original_plot.  capture actual figure generated ggplot, can use ggplotGrob(), returns Graphical object representation plot: get object class <gtable>, can draw device like grob:  can also use ggsave() render <gtable> image: Still, modified_plot graphical representation plot ggplot object can’t keep adding layers . grobs limiting sense. ’s totally limiting like raster image figure. example, patchwork patchwork::wrap_ggplot_grob() allows <gtable> properly aligned ggplots.","code":"original_plot <- ggplot(mtcars, aes(hp, mpg)) + geom_point()  ggtrace(ggplot2:::ggplot_build.ggplot, -1, quote(data[[1]]$colour <- \"red\"), verbose = FALSE) #> `ggplot2:::ggplot_build.ggplot` now being traced.  modified_plot <- original_plot modified_plot #> Triggering trace on `ggplot2:::ggplot_build.ggplot` #> Untracing `ggplot2:::ggplot_build.ggplot` on exit. modified_plot ggtrace(ggplot2:::ggplot_build.ggplot, -1, quote(data[[1]]$colour <- \"red\"), verbose = FALSE) #> `ggplot2:::ggplot_build.ggplot` now being traced.  modified_plot <- ggplotGrob(original_plot) #> Triggering trace on `ggplot2:::ggplot_build.ggplot` #> Untracing `ggplot2:::ggplot_build.ggplot` on exit.  modified_plot #> TableGrob (12 x 9) \"layout\": 18 grobs #>     z         cells       name                                          grob #> 1   0 ( 1-12, 1- 9) background               rect[plot.background..rect.357] #> 2   5 ( 6- 6, 4- 4)     spacer                                zeroGrob[NULL] #> 3   7 ( 7- 7, 4- 4)     axis-l           absoluteGrob[GRID.absoluteGrob.345] #> 4   3 ( 8- 8, 4- 4)     spacer                                zeroGrob[NULL] #> 5   6 ( 6- 6, 5- 5)     axis-t                                zeroGrob[NULL] #> 6   1 ( 7- 7, 5- 5)      panel                      gTree[panel-1.gTree.337] #> 7   9 ( 8- 8, 5- 5)     axis-b           absoluteGrob[GRID.absoluteGrob.341] #> 8   4 ( 6- 6, 6- 6)     spacer                                zeroGrob[NULL] #> 9   8 ( 7- 7, 6- 6)     axis-r                                zeroGrob[NULL] #> 10  2 ( 8- 8, 6- 6)     spacer                                zeroGrob[NULL] #> 11 10 ( 5- 5, 5- 5)     xlab-t                                zeroGrob[NULL] #> 12 11 ( 9- 9, 5- 5)     xlab-b titleGrob[axis.title.x.bottom..titleGrob.348] #> 13 12 ( 7- 7, 3- 3)     ylab-l   titleGrob[axis.title.y.left..titleGrob.351] #> 14 13 ( 7- 7, 7- 7)     ylab-r                                zeroGrob[NULL] #> 15 14 ( 4- 4, 5- 5)   subtitle         zeroGrob[plot.subtitle..zeroGrob.353] #> 16 15 ( 3- 3, 5- 5)      title            zeroGrob[plot.title..zeroGrob.352] #> 17 16 (10-10, 5- 5)    caption          zeroGrob[plot.caption..zeroGrob.355] #> 18 17 ( 2- 2, 2- 2)        tag              zeroGrob[plot.tag..zeroGrob.354] class(modified_plot) #> [1] \"gtable\" \"gTree\"  \"grob\"   \"gDesc\"  library(grid) grid.newpage() grid.draw(modified_plot) # Not ran  ggsave(filename = \"modified_plot.png\", plot = modified_plot, ...) library(patchwork) original_plot_titled <- original_plot + ggtitle(\"original plot\")  # Panels get aligned since `modified_plot` contains info about that original_plot_titled + wrap_ggplot_grob(modified_plot)"},{"path":"/articles/getting-started.html","id":"short-version","dir":"Articles","previous_headings":"","what":"Short version","title":"Getting Started","text":"experienced user wanting fully master grammar ggplot? Start rstudio::conf(2022) talk {ggtrace}! aspiring developer wanting extend ggplot? Start useR! 2022 talk {ggtrace}!","code":""},{"path":"/articles/getting-started.html","id":"long-version","dir":"Articles","previous_headings":"","what":"Long version","title":"Getting Started","text":"’s lot can said ggplot internals, can get using ggtrace depends comfortable ggplot ggplot internals. Whether ’re want become better ggplot user ’re aspiring extension developer, ggtrace covered stages ggplot journey! Traditionally, ggplot community thought split users (people use ggplot make plots) developers (people write extension packages contribute ggplot2). believe binary distinction outdated many reasons, recent one capacity user ever-expanding encroaching “internals” territory. distinction user-facing code ggplot internals clear, doesn’t map neatly onto user-developer dichotomy. one attempt trying address issue. following outlines five “stages” ggplot2 journey, ggtrace fits .","code":""},{"path":"/articles/getting-started.html","id":"stage-1-experienced-user","dir":"Articles","previous_headings":"Long version","what":"Stage 1 (experienced user)","title":"Getting Started","text":"someone comfortable using ggplot heard ggplot internals . wondering ’d even bother learning ggplot internals, see part 1 blog post series delayed aesthetic evaluation, case study set somewhat niche {ggplot2} functions lie intersection user-facing code ggplot internals. might also want start another blog post mine stat_*() layers, extra scaffolding. give practical background ggplot internals, just get started. Hopefully also get excited internals . Learning objectives: Every layer stat geom. stat_*() geom_*() layer functions two sides coin. job users ends ggplot code write. job internals spell assumptions behind concise code write users make figure. layer underlying dataframe representation contains kind information ’s relevant drawing layer. can use ggtrace reference internals snapshots layer’s data declaring complex aesthetic mappings using unconventional stat-geom pairs layer.","code":""},{"path":"/articles/getting-started.html","id":"stage-2-curious-user","dir":"Articles","previous_headings":"Long version","what":"Stage 2 (curious user)","title":"Getting Started","text":"someone recognizes division labor user internals, feel empowered knowledge. continue get better sense internals , recommend watching rstudio::conf(2022) talk {ggtrace} ggplot internals. felt little fast/dense, can watch slower (hour-long), broken version covering content. showcase inspect family workflow functions ggtrace also introduced ggproto. talks cover content Chapter 20.2 ggplot2 book, emphasis practicality user. ’d actually recommend reading entire book chapter anyways (read recording going Part 1 Part 2 chapter), covers many fundamental concepts take time digest. read , also highly recommend referencing Emi Tanaka’s awesome slides ggplot2 internals Bob Rudis’s short chapter demystifying ggplot2 companion guides. Learning objectives: ggplot object ggplot figure . ggplot object merely contains instructions plotting figure. figure get result executing instructions internals, print()/plot()-ing ggplot object. process making figure internals happens steps, first making layer’s data drawing-ready (ggplot_build()) drawing plot (ggplot_gtable()). internals implemented ggproto object oriented system difficult grok, lot just data wrangling. can get pretty far understanding internals using ggtrace just focus part internals takes user-supplied data turns “drawing-ready” data.","code":""},{"path":"/articles/getting-started.html","id":"stage-3-aspiring-developer","dir":"Articles","previous_headings":"Long version","what":"Stage 3 (aspiring developer)","title":"Getting Started","text":"someone aware existence ggproto, interested knowing implementational details internals. can gear deep dive internals first watching Thomas Lin Pedersen’s rstudio::conf(2020) talk extending ggplot, gives nice overview kind ggproto objects methods exist relevant ones / . case want comprehensive documentation ggproto (though necessary read stage), check package vignette ggproto Brodie Gaslam’s even comprehensive unofficial reference ggplot internals. can follow Thomas’s talk watching useR! 2022 talk {ggtrace} ggplot internals, showcases workflows ggtrace (inspect, capture, highjack) interacting ggproto methods. part 2 blog post series delayed aesthetic evaluation picks left talk expand possible extension points different Stat methods. leads nicely case study chapter ggplot2 book. ’s huge chapter, want diversity can also reference Emi’s slides writing ggplot2 extensions ggplot read package vignette extending ggplot side--side, touches topics different examples. process, ’ll inevitably encounter {grid}, scary beast. lot resources {grid}, notably R Graphics (3rd edition) book, also resources written ggplot mind, like yet another one Emi’s slides {grid}, functions interacting ggplot’s gtable graphical objects {lemon} {gridExtra}. Learning objectives: ggproto methods called step--step internals execute instructions plotting. ggproto objects Stat Geom lof work, offer powerful extension points. ggprotos mostly stateless ggproto methods essentially functions, though defy common expectations function look like behave. ggtrace allows interact ggproto methods stand-alone functions, can learn behavior trial error.","code":""},{"path":"/articles/getting-started.html","id":"stage-4-developer","dir":"Articles","previous_headings":"Long version","what":"Stage 4 (developer)","title":"Getting Started","text":"understand role ggproto objects methods play internals excited writing extensions. point now developer - training wheels ’re territory figuring things . developer requires new skill - debugging. people written topic debugging ggplot internals, including Hiroaki Yutani’s blog post using browser() debugging ggproto methods Dewey Dunnington’s {ggdebug} package gives freakishly powerful control internals. People also written packages less “intrusive” ways debugging interacting internals, including {gginnards} Pedro J. Aphalo {gggrid} Paul Murrell. Standing shoulders giants, ggtrace aims offer best worlds developers, high-level workflow functions form ggtrace_{action}_{value}(), low-level functions ggtrace() with_ggtrace(), interactive debugging functions ggedit() ggdebugonce(). ’s whole lot new stuff ggtrace offers space (package isn’t even much code) embodies transformative reframing ggplot internals functional programming, kind ’re familiar R users. treating ggproto methods like functions, can leverage existing debugging skills understanding extending ggplot internals. Learning objectives: small subset ggprotos exported ggplot2 available subclassing, handful ggproto methods productive extension points. big part developing extension locating appropriate extension point. ggtrace allows developers work backwards getting desired output work first, identifying implementational details need changed produce output. words, can find hack works first trial error, develop principled way implementing solution following best practices extending ggplot. process writing new ggproto objects ggproto methods, developers need debug frequently. ggtrace functions implement different strategies debugging, spanning spectrum interactive programmatic.","code":""},{"path":"/articles/getting-started.html","id":"stage-5-contributor","dir":"Articles","previous_headings":"Long version","what":"Stage 5 (contributor)","title":"Getting Started","text":"Lastly, ggplot2 always evolving, can take part process! might obvious users, internals undergoing constant change. point might also want start keeping eye Github issues. ’s also nice place can eavesdrop thoughts insights core developers (e.g., users able specify pieces scale_*() modularly?, guides system converted ggproto?, layers get “state”?), can help understand motivation behind things internals designed way. reading discussions inspire new ideas strong feelings, can submit issue PR make voice heard.","code":""},{"path":"/articles/intro.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to ggtrace()","text":"Slides useR! 2022 June 22th 2022: https://yjunechoe.github.io/ggtrace-user2022","code":"library(ggtrace)"},{"path":"/articles/overview.html","id":"extending-basetrace-with-ggtrace","dir":"Articles","previous_headings":"","what":"Extending base::trace() with ggtrace()","title":"Overview","text":"low-level function ggtrace() designed interacting functions ggproto methods ggplot2 ecosystem, “outside”. Formally put, ggtrace() allows user inject arbitrary expressions (called traces) functions methods evaluated execution ggplot. “triggered” evaluation ggplot, traces may modify resulting graphical output, may simply log values “tracedump” inspection user. Check FAQ vignette details. Briefly, three key arguments ggtrace(): method: function/method trace trace_steps: body inject expressions trace_exprs expressions inject simple example: following code injects code z <- z * 10 right dummy_fn enters third “step” body, right line return(z) ran. Note value trace_exprs must type “language” (quoted expression), idea injecting code evaluate inside function called. Often, providing code wrapped quote() suffices. complex injections see Expressions chapter Advanced R ggtrace() call, next time dummy_fn called run injected code. Essentially, dummy_fn ran following modified code just now: default, traces created ggtrace functions delete triggered. can also check whether function currently traced is_traced(). ggtrace automatically logs output triggered trace call tracedumps. example, last_ggtrace() stores output last trace created ggtrace(): See references section Extending base::trace() functionalities offered ggtrace().","code":"dummy_fn <- function(x = 1, y = 2) {   z <- x + y   return(z) } dummy_fn() ## [1] 3 body(dummy_fn)[[3]] ## return(z) ggtrace(   method = dummy_fn,   trace_steps = 3L, # Before `return(z)` is ran   trace_exprs = quote(z <- z * 10) ) ## `dummy_fn` now being traced. # Returns 30 instead of 3 dummy_fn() ## Triggering trace on `dummy_fn` ## Untracing `dummy_fn` on exit. ## [1] 30 dummy_fn_traced <- function(x = 1, y = 2) {   z <- x + y   z <- z * 10 #< injected code!   return(z) } dummy_fn_traced() ## [1] 30 is_traced(dummy_fn) ## [1] FALSE # The value of `(z <- z * 10)` when it was ran last_ggtrace() # Note that this is a list of length `trace_steps` ## [[1]] ## [1] 30"},{"path":"/articles/overview.html","id":"workflows-for-interacting-with-ggplot-internals","dir":"Articles","previous_headings":"","what":"Workflows for interacting with ggplot internals","title":"Overview","text":"Admittedly, ggtrace() bit clunky interactive explorations ggplot internals. address , offer “workflow” functions form ggtrace_{action}_{value}(). grouped three workflows: Inspect, Capture, Highjack. NOTE: Making workflow functions requires hint knowledge ggplot internals, namely fact ggproto objects like Stat Geom exists, ggprotos methods step different parts ggplot build/render pipeline modify data. completely new concepts, least watch Thomas Lin Pedersen’s talk Extending ability extend ggplot2 proceeding.","code":"library(ggplot2) # v3.3.5"},{"path":"/articles/overview.html","id":"walkthrough-with-geom_smooth","dir":"Articles","previous_headings":"Workflows for interacting with ggplot internals","what":"Walkthrough with geom_smooth()","title":"Overview","text":"Say want learn geom_smooth() layer works, exactly , ’re going adopt example ggplot2 internals chapter ggplot book  Let’s focus Stat ggproto. see geom_smooth() uses StatSmooth ggproto bulk work Stat done compute_* family methods, essentially just functions. ’ll focus compute_group :","code":"geom_smooth() ## geom_smooth: na.rm = FALSE, orientation = NA, se = TRUE ## stat_smooth: na.rm = FALSE, orientation = NA, se = TRUE ## position_identity p <- ggplot(mpg, aes(displ, hwy, color = drv)) +    geom_point(position = position_jitter(seed = 1116)) +   geom_smooth(method = \"lm\", formula = y ~ x) +    facet_wrap(vars(year)) +    ggtitle(\"A plot for expository purposes\") p class( geom_smooth()$stat ) ## [1] \"StatSmooth\" \"Stat\"       \"ggproto\"    \"gg\" identical(StatSmooth, geom_smooth()$stat) ## [1] TRUE # ggproto methods wrap over the actual function and print extra info class( StatSmooth$compute_group ) ## [1] \"ggproto_method\" # Use `get_method` to pull out just the function component class( get_method(StatSmooth$compute_group) ) ## [1] \"function\" # StatSmooth inherits `compute_layer`/`compute_panel` and defines `compute_group` get_method_inheritance(StatSmooth) ## $Stat ##  [1] \"aesthetics\"      \"compute_layer\"   \"compute_panel\"   \"default_aes\"     ##  [5] \"finish_layer\"    \"non_missing_aes\" \"optional_aes\"    \"parameters\"      ##  [9] \"retransform\"     \"setup_data\"      ##  ## $StatSmooth ## [1] \"compute_group\" \"dropped_aes\"   \"extra_params\"  \"required_aes\"  ## [5] \"setup_params\""},{"path":"/articles/overview.html","id":"inspect","dir":"Articles","previous_headings":"Workflows for interacting with ggplot internals","what":"Inspect","title":"Overview","text":"introduce first workflow function ggtrace_inspect_n(), takes ggplot first argument ggproto method second argument, returning number times ggproto method called ggplot’s evaluation: might guessed, StatSmooth$compute_group called fitted line (group) plot. StatSmooth$compute_group essentially function, return? can answer another workflow function ggtrace_inspect_return(), shares similar syntax: Note ggtrace_inspect_return() gave us 1 dataframe, corresponding return value StatSmooth$compute_group first time called. comes default value third argument cond set quote(._counter_ == 1). , ._counter_ internal variable keeps track many times method called. ’s available workflow functions can read Tracing context section docs. instead wanted get return value StatSmooth$compute_group third group second panel, example, can one two ways: Set value cond expression evaluates true panel group: Find counter value condition satisfied ggtrace_inspect_which(), simply check value ._counter_ back ggtrace_inspect_return(): two approaches work :","code":"ggtrace_inspect_n(x = p, method = StatSmooth$compute_group) ## [1] 6 return_val <- ggtrace_inspect_return(x = p, method = StatSmooth$compute_group)  dim(return_val) ## [1] 80  6 head(return_val) ##          x        y     ymin     ymax        se flipped_aes ## 1 1.800000 24.33592 23.07845 25.59339 0.6250675       FALSE ## 2 1.859494 24.17860 22.94830 25.40890 0.6115600       FALSE ## 3 1.918987 24.02127 22.81795 25.22460 0.5981528       FALSE ## 4 1.978481 23.86395 22.68738 25.04052 0.5848527       FALSE ## 5 2.037975 23.70663 22.55658 24.85668 0.5716673       FALSE ## 6 2.097468 23.54931 22.42554 24.67307 0.5586045       FALSE return_val_2_3_A <- ggtrace_inspect_return(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$PANEL[1] == 2 && data$group[1] == 3) ) ggtrace_inspect_which(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$PANEL[1] == 2 && data$group[1] == 3) ) ## [1] 6 return_val_2_3_B <- ggtrace_inspect_return(   x = p,   method = StatSmooth$compute_group,   cond = 6L # shorthand for `quote(._counter_ == 6L)` ) identical(return_val_2_3_A, return_val_2_3_B) ## [1] TRUE"},{"path":"/articles/overview.html","id":"capture","dir":"Articles","previous_headings":"Workflows for interacting with ggplot internals","what":"Capture","title":"Overview","text":"Okay, know StatSmooth$compute_group returns, return value change different input? generally put, StatSmooth$compute_group behave different contexts? answer making bunch different plots using geom_smooth() repeating inspection workflow. Alternatively, can capture call StatSmooth$compute_group extract function ggtrace_capture_fn(): captured_fn_2_3 essentially snapshot compute_group called third group second panel. Simply calling captured_fn_2_3 gives us expected return value: true power “capture” workflow functions lies ability interact captured. case ggtrace_capture_fn(), returned function arguments passed execution stored formals. words, “pre-filled” original values, can inspect formals(): makes convenient us explore behavior different arguments passed . example, flipped_aes = TRUE, get xmin xmax columns replacing ymin ymax: sense, can effectively simulate happens geom_smooth(orientation = \"y\") without needing construct entirely different ggplot. another example, set confidence interval 10% level = 0.1, ymin ymax values deviate less y value: Lastly, let’s talk data variable ’ve using inside cond argument workflow functions. data$group data$PANEL? know data looks like? answer actually simple: ’s argument passed StatSmooth$compute_group. saw earlier ’s stored formals(captured_fn_2_3), target explicitly can also use ggtrace_inspect_args(): see PANEL group columns conveniently give us information panel group compute_group calculations .","code":"captured_fn_2_3 <- ggtrace_capture_fn(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$PANEL[1] == 2 && data$group[1] == 3) ) identical(return_val_2_3_A, captured_fn_2_3()) ## [1] TRUE # Just showing their type/class for space sapply( formals(captured_fn_2_3) , class) ##         data       scales       method      formula           se  ## \"data.frame\"       \"list\"  \"character\"    \"formula\"    \"logical\"  ##            n         span    fullrange         xseq        level  ##    \"numeric\"    \"numeric\"    \"logical\"       \"NULL\"    \"numeric\"  ##  method.args        na.rm  flipped_aes  ##       \"list\"    \"logical\"    \"logical\" head( captured_fn_2_3(flipped_aes = TRUE) ) ##          y        x     xmin     xmax        se flipped_aes ## 1 15.00000 5.450710 4.369619 6.531802 0.4961840        TRUE ## 2 15.13924 5.448163 4.385577 6.510749 0.4876904        TRUE ## 3 15.27848 5.445616 4.401438 6.489794 0.4792416        TRUE ## 4 15.41772 5.443068 4.417196 6.468941 0.4708400        TRUE ## 5 15.55696 5.440521 4.432846 6.448196 0.4624882        TRUE ## 6 15.69620 5.437974 4.448381 6.427566 0.4541888        TRUE head( captured_fn_2_3(level = 0.1) ) ##          x        y     ymin     ymax       se flipped_aes ## 1 4.000000 21.70513 21.46539 21.94487 1.867921       FALSE ## 2 4.037975 21.69321 21.45840 21.92801 1.829458       FALSE ## 3 4.075949 21.68128 21.45137 21.91119 1.791313       FALSE ## 4 4.113924 21.66936 21.44430 21.89442 1.753509       FALSE ## 5 4.151899 21.65743 21.43718 21.87769 1.716067       FALSE ## 6 4.189873 21.64551 21.43001 21.86101 1.679011       FALSE args_2_3 <- ggtrace_inspect_args(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$PANEL[1] == 2 && data$group[1] == 3) )  identical(names(args_2_3), names(formals(captured_fn_2_3))) ## [1] TRUE args_2_3$data ##      x  y colour PANEL group ## 10 5.3 20      r     2     3 ## 11 5.3 15      r     2     3 ## 12 5.3 20      r     2     3 ## 13 6.0 17      r     2     3 ## 14 6.2 26      r     2     3 ## 15 6.2 25      r     2     3 ## 16 7.0 24      r     2     3 ## 43 5.4 18      r     2     3 ## 48 4.0 26      r     2     3 ## 49 4.0 24      r     2     3 ## 50 4.6 23      r     2     3 ## 51 4.6 22      r     2     3 ## 52 5.4 20      r     2     3 ## 73 5.4 18      r     2     3"},{"path":"/articles/overview.html","id":"highjack","dir":"Articles","previous_headings":"Workflows for interacting with ggplot internals","what":"Highjack","title":"Overview","text":"understanding StatSmooth$compute_group works, may want test hypotheses happen resulting graphical output method returned something else. Let’s revisit examples Capture workflow. third group second panel calculated conservative confidence interval (level = 0.1)? effect graphical output? answer question, use ggtrace_highjack_return() method return entirely different value. First store modified return value variable: target group inside cond pass modified_return_smooth value argument:  confidence band now nearly invisible fitted line ’s capturing 10% confidence interval! ’s another example make method fit predictions loess regression instead. achieve directly, use ggtrace_highjack_args() set values list(method = \"loess\"):  Lastly, ggtrace_highjack_return() exposes internal function called returnValue() value argument, simply returns original return value. Passing value argument expression computing returnValue() allows --fly modifications graphical output. example, can “intercept” dataframe output ggproto method, data wrangling , method return new dataframe instead. , hack data group make look like ’s absurd degree heteroskedasticity:","code":"modified_return_smooth <- captured_fn_2_3(level = 0.1) ggtrace_highjack_return(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$PANEL[1] == 2 && data$group[1] == 3),   value = modified_return_smooth ) ggtrace_highjack_args(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$PANEL[1] == 2 && data$group[1] == 3),   values = list(method = \"loess\") ) library(dplyr) # v1.0.8  ggtrace_highjack_return(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$PANEL[1] == 2 && data$group[1] == 3),   value = quote({          returnValue() %>%        mutate(         ymin = y - se * seq(0, 10, length.out = n()),         ymax = y + se * seq(0, 10, length.out = n())       )        }) )"},{"path":"/articles/overview.html","id":"middle-ground-approach-with_ggtrace","dir":"Articles","previous_headings":"","what":"Middle-ground approach with_ggtrace()","title":"Overview","text":"far ’ve seen low-level function ggtrace() high-level family workflow functions ggtrace_{action}_{value}(). get familiar ggplot internals start using ggtrace() “hack ” internals (moving learner developer, sense), might want exploit power convenience ggtrace provides across two designs. provide with_ggtrace(), wraps around ggtrace() give access full power, keeping effects localized (e.g., side-effects) therefore making fitting functional programming workflow. Like ggtrace(), can inject code different steps method runs:  like workflow functions, can conditional traces evaluate condition met, using statements inside trace_exprs = FALSE.  course, limited objects ggplot2 package . can fun hacking extension packages well!","code":"with_ggtrace(   x = p + facet_grid(year ~ drv),   method = Layout$render,   trace_steps = c(5L, 8L),   trace_exprs = rlang::exprs(          {       # First, turn all panels except the 4th semi-transparent       panels[-4] <- lapply(panels[-4], function(panel) {         editGrob(panel, gp = gpar(alpha = .4))       })       # Second, give red outline and fill to 4th panel       panels[[4]] <- gTree(children = gList(panels[[4]],         rectGrob(x = 0.5, y = 0.5, width = 1, height = 1,                  gp = gpar(col = \"red\", lwd = 5, fill = \"red\", alpha = 0.1))       ))     },          {       # Third, give it some emphasis by connecting to facet strips       outline_rect <- rectGrob(         x = 0.5, y = 0.5, width = 1, height = 1,         gp = gpar(col = \"red\", lwd = 2, fill = NA)       )       plot_table <- gtable_add_grob(         plot_table, outline_rect,         t = 1, l = 2, b = 5, r = 2, z = Inf       )       plot_table <- gtable_add_grob(         plot_table, outline_rect,         t = 5, l = 2, b = 5, r = 7, z = Inf       )     }        ),   out = \"g\" ) with_ggtrace(   p,   GeomRibbon$draw_group,   trace_steps = -1L,   trace_exprs = quote({     # Give gradient fill to the confidence bands for third group     if (data$group[1] == 3) {       g_poly <- editGrob(         g_poly,         gp = gpar(fill = linearGradient(           colours = c(\"purple\", \"skyblue\", \"pink\"),           stops = c(0, 0.5, 1),           x1 = 0, x2 = 1, y1 = 0, y2 = 0         ))       )     }   }),   once = FALSE, # to test `if` for all calls to method   out = \"g\" ) library(ggh4x) # v0.2.1  # Example from - https://teunbrand.github.io/ggh4x/articles/Facets.html ----  ## Base plot ==== p <- ggplot(mpg, aes(displ, hwy, colour = as.factor(cyl))) + geom_point() +   labs(x = \"Engine displacement\", y = \"Highway miles per gallon\") +   guides(colour = \"none\")  ## Fixed-aspect plot w/ independent scales using `ggh4x::facet_grid2()` ==== p2 <- p +   ggh4x::facet_grid2(vars(year), vars(drv), scales = \"free\", independent = \"all\") +   theme_grey(base_size = 9) +   theme(aspect.ratio = 1)  # Highjacking the plot's execution using `ggtrace::with_ggtrace()` ---- with_ggtrace(      ## Argument 1: The ggplot to interact with durings its execution ====   x = p2,      ## Argument 2: The method to inject code into ====   method = ggh4x::FacetGrid2$draw_panels,      ## Argument 3: The step in the method right before `panels` and `axes` ====   ## are merged into the `panel_table` <gtable> and shipped off   trace_steps = 13, # See `ggbody(FacetGrid2$draw_panels)`      ## Argument 4: The code injection to rotate the 2nd panel ====   trace_exprs = quote({          ### FIRST, specify row/column of panel to target ####     row <- 1     col <- 2     target_panel <- layout[layout$ROW == row & layout$COL == col, ]$PANEL     left_axis    <- axes$left[[row, col]]     bottom_axis  <- axes$bottom[[row, col]]          ### SECOND, replace target panel with a version of itself ####     ### that has axes attached to it, using `grid::gTree()`     panels[[target_panel]] <- gTree(              ##### Argument `children`: a list (`grid::gList()`) of three grobs:       children = gList(                  ###### 1. The original panel itself         panels[[target_panel]],                  ###### 2. Resized/repositioned left y-axis for that panel         editGrob(           left_axis,           vp = viewport(             x = unit(0.5, \"npc\") - grobWidth(left_axis) / 2,             just = c(\"right\")           )         ),                  ###### 3. Resized/repositioned bottom x-axis for that panel         editGrob(           bottom_axis,           vp = viewport(             y = unit(0.5, \"npc\") - grobHeight(bottom_axis) / 2,             just = c(\"top\")           )         )                ),              ##### Argument `vp`: Rotation for this combination of three grobs       vp = viewport(width = .7, height = .7, angle = 45)            )          ### THIRD, \"remove\" the original axes for that panel ####     axes$left[[row, col]]    <- zeroGrob()      axes$bottom[[row, col]]  <- zeroGrob()        }),      ## Argument `out`: The return value for `with_ggtrace()` ====   ## \"gtable\" returns the graphical output after injecting the code   out = \"gtable\" # you can also use the \"g\" shorthand    )"},{"path":"/articles/overview.html","id":"case-study-data-driven-legends","dir":"Articles","previous_headings":"","what":"Case study: Data-driven legends","title":"Overview","text":"Suppose want change fill legend key squares actual violins drawn category:  know violin drawn GeomViolin$draw_group, called group plot. Let’s grab plotted violins ggtrace_inspect_return() , can use ggtrace_highjack_return() highjack return value key drawing method GeomViolin$draw_key returns output draw_group method instead. set cond = 1:2 value = substitute(violins[[._counter_]]) draw_key method returns first violin first legend key, second violin second legend key.  Note violins legend drawn respect panel coordinate system, ’s draw_group method things. cleaner look, use defined function center_and_resize() modifies violin grob using grid::editGrob() passing ggtrace_highjack_return().  keep effect keeping violin_plot ggplot object, can create custom key glyph function inspects fill color original legend keys returns corresponding violin. Note difference output two methods. highjack workflow functions offer convenient way modifying ggplot, forces conversion ggplot object grob.  lesson highjack workflow ({ggtrace} package, broadly) means, end. Users encouraged generalize solutions beyond one-hacks using toolkit workflow functions determine appropriate point extension.","code":"violin_plot <- dplyr::starwars %>%    filter(species == \"Human\", !is.na(height)) %>%    ggplot(aes(gender, height)) +   geom_violin(aes(fill = gender)) +   theme(     aspect.ratio = 1,     legend.key.size = unit(1, \"in\"),     legend.key = element_rect(color = \"grey\", fill = NA)   )  violin_plot ggtrace_inspect_n(violin_plot, GeomViolin$draw_group) ## [1] 2 violins <- lapply(1:2, ggtrace_inspect_return,                   x = violin_plot, method = GeomViolin$draw_group) violins ## [[1]] ## polygon[geom_violin.polygon.2816]  ##  ## [[2]] ## polygon[geom_violin.polygon.2880] ggtrace_highjack_return(   violin_plot,   GeomViolin$draw_key,   cond = 1:2, # or `cond = TRUE` since method is called twice total   value = substitute(violins[[._counter_]]) ) library(grid) center_and_resize <- function(grob) {   x_range <- range(unclass(grob$x))   y_range <- range(unclass(grob$y))   width <- diff(x_range)   height <- diff(y_range)   resizing <- (1 - 0.2)/max(width, height)   editGrob(grob, vp = viewport(     xscale = x_range, yscale = y_range,     width = width * resizing, height = height * resizing   )) } violins_centered_resized <- lapply(violins, center_and_resize)  violin_plot_highjacked <- ggtrace_highjack_return(   violin_plot,   GeomViolin$draw_key,   cond = 1:2,   value = substitute(violins_centered_resized[[._counter_]]) ) violin_plot_highjacked names(violins_centered_resized) <- c(\"#F8766D\", \"#00BFC4\")  violin_plot_keyglyph <- dplyr::starwars %>%    filter(species == \"Human\", !is.na(height)) %>%    ggplot(aes(gender, height)) +   geom_violin(     aes(fill = gender),     key_glyph = function(data, params, size) {   #<       violins_centered_resized[[data$fill]]      #<  Custom `key_glyph` function     }                                            #<   ) +   theme(     aspect.ratio = 1,     legend.key.size = unit(1, \"in\"),     legend.key = element_rect(color = \"grey\", fill = NA)   ) class(violin_plot_highjacked) ## [1] \"ggtrace_highjacked\" \"gtable\"             \"gTree\"              ## [4] \"grob\"               \"gDesc\" violin_plot_highjacked +   labs(title = \"Violin plot with data-driven legend key glyphs\") ## Error in violin_plot_highjacked + labs(title = \"Violin plot with data-driven legend key glyphs\"): non-numeric argument to binary operator class(violin_plot_keyglyph) ## [1] \"gg\"     \"ggplot\" violin_plot_keyglyph +   labs(title = \"Violin plot with data-driven legend key glyphs\")"},{"path":"/articles/showcase-aes_evaluation.html","id":"under-construction","dir":"Articles","previous_headings":"","what":"Under construction","title":"Showcase: aes evaluation","text":"","code":"library(ggtrace) library(ggplot2)"},{"path":"/articles/showcase-aes_evaluation.html","id":"sneak-peak","dir":"Articles","previous_headings":"Under construction","what":"Sneak peak:","title":"Showcase: aes evaluation","text":"Read draft!","code":""},{"path":"/articles/showcase-ggplot_build.html","id":"under-construction","dir":"Articles","previous_headings":"","what":"Under construction","title":"Showcase: ggplot build","text":"","code":"library(ggtrace) library(ggplot2)"},{"path":"/articles/showcase-ggplot_build.html","id":"sneak-peak","dir":"Articles","previous_headings":"Under construction","what":"Sneak peak:","title":"Showcase: ggplot build","text":"Read draft!","code":""},{"path":[]},{"path":"/articles/technical-details.html","id":"sneak-peak","dir":"Articles","previous_headings":"Under construction","what":"Sneak peak:","title":"Technical details","text":"quick trace (tracer, , edit) ’s best debugging tool ever Getting arbitrary expressions evaluated inside tracer ggtrace works","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"June Choe. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Choe J (2023). ggtrace: Programmatically explore, debug, manipulate ggplot internals. https://yjunechoe.github.io/ggtrace, https://github.com/yjunechoe/ggtrace.","code":"@Manual{,   title = {ggtrace: Programmatically explore, debug, and manipulate ggplot internals},   author = {June Choe},   year = {2023},   note = {https://yjunechoe.github.io/ggtrace, https://github.com/yjunechoe/ggtrace}, }"},{"path":[]},{"path":[]},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"ggtrace","text":"can install development version GitHub : 📦 package website: https://yjunechoe.github.io/ggtrace","code":"# install.packages(\"remotes\") remotes::install_github(\"yjunechoe/ggtrace\")  library(ggtrace)"},{"path":"/index.html","id":"description","dir":"","previous_headings":"","what":"Description","title":"ggtrace","text":"ggtrace embodies opinionated approach learning ggplot internals. internals difficult topic, recommend watching following presentations ggtrace getting started kind code: Presentation rstudio::conf(2022) Presentation useR! 2022 Read philosophy behind ggtrace Getting Started vignette, see examples Overview vignette. ggtrace now also paper! Sub-layer modularity Grammar Graphics","code":""},{"path":"/index.html","id":"example-usage","dir":"","previous_headings":"","what":"Example usage","title":"ggtrace","text":"","code":"library(ggplot2) packageVersion(\"ggplot2\") #> [1] '3.4.1'"},{"path":"/index.html","id":"id_1-inspect-sub-layer-data","dir":"","previous_headings":"Example usage","what":"1) Inspect sub-layer data","title":"ggtrace","text":"bar plot counts geom_bar() stat = \"count\" default: State bar layer’s data statistical transformation step: can map aesthetics variables -stat data using after_stat():  idea after_scale():","code":"bar_plot <- ggplot(mpg, aes(class, fill = class)) +   geom_bar() +   theme(legend.position = \"none\") ggtrace::layer_after_stat(bar_plot) #> ✔ Executed `ggtrace_inspect_return(bar_plot, ggplot2:::Layer$compute_statistic)` #> # A tibble: 7 × 8 #>   count  prop x          width flipped_aes fill       PANEL group #>   <dbl> <dbl> <mppd_dsc> <dbl> <lgl>       <chr>      <fct> <int> #> 1     5     1 1            0.9 FALSE       2seater    1         1 #> 2    47     1 2            0.9 FALSE       compact    1         2 #> 3    41     1 3            0.9 FALSE       midsize    1         3 #> 4    11     1 4            0.9 FALSE       minivan    1         4 #> 5    33     1 5            0.9 FALSE       pickup     1         5 #> 6    35     1 6            0.9 FALSE       subcompact 1         6 #> 7    62     1 7            0.9 FALSE       suv        1         7 bar_plot +   geom_text(     aes(label = after_stat(count)),     stat = \"count\",     position = position_nudge(y = 1), vjust = 0   ) scatter_plot <- ggplot(mpg, aes(displ, hwy, fill = class)) +   scale_fill_viridis_d(option = \"magma\") scatter_plot +   geom_point(shape = 21, size = 4, stroke = 1) # `fill` column available for `after_scale(fill)` ggtrace::layer_after_scale(scatter_plot) #> ✔ Executed `ggtrace_inspect_return(scatter_plot, ggplot2:::Layer$compute_geom_2)` #> # A tibble: 234 × 5 #>    fill          x     y PANEL group #>    <chr>     <dbl> <dbl> <fct> <int> #>  1 #2D1160FF   1.8    29 1         2 #>  2 #2D1160FF   1.8    29 1         2 #>  3 #2D1160FF   2      31 1         2 #>  4 #2D1160FF   2      30 1         2 #>  5 #2D1160FF   2.8    26 1         2 #>  6 #2D1160FF   2.8    26 1         2 #>  7 #2D1160FF   3.1    27 1         2 #>  8 #2D1160FF   1.8    26 1         2 #>  9 #2D1160FF   1.8    25 1         2 #> 10 #2D1160FF   2      28 1         2 #> # … with 224 more rows  scatter_plot +   geom_point(     aes(color = after_scale(prismatic::best_contrast(fill))),     shape = 21, size = 4, stroke = 1   )"},{"path":"/index.html","id":"id_2-highjack-ggproto-remove-boxplot-outliers","dir":"","previous_headings":"Example usage","what":"2) Highjack ggproto (remove boxplot outliers)","title":"ggtrace","text":"can hide outliers geom_boxplot(), ’ll still layer’s underlying dataframe representation. makes plot look stretched:  scales re-trained calculation boxplot statistics. words, “final” min/max value x-scale derived calculated outliers, even ’re drawn. One solution highjack calculation boxplot layer’s statistics values outliers column set NULL. ggtrace_highjack_return(), pass expression modifies returnValue() value argument, evaluates value returned method.  Problem inspired https://github.com/tidyverse/ggplot2/issues/4892. Note also possible “vanilla” ggplot. Following earlier discussion after_stat():","code":"boxplot_plot <- ggplot(mpg, aes(hwy, class)) +   geom_boxplot(outlier.shape = NA) boxplot_plot layer_data(boxplot_plot)[, c(\"xmin\", \"xmax\", \"outliers\", \"xmin_final\", \"xmax_final\")] #>   xmin xmax                       outliers xmin_final xmax_final #> 1   23   26                                        23         26 #> 2   23   33                 35, 37, 35, 44         23         44 #> 3   23   32                                        23         32 #> 4   21   24                             17         17         24 #> 5   15   20                 12, 12, 12, 22         12         22 #> 6   20   36                         44, 41         20         44 #> 7   14   22 12, 12, 25, 24, 27, 25, 26, 23         12         27 ggtrace_highjack_return(   x = boxplot_plot,   method = Stat$compute_layer,   cond = 1L,   value = quote({     transform(returnValue(), outliers = NULL)   }) ) # Suppress warning from mapping to `outliers` aesthetic update_geom_defaults(\"boxplot\", list(outliers = NULL))  ggplot(mpg, aes(hwy, class)) +   geom_boxplot(     # Equivalent effect of modifying the after-stat data     aes(outliers = after_stat(list(NULL)))   )"},{"path":"/index.html","id":"id_3-not-just-ggproto","dir":"","previous_headings":"Example usage","what":"3) Not just ggproto","title":"ggtrace","text":"method argument ggtrace_*() workflow functions can (almost) function-like object called rendering ggplot.","code":"set.seed(2023) # Example from `?stat_summary` summary_plot <- ggplot(mtcars, aes(mpg, factor(cyl))) +   geom_point() +   stat_summary(fun.data = \"mean_cl_boot\", colour = \"red\", linewidth = 2, size = 3) summary_plot ggtrace_inspect_args(x = summary_plot, method = mean_cl_boot) #> $x #>  [1] 22.8 24.4 22.8 32.4 30.4 33.9 21.5 27.3 26.0 30.4 21.4 ggtrace_inspect_return(x = summary_plot, method = mean_cl_boot) #>          y     ymin     ymax #> 1 26.66364 24.11727 29.19159  ggtrace_highjack_return(   x = summary_plot, method = mean_cl_boot,   value = quote({     data.frame(y = 50, ymin = 25, ymax = 75)   }) )"},{"path":"/index.html","id":"id_4-visually-crop-polar-coordinate-plots","dir":"","previous_headings":"Example usage","what":"4) Visually crop polar coordinate plots","title":"ggtrace","text":"’s plot polar coordinates:  can clip plot panel highjacking Layout$render() method using generic workflow function with_ggtrace():  Inspired twitter thread. See implementation MSBMisc::crop_coord_polar().","code":"polar_plot <- ggplot(mtcars, aes(hp, mpg)) +   geom_point() +   geom_smooth(method = \"lm\", formula = y ~ x) +   expand_limits(y = c(0, 60)) +   coord_polar(start = 0, theta = \"y\")  polar_plot with_ggtrace(   x = polar_plot + theme(aspect.ratio = 1/.48),   method = Layout$render,   trace_steps = 5L,   trace_expr = quote({     panels[[1]] <- editGrob(panels[[1]], vp = viewport(xscale = c(.48, 1)))   }),   out = \"g\" )"},{"path":"/index.html","id":"id_5-highjack-the-drawing-context","dir":"","previous_headings":"Example usage","what":"5) Highjack the drawing context","title":"ggtrace","text":"Flashy example adopted UseR! talk:   Note use special variable ._counter_, increments every time function/method called. See reference section tracing context details.","code":"library(palmerpenguins) flashy_plot <- na.omit(palmerpenguins::penguins) |>    ggplot(aes(x = species, y = flipper_length_mm)) +   geom_boxplot(aes(fill = species), width = .7) +   facet_wrap(~ year) flashy_plot ggtrace_highjack_return(   flashy_plot, Geom$draw_panel, cond = TRUE,   value = quote({     circ <- circleGrob(y = .25 * ._counter_)     grobTree( editGrob(circ, gp = gpar(fill = linearGradient())),               editGrob(returnValue(), vp = viewport(clip = circ)) )   }))"},{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2021 June Choe Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/reference/get_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Get information about ggproto methods — get_method","title":"Get information about ggproto methods — get_method","text":"Get information ggproto methods","code":""},{"path":"/reference/get_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get information about ggproto methods — get_method","text":"","code":"get_method(method, inherit = FALSE)  get_method_inheritance(obj, trim_overriden = TRUE)  ggbody(method, inherit = FALSE, as.list = TRUE)  ggformals(method, inherit = FALSE)"},{"path":"/reference/get_method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get information about ggproto methods — get_method","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method inherit Whether method searched closest parent. Defaults FALSE. TRUE, returns parent's method corresponding ggbody() code message. obj ggproto object trim_overriden Whether get_method_inheritance recursively hide methods defined parent. .list Whether ggbody() return body method list. Defaults TRUE.","code":""},{"path":"/reference/get_method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get information about ggproto methods — get_method","text":"list","code":""},{"path":"/reference/get_method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get information about ggproto methods — get_method","text":"get_method() returns method. get_method_inheritance() lists available methods self parent ggprotos. ggbody() returns body method. ggformals() returns formals method.","code":""},{"path":"/reference/get_method.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Get information about ggproto methods — get_method","text":"get_method() calls get(\"method\", ggproto) hood. get(\"method\", ggproto) syntax long form ggproto$method retrieves actual function body. subtle important difference inspecting ggproto methods. example, works: debugonce(get(\"compute_group\", StatCount)) fails insert break point: debugonce(StatCount$compute_group) get_method() designed worry distinction.","code":""},{"path":"/reference/get_method.html","id":"gotchas","dir":"Reference","previous_headings":"","what":"Gotchas","title":"Get information about ggproto methods — get_method","text":"method traced via ggtrace() ggedit(), get_method() return current modified state method. v0.3.5, calling get_method() method trace return warning emphasize fact. using inherit = TRUE, make sure ggproto objects class(ggproto) available (loading packages defined, example). hood, get_method() loops parents search method, needs able evaluate element class(ggproto) object.","code":""},{"path":"/reference/get_method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get information about ggproto methods — get_method","text":"","code":"library(ggplot2)  # Uninformative StatCount$compute_group #> <ggproto method> #>   <Wrapper function> #>     function (...)  #> compute_group(..., self = self) #>  #>   <Inner function (f)> #>     function (self, data, scales, width = NULL, flipped_aes = FALSE)  #> { #>     data <- flip_data(data, flipped_aes) #>     x <- data$x #>     weight <- data$weight %||% rep(1, length(x)) #>     count <- as.numeric(tapply(weight, x, sum, na.rm = TRUE)) #>     count[is.na(count)] <- 0 #>     bars <- data_frame0(count = count, prop = count/sum(abs(count)),  #>         x = sort(unique0(x)), width = width, flipped_aes = flipped_aes,  #>         .size = length(count)) #>     flip_data(bars, flipped_aes) #> } formals(StatCount$compute_group) #> $... #>  #>  body(StatCount$compute_group) #> compute_group(..., self = self)  # Errors # get(StatCount$compute_group)  # Informative get_method(StatCount$compute_group) #> function (self, data, scales, width = NULL, flipped_aes = FALSE)  #> { #>     data <- flip_data(data, flipped_aes) #>     x <- data$x #>     weight <- data$weight %||% rep(1, length(x)) #>     count <- as.numeric(tapply(weight, x, sum, na.rm = TRUE)) #>     count[is.na(count)] <- 0 #>     bars <- data_frame0(count = count, prop = count/sum(abs(count)),  #>         x = sort(unique0(x)), width = width, flipped_aes = flipped_aes,  #>         .size = length(count)) #>     flip_data(bars, flipped_aes) #> } #> <bytecode: 0x0000015e330a3c58> #> <environment: namespace:ggplot2> ggformals(StatCount$compute_group) # formals(get_method(StatCount$compute_group)) #> $self #>  #>  #> $data #>  #>  #> $scales #>  #>  #> $width #> NULL #>  #> $flipped_aes #> [1] FALSE #>  ggbody(StatCount$compute_group)    # body(get_method(StatCount$compute_group)) #> [[1]] #> `{` #>  #> [[2]] #> data <- flip_data(data, flipped_aes) #>  #> [[3]] #> x <- data$x #>  #> [[4]] #> weight <- data$weight %||% rep(1, length(x)) #>  #> [[5]] #> count <- as.numeric(tapply(weight, x, sum, na.rm = TRUE)) #>  #> [[6]] #> count[is.na(count)] <- 0 #>  #> [[7]] #> bars <- data_frame0(count = count, prop = count/sum(abs(count)),  #>     x = sort(unique0(x)), width = width, flipped_aes = flipped_aes,  #>     .size = length(count)) #>  #> [[8]] #> flip_data(bars, flipped_aes) #>   # Works for ggproto in extension packages  ggbody(ggforce::StatDelaunaySegment$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> if (any(duplicated(data[, c(\"x\", \"y\")]))) { #>     cli::cli_warn(\"{.fn {snake_class(self)}} is dropping duplicated points\") #> } #>  #> [[3]] #> if (normalize) { #>     x_range <- range(data$x, na.rm = TRUE, finite = TRUE) #>     y_range <- range(data$y, na.rm = TRUE, finite = TRUE) #>     data$x <- rescale(data$x, from = x_range) * asp.ratio #>     data$y <- rescale(data$y, from = y_range) #>     if (!is.null(bound)) { #>         bound[1:2] <- rescale(bound[1:2], from = x_range) * asp.ratio #>         bound[3:4] <- rescale(bound[3:4], from = x_range) #>     } #> } #>  #> [[4]] #> vor <- deldir::deldir(data$x, data$y, rw = bound, eps = eps,  #>     suppressMsge = TRUE) #>  #> [[5]] #> segments <- vor$delsgs[, 1:5] #>  #> [[6]] #> names(segments) <- c(\"x\", \"y\", \"xend\", \"yend\", \"group\") #>  #> [[7]] #> segments$group <- vor$ind.orig[segments$group] #>  #> [[8]] #> data <- cbind(segments[, 1:4], data[segments$group, !names(data) %in%  #>     c(\"x\", \"y\"), drop = FALSE]) #>  #> [[9]] #> if (normalize) { #>     data$x <- rescale(data$x/asp.ratio, to = x_range, from = c(0,  #>         1)) #>     data$xend <- rescale(data$xend/asp.ratio, to = x_range, from = c(0,  #>         1)) #>     data$y <- rescale(data$y, to = y_range, from = c(0, 1)) #>     data$yend <- rescale(data$yend, to = y_range, from = c(0,  #>         1)) #> } #>  #> [[10]] #> data #>   library(ggforce) ggbody(StatBezier$compute_panel) #> [[1]] #> `{` #>  #> [[2]] #> if (empty_data(data)) return(data) #>  #> [[3]] #> nControls <- table(data$group) #>  #> [[4]] #> controlRange <- range(nControls) #>  #> [[5]] #> if (min(controlRange) < 3 || max(controlRange) > 4) { #>     cli::cli_abort(c(\"Only support for quadratic and cubic beziers\",  #>         i = \"Make sure each group consists of 3 or 4 rows\")) #> } #>  #> [[6]] #> data <- data[order(data$group), ] #>  #> [[7]] #> groups <- unique0(data$group) #>  #> [[8]] #> paths <- getBeziers(data$x, data$y, match(data$group, groups),  #>     n) #>  #> [[9]] #> paths <- data_frame0(x = paths$paths[, 1], y = paths$paths[,  #>     2], group = groups[paths$pathID]) #>  #> [[10]] #> paths$index <- rep(seq(0, 1, length.out = n), length(nControls)) #>  #> [[11]] #> dataIndex <- rep(match(unique0(data$group), data$group), each = n) #>  #> [[12]] #> cbind(paths, data[dataIndex, !names(data) %in% c(\"x\", \"y\", \"group\"),  #>     drop = FALSE]) #>   # `inherit = TRUE` will return the method from the closest parent  ## ERRORS: ## get_method(StatBoxplot$compute_panel) ## ggbody(StatBoxplot$compute_panel) ## ggformals(StatBoxplot$compute_panel) ggbody(StatBoxplot$compute_panel, inherit = TRUE) #> Method inherited from `Stat$compute_panel` #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(data_frame0()) #>  #> [[3]] #> groups <- split(data, data$group) #>  #> [[4]] #> stats <- lapply(groups, function(group) { #>     self$compute_group(data = group, scales = scales, ...) #> }) #>  #> [[5]] #> non_constant_columns <- character(0) #>  #> [[6]] #> stats <- mapply(function(new, old) { #>     if (empty(new))  #>         return(data_frame0()) #>     old <- old[, !(names(old) %in% names(new)), drop = FALSE] #>     non_constant <- vapply(old, function(x) length(unique0(x)) >  #>         1, logical(1L)) #>     non_constant_columns <<- c(non_constant_columns, names(old)[non_constant]) #>     vec_cbind(new, old[rep(1, nrow(new)), , drop = FALSE]) #> }, stats, groups, SIMPLIFY = FALSE) #>  #> [[7]] #> non_constant_columns <- unique0(non_constant_columns) #>  #> [[8]] #> dropped <- non_constant_columns[!non_constant_columns %in% self$dropped_aes] #>  #> [[9]] #> if (length(dropped) > 0) { #>     cli::cli_warn(c(\"The following aesthetics were dropped during statistical transformation: {.field {glue_collapse(dropped, sep = ', ')}}\",  #>         i = \"This can happen when ggplot fails to infer the correct grouping structure in the data.\",  #>         i = \"Did you forget to specify a {.code group} aesthetic or to convert a numerical variable into a factor?\")) #> } #>  #> [[10]] #> data_new <- vec_rbind0(!!!stats) #>  #> [[11]] #> data_new[, !names(data_new) %in% non_constant_columns, drop = FALSE] #>  ggbody(Stat$compute_panel) #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(data_frame0()) #>  #> [[3]] #> groups <- split(data, data$group) #>  #> [[4]] #> stats <- lapply(groups, function(group) { #>     self$compute_group(data = group, scales = scales, ...) #> }) #>  #> [[5]] #> non_constant_columns <- character(0) #>  #> [[6]] #> stats <- mapply(function(new, old) { #>     if (empty(new))  #>         return(data_frame0()) #>     old <- old[, !(names(old) %in% names(new)), drop = FALSE] #>     non_constant <- vapply(old, function(x) length(unique0(x)) >  #>         1, logical(1L)) #>     non_constant_columns <<- c(non_constant_columns, names(old)[non_constant]) #>     vec_cbind(new, old[rep(1, nrow(new)), , drop = FALSE]) #> }, stats, groups, SIMPLIFY = FALSE) #>  #> [[7]] #> non_constant_columns <- unique0(non_constant_columns) #>  #> [[8]] #> dropped <- non_constant_columns[!non_constant_columns %in% self$dropped_aes] #>  #> [[9]] #> if (length(dropped) > 0) { #>     cli::cli_warn(c(\"The following aesthetics were dropped during statistical transformation: {.field {glue_collapse(dropped, sep = ', ')}}\",  #>         i = \"This can happen when ggplot fails to infer the correct grouping structure in the data.\",  #>         i = \"Did you forget to specify a {.code group} aesthetic or to convert a numerical variable into a factor?\")) #> } #>  #> [[10]] #> data_new <- vec_rbind0(!!!stats) #>  #> [[11]] #> data_new[, !names(data_new) %in% non_constant_columns, drop = FALSE] #>   # Navigating complex inheritance class(GeomArcBar) #> [1] \"GeomArcBar\"  \"GeomShape\"   \"GeomPolygon\" \"Geom\"        \"ggproto\"     #> [6] \"gg\"          invisible(ggbody(GeomArcBar$default_aes, inherit = TRUE)) # self #> Method 'default_aes' is defined for `GeomArcBar`, not inherited. invisible(ggbody(GeomArcBar$draw_panel, inherit = TRUE))  # parent #> Method inherited from `GeomShape$draw_panel` invisible(ggbody(GeomArcBar$draw_key, inherit = TRUE))    # grandparent #> Method inherited from `GeomPolygon$draw_key` invisible(ggbody(GeomArcBar$draw_group, inherit = TRUE))  # top-level #> Method inherited from `Geom$draw_group`  # Getting information about method inheritance all at once # - default `trim_overriden = TRUE` hides redundant methods defined in parent get_method_inheritance(GeomArcBar, trim_overriden = TRUE) #> $Geom #>  [1] \"aesthetics\"      \"draw_group\"      \"draw_layer\"      \"draw_panel\"      #>  [5] \"extra_params\"    \"non_missing_aes\" \"optional_aes\"    \"parameters\"      #>  [9] \"setup_data\"      \"setup_params\"    \"use_defaults\"    #>  #> $GeomPolygon #> [1] \"default_aes\"  \"draw_key\"     \"handle_na\"    \"rename_size\"  \"required_aes\" #>  #> $GeomShape #> [1] \"draw_panel\"   \"extra_params\" #>  #> $GeomArcBar #> [1] \"default_aes\" #>   # Works for custom ggproto # - Example from {ggplot2} \"Extending ggplot2\" vignette StatDensityCommon <- ggproto(\"StatDensityCommon\", Stat,   required_aes = \"x\",    setup_params = function(data, params) {     if (!is.null(params$bandwidth))       return(params)      xs <- split(data$x, data$group)     bws <- vapply(xs, bw.nrd0, numeric(1))     bw <- mean(bws)     message(\"Picking bandwidth of \", signif(bw, 3))      params$bandwidth <- bw     params   },    compute_group = function(data, scales, bandwidth = 1) {     d <- density(data$x, bw = bandwidth)     data.frame(x = d$x, y = d$y)   } )  as.list(body(get(\"compute_group\", StatDensityCommon))) #> [[1]] #> `{` #>  #> [[2]] #> d <- density(data$x, bw = bandwidth) #>  #> [[3]] #> data.frame(x = d$x, y = d$y) #>   ggbody(StatDensityCommon$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> d <- density(data$x, bw = bandwidth) #>  #> [[3]] #> data.frame(x = d$x, y = d$y) #>   # As of v.0.4.0, ggbody works for functions as well ggbody(sample) #> [[1]] #> `{` #>  #> [[2]] #> if (length(x) == 1L && is.numeric(x) && is.finite(x) && x >=  #>     1) { #>     if (missing(size))  #>         size <- x #>     sample.int(x, size, replace, prob) #> } else { #>     if (missing(size))  #>         size <- length(x) #>     x[sample.int(length(x), size, replace, prob)] #> } #>  ggtrace(sample, 1) #> `sample` now being traced. invisible(ggbody(sample)) #> Warning: `sample` is currently being traced is_traced(sample) #> [1] TRUE gguntrace(sample) #> `sample` no longer being traced."},{"path":"/reference/ggbody.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the body of a function or a method as a list — ggbody","title":"Retrieve the body of a function or a method as a list — ggbody","text":"Retrieve body function method list","code":""},{"path":"/reference/ggbody.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the body of a function or a method as a list — ggbody","text":"","code":"ggbody(method, inherit = FALSE)"},{"path":"/reference/ggbody.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the body of a function or a method as a list — ggbody","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method inherit Whether method searched closest parent. Defaults FALSE. TRUE, returns parent's method corresponding ggbody() code message.","code":""},{"path":"/reference/ggbody.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the body of a function or a method as a list — ggbody","text":"list","code":""},{"path":"/reference/ggbody.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Retrieve the body of a function or a method as a list — ggbody","text":"ggbody() calls .list(body(get(\"method\", ggproto))) hood. get(\"method\", ggproto) syntax long form ggproto$method retrieves actual function body. subtle important difference inspecting ggproto methods. example, works: debugonce(get(\"compute_group\", StatCount)) fails insert break point: debugonce(StatCount$compute_group) ggbody() designed worry distinction.","code":""},{"path":"/reference/ggbody.html","id":"gotchas","dir":"Reference","previous_headings":"","what":"Gotchas","title":"Retrieve the body of a function or a method as a list — ggbody","text":"method traced via ggtrace() ggedit(), ggbody() return current modified state method. v0.3.5, calling ggbody() method trace return warning emphasize fact. using inherit = TRUE, make sure ggproto objects class(ggproto) available (loading packages defined, example). hood, ggbody() loops parents search method, needs able evaluate element class(ggproto) object.","code":""},{"path":"/reference/ggbody.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the body of a function or a method as a list — ggbody","text":"","code":"library(ggplot2)  ggbody(StatCount$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> data <- flip_data(data, flipped_aes) #>  #> [[3]] #> x <- data$x #>  #> [[4]] #> weight <- data$weight %||% rep(1, length(x)) #>  #> [[5]] #> count <- as.numeric(tapply(weight, x, sum, na.rm = TRUE)) #>  #> [[6]] #> count[is.na(count)] <- 0 #>  #> [[7]] #> bars <- new_data_frame(list(count = count, prop = count/sum(abs(count)),  #>     x = sort(unique(x)), width = width, flipped_aes = flipped_aes),  #>     n = length(count)) #>  #> [[8]] #> flip_data(bars, flipped_aes) #>   # Works for ggproto in extension packages  ggbody(ggforce::StatDelaunaySegment$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> if (any(duplicated(data[, c(\"x\", \"y\")]))) { #>     warning(\"stat_delaunay_segment: dropping duplicated points\",  #>         call. = FALSE) #> } #>  #> [[3]] #> if (normalize) { #>     x_range <- range(data$x, na.rm = TRUE, finite = TRUE) #>     y_range <- range(data$y, na.rm = TRUE, finite = TRUE) #>     data$x <- rescale(data$x, from = x_range) * asp.ratio #>     data$y <- rescale(data$y, from = y_range) #>     if (!is.null(bound)) { #>         bound[1:2] <- rescale(bound[1:2], from = x_range) * asp.ratio #>         bound[3:4] <- rescale(bound[3:4], from = x_range) #>     } #> } #>  #> [[4]] #> vor <- deldir::deldir(data$x, data$y, rw = bound, eps = eps,  #>     suppressMsge = TRUE) #>  #> [[5]] #> segments <- vor$delsgs[, 1:5] #>  #> [[6]] #> names(segments) <- c(\"x\", \"y\", \"xend\", \"yend\", \"group\") #>  #> [[7]] #> segments$group <- vor$ind.orig[segments$group] #>  #> [[8]] #> data <- cbind(segments[, 1:4], data[segments$group, !names(data) %in%  #>     c(\"x\", \"y\"), drop = FALSE]) #>  #> [[9]] #> if (normalize) { #>     data$x <- rescale(data$x/asp.ratio, to = x_range, from = c(0,  #>         1)) #>     data$xend <- rescale(data$xend/asp.ratio, to = x_range, from = c(0,  #>         1)) #>     data$y <- rescale(data$y, to = y_range, from = c(0, 1)) #>     data$yend <- rescale(data$yend, to = y_range, from = c(0,  #>         1)) #> } #>  #> [[10]] #> data #>   library(ggforce) ggbody(StatBezier$compute_panel) #> [[1]] #> `{` #>  #> [[2]] #> if (is.null(data)) return(data) #>  #> [[3]] #> nControls <- table(data$group) #>  #> [[4]] #> controlRange <- range(nControls) #>  #> [[5]] #> if (min(controlRange) < 3 || max(controlRange) > 4) { #>     stop(\"Only support for quadratic and cubic beziers\") #> } #>  #> [[6]] #> data <- data[order(data$group), ] #>  #> [[7]] #> groups <- unique(data$group) #>  #> [[8]] #> paths <- getBeziers(data$x, data$y, match(data$group, groups),  #>     n) #>  #> [[9]] #> paths <- data.frame(x = paths$paths[, 1], y = paths$paths[, 2],  #>     group = groups[paths$pathID]) #>  #> [[10]] #> paths$index <- rep(seq(0, 1, length.out = n), length(nControls)) #>  #> [[11]] #> dataIndex <- rep(match(unique(data$group), data$group), each = n) #>  #> [[12]] #> cbind(paths, data[dataIndex, !names(data) %in% c(\"x\", \"y\", \"group\"),  #>     drop = FALSE]) #>   # `inherit = TRUE` will return the method from the closest parent  ## ERRORS: ## ggbody(StatBoxplot$compute_panel) ggbody(StatBoxplot$compute_panel, inherit = TRUE) #> Returning `ggbody(Stat$compute_panel)` #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(new_data_frame()) #>  #> [[3]] #> groups <- split(data, data$group) #>  #> [[4]] #> stats <- lapply(groups, function(group) { #>     self$compute_group(data = group, scales = scales, ...) #> }) #>  #> [[5]] #> stats <- mapply(function(new, old) { #>     if (empty(new))  #>         return(new_data_frame()) #>     unique <- uniquecols(old) #>     missing <- !(names(unique) %in% names(new)) #>     cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #> }, stats, groups, SIMPLIFY = FALSE) #>  #> [[6]] #> rbind_dfs(stats) #>  ggbody(Stat$compute_panel) #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(new_data_frame()) #>  #> [[3]] #> groups <- split(data, data$group) #>  #> [[4]] #> stats <- lapply(groups, function(group) { #>     self$compute_group(data = group, scales = scales, ...) #> }) #>  #> [[5]] #> stats <- mapply(function(new, old) { #>     if (empty(new))  #>         return(new_data_frame()) #>     unique <- uniquecols(old) #>     missing <- !(names(unique) %in% names(new)) #>     cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #> }, stats, groups, SIMPLIFY = FALSE) #>  #> [[6]] #> rbind_dfs(stats) #>   # Navigating complex inheritance class(GeomArcBar) #> [1] \"GeomArcBar\"  \"GeomShape\"   \"GeomPolygon\" \"Geom\"        \"ggproto\"     #> [6] \"gg\"          invisible(ggbody(GeomArcBar$default_aes, inherit = TRUE)) # self #> Method 'default_aes' is defined for `GeomArcBar`, not inherited. invisible(ggbody(GeomArcBar$draw_panel, inherit = TRUE))  # parent #> Returning `ggbody(GeomShape$draw_panel)` invisible(ggbody(GeomArcBar$draw_key, inherit = TRUE))    # grandparent #> Returning `ggbody(GeomPolygon$draw_key)` invisible(ggbody(GeomArcBar$draw_group, inherit = TRUE))  # top-level #> Returning `ggbody(Geom$draw_group)`  # Works for custom ggproto # - Example from {ggplot2} \"Extending ggplot2\" vignette StatDensityCommon <- ggproto(\"StatDensityCommon\", Stat,   required_aes = \"x\",    setup_params = function(data, params) {     if (!is.null(params$bandwidth))       return(params)      xs <- split(data$x, data$group)     bws <- vapply(xs, bw.nrd0, numeric(1))     bw <- mean(bws)     message(\"Picking bandwidth of \", signif(bw, 3))      params$bandwidth <- bw     params   },    compute_group = function(data, scales, bandwidth = 1) {     d <- density(data$x, bw = bandwidth)     data.frame(x = d$x, y = d$y)   } )  as.list(body(get(\"compute_group\", StatDensityCommon))) #> [[1]] #> `{` #>  #> [[2]] #> d <- density(data$x, bw = bandwidth) #>  #> [[3]] #> data.frame(x = d$x, y = d$y) #>   ggbody(StatDensityCommon$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> d <- density(data$x, bw = bandwidth) #>  #> [[3]] #> data.frame(x = d$x, y = d$y) #>   # As of v.0.4.0, ggbody works for functions as well ggbody(sample) #> [[1]] #> `{` #>  #> [[2]] #> if (length(x) == 1L && is.numeric(x) && is.finite(x) && x >=  #>     1) { #>     if (missing(size))  #>         size <- x #>     sample.int(x, size, replace, prob) #> } else { #>     if (missing(size))  #>         size <- length(x) #>     x[sample.int(length(x), size, replace, prob)] #> } #>  ggtrace(sample, 1) #> `sample` now being traced. invisible(ggbody(sample)) #> Warning: `sample` is currently being traced is_traced(sample) #> [1] TRUE gguntrace(sample) #> `sample` no longer being traced."},{"path":"/reference/ggdebug.html","id":null,"dir":"Reference","previous_headings":"","what":"Debug a ggproto method — ggdebug","title":"Debug a ggproto method — ggdebug","text":"Debug ggproto method","code":""},{"path":"/reference/ggdebug.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Debug a ggproto method — ggdebug","text":"","code":"ggdebug(method, ...)  ggdebugonce(method, ...)  ggundebug(method, ...)"},{"path":"/reference/ggdebug.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Debug a ggproto method — ggdebug","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Ignored. Designed ease calling function modifying call earlier {ggtrace} function interactive contexts.","code":""},{"path":"/reference/ggdebugonce.html","id":null,"dir":"Reference","previous_headings":"","what":"Debugonce a ggproto method — ggdebugonce","title":"Debugonce a ggproto method — ggdebugonce","text":"Debugonce ggproto method","code":""},{"path":"/reference/ggdebugonce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Debugonce a ggproto method — ggdebugonce","text":"","code":"ggdebugonce(method, ...)"},{"path":"/reference/ggdebugonce.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Debugonce a ggproto method — ggdebugonce","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Ignored. Designed ease calling function modifying call earlier {ggtrace} function interactive contexts.","code":""},{"path":"/reference/ggedit.html","id":null,"dir":"Reference","previous_headings":"","what":"Interactively edit a masking copy of the source code — ggedit","title":"Interactively edit a masking copy of the source code — ggedit","text":"Interactively edit masking copy source code","code":""},{"path":"/reference/ggedit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interactively edit a masking copy of the source code — ggedit","text":"","code":"ggedit(method, remove_trace = FALSE, ...)"},{"path":"/reference/ggedit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interactively edit a masking copy of the source code — ggedit","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method remove_trace Whether edit clean slate. Defaults FALSE. ... Unused, extensibility.","code":""},{"path":"/reference/ggedit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interactively edit a masking copy of the source code — ggedit","text":"Like base::trace(), edit effect gguntrace() called. Changes ggedit() cumulative, ggedit() inform via warning making edit top existing edit. Call gguntrace() object first like edit method's original unaltered source code. works interactive contexts.","code":""},{"path":"/reference/ggedit.html","id":"gotchas","dir":"Reference","previous_headings":"","what":"Gotchas","title":"Interactively edit a masking copy of the source code — ggedit","text":"Calling ggtrace() method changes ggedit() remove changes ggedit(). possible combine features, disabled package keep API consistent. philosophy {ggtrace} mix programmatic interactive workflows.","code":""},{"path":[]},{"path":"/reference/ggedit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interactively edit a masking copy of the source code — ggedit","text":"","code":"if (FALSE) {  jitter_plot <- ggplot(diamonds[1:1000,], aes(cut, depth)) +   geom_point(position = position_jitter(width = 0.2, seed = 2021))  # Interactively modify the method's source code in text editor ggedit(PositionJitter$compute_layer)  # Check the edited code ggbody(PositionJitter$compute_layer)  # Execute method with edit jitter_plot  # Untrace gguntrace(PositionJitter$compute_layer)  # Edit is removed in the next call jitter_plot  }"},{"path":"/reference/ggeval_silent.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple evaluation and printing of a ggplot object — ggeval_silent","title":"Simple evaluation and printing of a ggplot object — ggeval_silent","text":"ggeval_silent() evaluates ggplot object <gtable> grob ggdraw_silent() renders grob {grid}. Combined, two functions simulate ggplot2:::print.ggplot without overriding last_plot().","code":""},{"path":"/reference/ggeval_silent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple evaluation and printing of a ggplot object — ggeval_silent","text":"","code":"ggeval_silent(x)  ggdraw_silent(x)"},{"path":"/reference/ggeval_silent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple evaluation and printing of a ggplot object — ggeval_silent","text":"x ggplot","code":""},{"path":"/reference/ggeval_silent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple evaluation and printing of a ggplot object — ggeval_silent","text":"gtable","code":""},{"path":"/reference/ggtrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Insert traces for delayed evaluation — ggtrace","title":"Insert traces for delayed evaluation — ggtrace","text":"Insert traces delayed evaluation","code":""},{"path":"/reference/ggtrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Insert traces for delayed evaluation — ggtrace","text":"","code":"ggtrace(   method,   trace_steps,   trace_exprs,   once = TRUE,   use_names = TRUE,   ...,   print_output = TRUE,   verbose = FALSE )"},{"path":"/reference/ggtrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Insert traces for delayed evaluation — ggtrace","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method trace_steps sorted numeric vector positions method's body trace. Negative indices reference steps last, -1 references last step body. trace_exprs list expressions evaluate position specified trace_steps. single expression provided, recycled match length trace_steps. simply run step return output, can use ~step keyword. step assign expression, value assigned variable returned. trace_exprs provided, ggtrace() called ~step default. Whether untrace() method exit. FALSE, creates persistent trace active gguntrace() called method. Defaults TRUE. use_names Whether trace dump use names trace_exprs. Defaults TRUE. ... Unused, extensibility. print_output Whether print() output expression console. Defaults TRUE. verbose Whether logs printed trace triggered. Encompasses print_output, meaning verbose = FALSE also triggers effect print_output = FALSE consequence. Defaults FALSE.","code":""},{"path":"/reference/ggtrace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Insert traces for delayed evaluation — ggtrace","text":"ggtrace() wrapper around base::trace() called ggproto method. calls base::untrace() exit default, make effect ephemeral like base::debugonce(). major feature ability pass multiple positions expressions trace_steps trace_exprs inspect, capture, modify run time environment ggproto methods. recommended consult output ggbody() deciding expressions evaluate steps. output expressions passed trace_exprs printed tracing takes place. list outputs ggtrace() (\"trace dumps\") can returned inspection last_ggtrace() global_ggtrace().","code":""},{"path":"/reference/ggtrace.html","id":"workflows","dir":"Reference","previous_headings":"","what":"Workflows","title":"Insert traces for delayed evaluation — ggtrace","text":"Broadly, four flavors working {ggtrace} package, listed order increasing complexity: Inspect: canonical use ggtrace() make queries, expressions passed evaluated output returned, potentially inspection. Capture: strategy returning method's runtime environment complex explorations outside debugging context. method's environment contextualizes self object addition making inherited params local variables available. reference method's runtime environment can returned environment(), trace_exprs = quote(environment()). Note environments mutable, meaning environment() returned first last steps reference environment. get snapshot environment particular step, can return deep copy rlang::env_clone(environment()). Inject: strategy modifying behavior method runs passing expressions make assignments. example, trace_steps = c(1, 10) trace_exprs = rlang::exprs(<- 5, ) first assign new variable step 1, return value 5 step 10. can also used modify important variables like quote(data$x <- data$x * 10). like inject object global environment, can make use !! (bang-bang) operator {rlang}, like : rlang::expr(data <- !!modified_data). Note execution environment created anew time method ran, modifying environment previous execution affect future calls method. like capture modified plot output assign variable, can ggplotGrob(). can render modified plot print(). Edit: also possible make arbitrary modifications method's source code, stays effect method untraced. also handled base::trace(), workflow fundamentally interactive. Therefore, refactored function ggedit(). See ?ggedit details.","code":""},{"path":"/reference/ggtrace.html","id":"gotchas","dir":"Reference","previous_headings":"","what":"Gotchas","title":"Insert traces for delayed evaluation — ggtrace","text":"wrap ggplot invisible() silence ggtrace(), plot build, also means tracing triggered. print/plot method ggplot triggers evaluation plot code. recommended allow ggtrace() print information, really like silence , can wrapping plot function forces evaluation first, like ggplotGrob, invisible(ggplotGrob(<plot>)). reason ggtrace(= TRUE) fails untrace exit, may accidentally trigger trace . check method traced, call is_traced(). can also always call gguntrace() since unlike base::untrace(), error trace exist method. Instead, gguntrace() nothing case simply inform trace remove. base::trace() wraps method body special environment, possible inspect method/function called , even something like rlang::caller_env(). traverse wrapping environments created base::trace() eventually ends looping around.","code":""},{"path":"/reference/ggtrace.html","id":"messages","dir":"Reference","previous_headings":"","what":"Messages","title":"Insert traces for delayed evaluation — ggtrace","text":"Various information sent console whenever trace triggered. can control gets displayed print_output verbose, TRUE default. print_output simply calls print() evaluated expressions, turning may desirable expressions trace_exprs evaluates long dataframe vector. verbose controls information printed console including print(), setting verbose = FALSE mean message()s displayed. Lastly, can suppress message() ggtrace() options(ggtrace.suppressMessages = TRUE), though suppressing messages generally recommended.","code":""},{"path":[]},{"path":"/reference/ggtrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Insert traces for delayed evaluation — ggtrace","text":"","code":"# One example of an Inspect workflow ----  library(ggplot2)  jitter_plot <- ggplot(diamonds[1:1000,], aes(cut, depth)) +   geom_point(position = position_jitter(width = 0.2, seed = 2021))  jitter_plot   ggbody(PositionJitter$compute_layer) #> [[1]] #> `{` #>  #> [[2]] #> trans_x <- if (params$width > 0) function(x) jitter(x, amount = params$width) #>  #> [[3]] #> trans_y <- if (params$height > 0) function(x) jitter(x, amount = params$height) #>  #> [[4]] #> x_aes <- intersect(ggplot_global$x_aes, names(data)) #>  #> [[5]] #> x <- if (length(x_aes) == 0) 0 else data[[x_aes[1]]] #>  #> [[6]] #> y_aes <- intersect(ggplot_global$y_aes, names(data)) #>  #> [[7]] #> y <- if (length(y_aes) == 0) 0 else data[[y_aes[1]]] #>  #> [[8]] #> dummy_data <- data_frame0(x = x, y = y, .size = nrow(data)) #>  #> [[9]] #> fixed_jitter <- with_seed_null(params$seed, transform_position(dummy_data,  #>     trans_x, trans_y)) #>  #> [[10]] #> x_jit <- fixed_jitter$x - x #>  #> [[11]] #> y_jit <- fixed_jitter$y - y #>  #> [[12]] #> x_jit[is.infinite(x)] <- 0 #>  #> [[13]] #> y_jit[is.infinite(y)] <- 0 #>  #> [[14]] #> transform_position(data, function(x) x + x_jit, function(x) x +  #>     y_jit) #>   ## Step 1 ==== ## Inspect what `data` look like at the start of the function ggtrace(PositionJitter$compute_layer, trace_steps = 1, trace_exprs = quote(head(data))) #> `PositionJitter$compute_layer` now being traced.  jitter_plot #> Triggering trace on `PositionJitter$compute_layer` #> Untracing `PositionJitter$compute_layer` on exit.   ## Step 2 ==== ## What does `data` look like at the end of the method? Unfortunately, `trace()` only lets us enter ## at the beginning of a step, so we can't inspect what happens after the last step is evaluated. To ## address this, `ggtrace()` offers a `~step` keyword which gets substituted for the current line. ## We also set `print_output = FALSE` to disable printing of the output ggtrace(   PositionJitter$compute_layer,   trace_steps = 14,   trace_exprs = quote(~step), # This is the default if `trace_exprs` is not provided   print_output = FALSE ) #> `PositionJitter$compute_layer` now being traced.  # We wrap the plot in `ggplotGrob()` and `invisible()` to force # its evaluation while suppressing its rendering invisible(ggplotGrob(jitter_plot)) #> Triggering trace on `PositionJitter$compute_layer` #> Untracing `PositionJitter$compute_layer` on exit.  # The output of the evaluated expressions can be inspected with `last_ggtrace()` head(last_ggtrace()[[1]]) #>          x        y PANEL group #> 1 4.980507 61.50684     1     5 #> 2 4.113512 59.77872     1     4 #> 3 2.083873 56.86655     1     2 #> 4 3.952698 62.42703     1     4 #> 5 2.054530 63.29763     1     2 #> 6 3.080538 62.77536     1     3  ## Step 3 ==== ## If we want both to be returned at the same time for an easier comparison, we can pass in a ## (named) list of expressions. ggtrace(   PositionJitter$compute_layer,   trace_steps = c(1, 14),   trace_exprs = rlang::exprs(     before_jitter = data,     after_jitter = ~step   ),   verbose = FALSE ) #> `PositionJitter$compute_layer` now being traced.  invisible(ggplotGrob(jitter_plot)) #> Triggering trace on `PositionJitter$compute_layer` #> Untracing `PositionJitter$compute_layer` on exit.  ## Step 4 ==== ## The output of the evaluated expressions can be inspected with `last_ggtrace()` jitter_tracedump <- last_ggtrace()  lapply(jitter_tracedump, head, 3) #> $before_jitter #>   x    y PANEL group #> 1 5 61.5     1     5 #> 2 4 59.8     1     4 #> 3 2 56.9     1     2 #>  #> $after_jitter #>          x        y PANEL group #> 1 4.980507 61.50684     1     5 #> 2 4.113512 59.77872     1     4 #> 3 2.083873 56.86655     1     2 #>   jitter_distances <- jitter_tracedump[[\"before_jitter\"]]$x -   jitter_tracedump[[\"after_jitter\"]]$x  range(jitter_distances) #> [1] -0.1994971  0.1995346 jitter_plot$layers[[1]]$position$width #> [1] 0.2"},{"path":"/reference/ggtraceback.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect the call stack on enter — ggtraceback","title":"Inspect the call stack on enter — ggtraceback","text":"Inspect call stack enter","code":""},{"path":"/reference/ggtraceback.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect the call stack on enter — ggtraceback","text":"","code":"ggtraceback(method, ...)"},{"path":"/reference/ggtraceback.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect the call stack on enter — ggtraceback","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Arguments passed rlang::trace_back top first frame environment included backtrace. becomes top backtrace tree represents oldest call backtrace. needed particular call trace_back() indirectly larger context, example tests inside RMarkdown document want knitr evaluation mechanisms appear backtrace. supplied, rlang_trace_top_env global option consulted. makes possible trim embedding context backtraces created option set. knitr progress, default value option knitr::knit_global() knitr context trimmed backtraces. bottom last frame environment included backtrace. becomes rightmost leaf backtrace tree represents youngest call backtrace. Set like capture backtrace without capture context. Can also integer passed caller_env().","code":""},{"path":"/reference/ggtraceback.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Inspect the call stack on enter — ggtraceback","text":"Calls rlang::trace_back() upon first entering function method. Note ggtraceback() ever prints back trace calls gguntrace() first time triggered. complex inspections call stack, ggedit() recommended.","code":""},{"path":"/reference/ggtraceback.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Inspect the call stack on enter — ggtraceback","text":"output rlang::trace_back() logged tracedumps (last_ggtrace() global_ggtrace())","code":""},{"path":"/reference/ggtrace_capture.html","id":null,"dir":"Reference","previous_headings":"","what":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"Returns ggproto method function arguments pre-filled values first called","code":""},{"path":"/reference/ggtrace_capture.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"","code":"ggtrace_capture(x, ...)"},{"path":"/reference/ggtrace_capture.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"x ggplot object ... Passed ggtrace(). method capture specified .","code":""},{"path":"/reference/ggtrace_capture.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"function","code":""},{"path":"/reference/ggtrace_capture.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"methods take ..., arguments passed ... runtime, captured stored .dots_captured argument returned function, accessible via formals(x)$.dots_captured. returned function also expose ..., defaults .dots_captured passed captured method unless also provided ...","code":""},{"path":"/reference/ggtrace_capture.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"","code":"library(ggplot2)  set.seed(47) df <- as.data.frame(matrix(sample(5, 50, TRUE), ncol = 2)) df #>    V1 V2 #> 1   3  5 #> 2   1  5 #> 3   2  4 #> 4   4  1 #> 5   1  5 #> 6   2  5 #> 7   5  1 #> 8   1  5 #> 9   5  2 #> 10  4  1 #> 11  5  3 #> 12  5  5 #> 13  4  3 #> 14  3  3 #> 15  3  5 #> 16  4  3 #> 17  1  1 #> 18  5  2 #> 19  2  5 #> 20  5  2 #> 21  2  2 #> 22  5  3 #> 23  3  5 #> 24  3  2 #> 25  1  3  base <- ggplot(df, aes(x = V1, y = V2))  p1 <- base + stat_summary(orientation = \"x\") p1 #> No summary function supplied, defaulting to `mean_se()`   p1_compute_panel <- ggtrace_capture(p1, method = StatSummary$compute_panel)  # `p1_compute_panel` is a copy of the ggproto method body(p1_compute_panel) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> } ggbody(StatSummary$compute_panel, as.list = FALSE) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> }  # Its arguments are pre-filled (captured at runtime) formals(p1_compute_panel) #> $data #>    x y PANEL group #> 1  3 5     1    -1 #> 2  1 5     1    -1 #> 3  2 4     1    -1 #> 4  4 1     1    -1 #> 5  1 5     1    -1 #> 6  2 5     1    -1 #> 7  5 1     1    -1 #> 8  1 5     1    -1 #> 9  5 2     1    -1 #> 10 4 1     1    -1 #> 11 5 3     1    -1 #> 12 5 5     1    -1 #> 13 4 3     1    -1 #> 14 3 3     1    -1 #> 15 3 5     1    -1 #> 16 4 3     1    -1 #> 17 1 1     1    -1 #> 18 5 2     1    -1 #> 19 2 5     1    -1 #> 20 5 2     1    -1 #> 21 2 2     1    -1 #> 22 5 3     1    -1 #> 23 3 5     1    -1 #> 24 3 2     1    -1 #> 25 1 3     1    -1 #>  #> $scales #> $scales$x #> <ScaleContinuousPosition> #>  Range:     1 --    5 #>  Limits:    1 --    5 #>  #> $scales$y #> <ScaleContinuousPosition> #>  Range:  1.42 -- 4.71 #>  Limits: 1.42 -- 4.71 #>  #>  #> $fun.data #> NULL #>  #> $fun #> NULL #>  #> $fun.max #> NULL #>  #> $fun.min #> NULL #>  #> $fun.args #> list() #>  #> $na.rm #> [1] FALSE #>  #> $flipped_aes #> [1] FALSE #>   # Runs as it should p1_compute_panel() #> No summary function supplied, defaulting to `mean_se()` #>   x group        y     ymin     ymax PANEL flipped_aes #> 1 1    -1 3.800000 3.000000 4.600000     1       FALSE #> 2 2    -1 4.000000 3.292893 4.707107     1       FALSE #> 3 3    -1 4.000000 3.367544 4.632456     1       FALSE #> 4 4    -1 2.000000 1.422650 2.577350     1       FALSE #> 5 5    -1 2.571429 2.090500 3.052357     1       FALSE  # You can inspect changes to its behavior outisde of ggplot # For example, see what happens when aes is flipped via `orientation = \"y\"` p1_compute_panel(flipped_aes = TRUE) #> No summary function supplied, defaulting to `mean_se()` #>   y group        x     xmin     xmax PANEL flipped_aes #> 1 1    -1 3.500000 2.633975 4.366025     1        TRUE #> 2 2    -1 4.000000 3.367544 4.632456     1        TRUE #> 3 3    -1 3.666667 3.052030 4.281303     1        TRUE #> 4 4    -1 2.000000       NA       NA     1        TRUE #> 5 5    -1 2.333333 1.892375 2.774292     1        TRUE  # We confirm this output to be true when `orientation = \"y\"` p2 <- base + stat_summary(orientation = \"y\") p2_compute_panel <- ggtrace_capture(p2, method = StatSummary$compute_panel) #> Warning: Removed 1 rows containing missing values (geom_segment).  identical(p1_compute_panel(flipped_aes = TRUE), p2_compute_panel()) #> No summary function supplied, defaulting to `mean_se()` #> No summary function supplied, defaulting to `mean_se()` #> [1] TRUE  # You can interactively explore with `debugonce(p2_compute_panel)`   # Note that the captured method looks slightly different if the method takes `...` p3 <- base + stat_smooth() + geom_jitter() p3 #> `geom_smooth()` using method = 'loess' and formula 'y ~ x'   p3_compute_panel <- ggtrace_capture(p3, method = Stat$compute_panel)  # For one, the body is different body(p3_compute_panel) #> { #>     cur_args <- mget(names(formals(rlang::current_fn()))) #>     specs <- names(cur_args) %in% names(formals(inner)) #>     do.call(inner, c(cur_args[specs], cur_args[!specs])) #> }  # The captured method is called internally, stored in the `\"inner\"` attribute attr(p3_compute_panel, \"inner\") #> function (self, data, scales, ...)  #> { #>     if (empty(data))  #>         return(new_data_frame()) #>     groups <- split(data, data$group) #>     stats <- lapply(groups, function(group) { #>         self$compute_group(data = group, scales = scales, ...) #>     }) #>     stats <- mapply(function(new, old) { #>         if (empty(new))  #>             return(new_data_frame()) #>         unique <- uniquecols(old) #>         missing <- !(names(unique) %in% names(new)) #>         cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #>     }, stats, groups, SIMPLIFY = FALSE) #>     rbind_dfs(stats) #> } #> <environment: 0x0000000039c61430>  # Captured argument defaults are again available for inspection via `formals()` # Note that arguments passed to the `...` are promoted to function arguments names(ggformals(Stat$compute_panel)) #> [1] \"self\"   \"data\"   \"scales\" \"...\"    names(formals(p3_compute_panel)) #>  [1] \"self\"        \"data\"        \"scales\"      \"method\"      \"formula\"     #>  [6] \"se\"          \"n\"           \"fullrange\"   \"level\"       \"na.rm\"       #> [11] \"method.args\" \"span\"        \"flipped_aes\"  # It works the same otherwise - plus you get the benefit of autocomplete head(p3_compute_panel()) #>          x        y     ymin     ymax        se flipped_aes PANEL group #> 1 1.000000 3.800000 2.456618 5.143382 0.6437060       FALSE     1    -1 #> 2 1.050633 3.814934 2.562634 5.067233 0.6000623       FALSE     1    -1 #> 3 1.101266 3.829354 2.645742 5.012967 0.5671495       FALSE     1    -1 #> 4 1.151899 3.843262 2.705881 4.980643 0.5449968       FALSE     1    -1 #> 5 1.202532 3.856658 2.744115 4.969200 0.5330951       FALSE     1    -1 #> 6 1.253165 3.869540 2.762657 4.976424 0.5303834       FALSE     1    -1 head(p3_compute_panel(level = .99)[, c(\"ymin\", \"ymax\")]) #>       ymin     ymax #> 1 1.967038 5.632962 #> 2 2.106247 5.523620 #> 3 2.214388 5.444321 #> 4 2.291376 5.395149 #> 5 2.338661 5.374654 #> 6 2.359266 5.379815 head(p3_compute_panel(flipped_aes = TRUE)) #>          y        x     xmin     xmax        se flipped_aes PANEL group #> 1 1.000000 3.486913 1.996579 4.977247 0.7148639        TRUE     1    -1 #> 2 1.050633 3.537510 2.136220 4.938801 0.6721527        TRUE     1    -1 #> 3 1.101266 3.585828 2.263181 4.908476 0.6344304        TRUE     1    -1 #> 4 1.151899 3.631850 2.377468 4.886232 0.6016854        TRUE     1    -1 #> 5 1.202532 3.675558 2.479204 4.871912 0.5738514        TRUE     1    -1 #> 6 1.253165 3.716935 2.568654 4.865215 0.5507921        TRUE     1    -1  # Interactively explore with `debugonce(attr(p3_compute_panel, \"inner\"))`"},{"path":"/reference/ggtrace_capture_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Capture a snapshot of a method's execution environment — ggtrace_capture_env","title":"Capture a snapshot of a method's execution environment — ggtrace_capture_env","text":"Capture snapshot method's execution environment","code":""},{"path":"/reference/ggtrace_capture_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capture a snapshot of a method's execution environment — ggtrace_capture_env","text":"","code":"ggtrace_capture_env(x, method, cond = 1L, at = -1L)"},{"path":"/reference/ggtrace_capture_env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capture a snapshot of a method's execution environment — ggtrace_capture_env","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond method environment captured. Defaults 1L. step method body environment captured. See ggbody() list expressions/steps method body.","code":""},{"path":"/reference/ggtrace_capture_env.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capture a snapshot of a method's execution environment — ggtrace_capture_env","text":"environment","code":""},{"path":"/reference/ggtrace_capture_env.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Capture a snapshot of a method's execution environment — ggtrace_capture_env","text":"quoted expressions passed cond value argument workflow functions evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ increments every time function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1L) evaluated TRUE method called first time. cond argument also supports numeric shorthands like cond = 1L evaluates quote(._counter_ == 1L), default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). recommended consult output ggtrace_inspect_n() ggtrace_inspect_which() construct expressions condition ._counter_. highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/ggtrace_capture_env.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capture a snapshot of a method's execution environment — ggtrace_capture_env","text":"","code":"library(ggplot2)  # Example from https://ggplot2.tidyverse.org/reference/aes_eval.html after_scale_plot <- ggplot(mpg, aes(class, hwy)) +   geom_boxplot(aes(colour = class, fill = after_scale(alpha(colour, 0.4)))) after_scale_plot   # `after_scale()` is resolved by `Geom$use_defaults` (at Step 6)  before_applying <- ggtrace_capture_env(   x = after_scale_plot,   method = Geom$use_defaults,   at = 1  # To be more specific, do `at = 6` ) after_applying <- ggtrace_capture_env(   x = after_scale_plot,   method = Geom$use_defaults,   at = -1  # To be more specific, do `at = 7` )  colnames(before_applying$data) #>  [1] \"colour\"      \"ymin\"        \"lower\"       \"middle\"      \"upper\"       #>  [6] \"ymax\"        \"outliers\"    \"notchupper\"  \"notchlower\"  \"x\"           #> [11] \"flipped_aes\" \"PANEL\"       \"group\"       \"ymin_final\"  \"ymax_final\"  #> [16] \"xmin\"        \"xmax\"        \"xid\"         \"newx\"        \"new_width\"   colnames(after_applying$data) #>  [1] \"fill\"        \"colour\"      \"ymin\"        \"lower\"       \"middle\"      #>  [6] \"upper\"       \"ymax\"        \"outliers\"    \"notchupper\"  \"notchlower\"  #> [11] \"x\"           \"flipped_aes\" \"PANEL\"       \"group\"       \"ymin_final\"  #> [16] \"ymax_final\"  \"xmin\"        \"xmax\"        \"xid\"         \"newx\"        #> [21] \"new_width\"   \"weight\"      \"alpha\"       \"shape\"       \"linetype\"    #> [26] \"linewidth\"    library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union  before_applying$data %>%   select(any_of(c(\"colour\", \"fill\"))) #>    colour #> 1 #F8766D #> 2 #C49A00 #> 3 #53B400 #> 4 #00C094 #> 5 #00B6EB #> 6 #A58AFF #> 7 #FB61D7 after_applying$data %>%   select(any_of(c(\"colour\", \"fill\"))) #>    colour      fill #> 1 #F8766D #F8766D66 #> 2 #C49A00 #C49A0066 #> 3 #53B400 #53B40066 #> 4 #00C094 #00C09466 #> 5 #00B6EB #00B6EB66 #> 6 #A58AFF #A58AFF66 #> 7 #FB61D7 #FB61D766  identical(   before_applying$data %>%     select(any_of(c(\"colour\", \"fill\"))) %>%     mutate(fill = alpha(colour, 0.4)),       #< after_scale() logic here   after_applying$data %>%     select(any_of(c(\"colour\", \"fill\"))) ) #> [1] TRUE   # Using the captured environment for further evaluation ggbody(Geom$draw_panel) #> [[1]] #> `{` #>  #> [[2]] #> groups <- split(data, factor(data$group)) #>  #> [[3]] #> grobs <- lapply(groups, function(group) { #>     self$draw_group(group, panel_params, coord, ...) #> }) #>  #> [[4]] #> ggname(snake_class(self), gTree(children = inject(gList(!!!grobs)))) #>   by_group_drawing_code <- rlang::call_args(ggbody(Geom$draw_panel)[[3]])[[2]] by_group_drawing_code #> lapply(groups, function(group) { #>     self$draw_group(group, panel_params, coord, ...) #> })  draw_panel_env <- ggtrace_capture_env(   x = after_scale_plot,   method = Geom$draw_panel ) draw_panel_env #> <environment: 0x0000015e319933b8>  boxes <- eval(by_group_drawing_code, draw_panel_env)  library(grid) grid.newpage() grid.draw(editGrob(boxes[[1]], vp = viewport()))"},{"path":"/reference/ggtrace_capture_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","title":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","text":"Returns ggproto method function arguments pre-filled values first called","code":""},{"path":"/reference/ggtrace_capture_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","text":"","code":"ggtrace_capture_fn(x, method, cond = 1L)"},{"path":"/reference/ggtrace_capture_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond method function captured. Defaults 1L.","code":""},{"path":"/reference/ggtrace_capture_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","text":"function","code":""},{"path":"/reference/ggtrace_capture_fn.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","text":"functions methods take ..., arguments passed ... captured promoted function arguments. captured values available inspection via formals().","code":""},{"path":"/reference/ggtrace_capture_fn.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","text":"quoted expressions passed cond value argument workflow functions evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ increments every time function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1L) evaluated TRUE method called first time. cond argument also supports numeric shorthands like cond = 1L evaluates quote(._counter_ == 1L), default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). recommended consult output ggtrace_inspect_n() ggtrace_inspect_which() construct expressions condition ._counter_. highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/ggtrace_capture_fn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","text":"","code":"library(ggplot2)  set.seed(47) df <- as.data.frame(matrix(sample(5, 1000, TRUE), ncol = 2)) table(df) #>    V2 #> V1   1  2  3  4  5 #>   1 28 16 15 23 21 #>   2 19 16 19 15 15 #>   3 23 22 18 21 20 #>   4 15 21 17 26 18 #>   5 20 27 26 18 21  base <- ggplot(df, aes(x = V1, y = V2))  p1 <- base + stat_summary(orientation = \"x\") p1 #> No summary function supplied, defaulting to `mean_se()`   p1_compute_panel <- ggtrace_capture_fn(p1, method = StatSummary$compute_panel) #> No summary function supplied, defaulting to `mean_se()`  # `p1_compute_panel` is a copy of the ggproto method body(p1_compute_panel) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> } ggbody(StatSummary$compute_panel, as.list = FALSE) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> }  # Its arguments are pre-filled (captured at runtime) sapply(formals(p1_compute_panel), class) #>         data       scales     fun.data          fun      fun.max      fun.min  #> \"data.frame\"       \"list\"       \"NULL\"       \"NULL\"       \"NULL\"       \"NULL\"  #>     fun.args        na.rm  flipped_aes  #>       \"list\"    \"logical\"    \"logical\"   # Runs as it should p1_compute_panel() #> No summary function supplied, defaulting to `mean_se()` #>   x group        y     ymin     ymax PANEL flipped_aes #> 1 1    -1 2.932039 2.782630 3.081447     1       FALSE #> 2 2    -1 2.892857 2.738537 3.047177     1       FALSE #> 3 3    -1 2.932692 2.791176 3.074209     1       FALSE #> 4 4    -1 3.113402 2.975241 3.251563     1       FALSE #> 5 5    -1 2.937500 2.807977 3.067023     1       FALSE  # You can inspect changes to its behavior outisde of ggplot # For example, see what happens when aes is flipped via `orientation = \"y\"` p1_compute_panel(flipped_aes = TRUE) #> No summary function supplied, defaulting to `mean_se()` #>   y group        x     xmin     xmax PANEL flipped_aes #> 1 1    -1 2.809524 2.666881 2.952167     1        TRUE #> 2 2    -1 3.264706 3.124729 3.404683     1        TRUE #> 3 3    -1 3.210526 3.062456 3.358597     1        TRUE #> 4 4    -1 3.009709 2.870024 3.149393     1        TRUE #> 5 5    -1 3.031579 2.881586 3.181572     1        TRUE  # We confirm this output to be true when `orientation = \"y\"` in `stat_summary()` p2 <- base + stat_summary(orientation = \"y\") p2_compute_panel <- ggtrace_capture_fn(p2, method = StatSummary$compute_panel) #> No summary function supplied, defaulting to `mean_se()`  identical(p1_compute_panel(flipped_aes = TRUE), p2_compute_panel()) #> No summary function supplied, defaulting to `mean_se()` #> No summary function supplied, defaulting to `mean_se()` #> [1] TRUE  # You can interactively explore with `debugonce(p2_compute_panel)`   # Note that the captured method looks slightly different if the method takes `...` p3 <- base + stat_smooth() + geom_jitter() p3 #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'   p3_compute_panel <- ggtrace_capture_fn(p3, method = Stat$compute_panel) #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  # For one, the body is different - it's a \"wrapper\" around the captured method body(p3_compute_panel) #> { #>     cur_args <- mget(names(formals(rlang::current_fn()))) #>     specs <- names(cur_args) %in% names(formals(inner)) #>     do.call(inner, c(cur_args[specs], cur_args[!specs])) #> }  # The captured method is stored in the `\"inner\"` attribute attr(p3_compute_panel, \"inner\") #> function (self, data, scales, ...)  #> { #>     if (empty(data))  #>         return(data_frame0()) #>     groups <- split(data, data$group) #>     stats <- lapply(groups, function(group) { #>         self$compute_group(data = group, scales = scales, ...) #>     }) #>     non_constant_columns <- character(0) #>     stats <- mapply(function(new, old) { #>         if (empty(new))  #>             return(data_frame0()) #>         old <- old[, !(names(old) %in% names(new)), drop = FALSE] #>         non_constant <- vapply(old, function(x) length(unique0(x)) >  #>             1, logical(1L)) #>         non_constant_columns <<- c(non_constant_columns, names(old)[non_constant]) #>         vec_cbind(new, old[rep(1, nrow(new)), , drop = FALSE]) #>     }, stats, groups, SIMPLIFY = FALSE) #>     non_constant_columns <- unique0(non_constant_columns) #>     dropped <- non_constant_columns[!non_constant_columns %in%  #>         self$dropped_aes] #>     if (length(dropped) > 0) { #>         cli::cli_warn(c(\"The following aesthetics were dropped during statistical transformation: {.field {glue_collapse(dropped, sep = ', ')}}\",  #>             i = \"This can happen when ggplot fails to infer the correct grouping structure in the data.\",  #>             i = \"Did you forget to specify a {.code group} aesthetic or to convert a numerical variable into a factor?\")) #>     } #>     data_new <- vec_rbind0(!!!stats) #>     data_new[, !names(data_new) %in% non_constant_columns, drop = FALSE] #> } #> <environment: 0x0000015e3a4fb6c8>  # Captured argument defaults are again available for inspection via `formals()` # Note that arguments passed to the `...` are promoted to function arguments names(ggformals(Stat$compute_panel)) #> [1] \"self\"   \"data\"   \"scales\" \"...\"    names(formals(p3_compute_panel)) #>  [1] \"self\"        \"data\"        \"scales\"      \"method\"      \"formula\"     #>  [6] \"se\"          \"n\"           \"fullrange\"   \"level\"       \"na.rm\"       #> [11] \"method.args\" \"span\"        \"flipped_aes\"  # It works the same otherwise - plus you get the benefit of autocomplete head(p3_compute_panel()) #>          x        y     ymin     ymax        se flipped_aes PANEL group #> 1 1.000000 2.932039 2.656568 3.207510 0.1402053       FALSE     1    -1 #> 2 1.050633 2.928156 2.671397 3.184915 0.1306815       FALSE     1    -1 #> 3 1.101266 2.924475 2.681907 3.167044 0.1234590       FALSE     1    -1 #> 4 1.151899 2.920997 2.688081 3.153914 0.1185468       FALSE     1    -1 #> 5 1.202532 2.917722 2.690122 3.145322 0.1158405       FALSE     1    -1 #> 6 1.253165 2.914649 2.688468 3.140830 0.1151184       FALSE     1    -1 head(p3_compute_panel(level = .99)[, c(\"ymin\", \"ymax\")]) #>       ymin     ymax #> 1 2.569496 3.294582 #> 2 2.590240 3.266072 #> 3 2.605235 3.243716 #> 4 2.614459 3.227536 #> 5 2.618182 3.217263 #> 6 2.616976 3.212323 head(p3_compute_panel(flipped_aes = TRUE)) #>          y        x     xmin     xmax        se flipped_aes PANEL group #> 1 1.000000 2.809524 2.533395 3.085653 0.1405400        TRUE     1    -1 #> 2 1.050633 2.844813 2.587716 3.101911 0.1308538        TRUE     1    -1 #> 3 1.101266 2.878797 2.636755 3.120838 0.1231908        TRUE     1    -1 #> 4 1.151899 2.911475 2.680469 3.142480 0.1175739        TRUE     1    -1 #> 5 1.202532 2.942847 2.718976 3.166717 0.1139424        TRUE     1    -1 #> 6 1.253165 2.972913 2.752581 3.193245 0.1121416        TRUE     1    -1  # Interactively explore with `debugonce(attr(p3_compute_panel, \"inner\"))`"},{"path":"/reference/ggtrace_capture_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"Returns ggproto method function arguments pre-filled values upon entering function.","code":""},{"path":"/reference/ggtrace_capture_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"","code":"ggtrace_capture_method(x, ...)"},{"path":"/reference/ggtrace_capture_method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"x ggplot object ... Passed ggtrace(). usecases, suffices just provide ggproto method method argument.","code":""},{"path":"/reference/ggtrace_capture_method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"function","code":""},{"path":"/reference/ggtrace_capture_method.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"methods take ..., arguments passed ... runtime, captured stored .dots_captured argument returned function, accessible via formals(x)$.dots_captured. returned function also expose ..., defaults .dots_captured passed captured method unless also provided ...","code":""},{"path":"/reference/ggtrace_capture_method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"","code":"library(ggplot2)  set.seed(47) df <- as.data.frame(matrix(sample(5, 50, TRUE), ncol = 2)) df #>    V1 V2 #> 1   3  5 #> 2   1  5 #> 3   2  4 #> 4   4  1 #> 5   1  5 #> 6   2  5 #> 7   5  1 #> 8   1  5 #> 9   5  2 #> 10  4  1 #> 11  5  3 #> 12  5  5 #> 13  4  3 #> 14  3  3 #> 15  3  5 #> 16  4  3 #> 17  1  1 #> 18  5  2 #> 19  2  5 #> 20  5  2 #> 21  2  2 #> 22  5  3 #> 23  3  5 #> 24  3  2 #> 25  1  3  p1 <- ggplot(df, aes(x = V1, y = V2)) + stat_summary(orientation = \"x\") p1 #> No summary function supplied, defaulting to `mean_se()`   p1_compute_panel <- ggtrace_capture_method(p1, method = StatSummary$compute_panel)  # `p1_compute_panel` is a copy of the ggproto method body(p1_compute_panel) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> } ggbody(StatSummary$compute_panel, as.list = FALSE) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> }  # Its arguments are pre-filled (captured at runtime) formals(p1_compute_panel) #> $data #>    x y PANEL group #> 1  3 5     1    -1 #> 2  1 5     1    -1 #> 3  2 4     1    -1 #> 4  4 1     1    -1 #> 5  1 5     1    -1 #> 6  2 5     1    -1 #> 7  5 1     1    -1 #> 8  1 5     1    -1 #> 9  5 2     1    -1 #> 10 4 1     1    -1 #> 11 5 3     1    -1 #> 12 5 5     1    -1 #> 13 4 3     1    -1 #> 14 3 3     1    -1 #> 15 3 5     1    -1 #> 16 4 3     1    -1 #> 17 1 1     1    -1 #> 18 5 2     1    -1 #> 19 2 5     1    -1 #> 20 5 2     1    -1 #> 21 2 2     1    -1 #> 22 5 3     1    -1 #> 23 3 5     1    -1 #> 24 3 2     1    -1 #> 25 1 3     1    -1 #>  #> $scales #> $scales$x #> <ScaleContinuousPosition> #>  Range:     1 --    5 #>  Limits:    1 --    5 #>  #> $scales$y #> <ScaleContinuousPosition> #>  Range:  1.42 -- 4.71 #>  Limits: 1.42 -- 4.71 #>  #>  #> $fun.data #> NULL #>  #> $fun #> NULL #>  #> $fun.max #> NULL #>  #> $fun.min #> NULL #>  #> $fun.args #> list() #>  #> $na.rm #> [1] FALSE #>  #> $flipped_aes #> [1] FALSE #>   # Runs as it should p1_compute_panel() #> No summary function supplied, defaulting to `mean_se()` #>   x group        y     ymin     ymax PANEL flipped_aes #> 1 1    -1 3.800000 3.000000 4.600000     1       FALSE #> 2 2    -1 4.000000 3.292893 4.707107     1       FALSE #> 3 3    -1 4.000000 3.367544 4.632456     1       FALSE #> 4 4    -1 2.000000 1.422650 2.577350     1       FALSE #> 5 5    -1 2.571429 2.090500 3.052357     1       FALSE  # You can inspect changes to its behavior outisde of ggplot # For example, see what happens when aes is flipped via `orientation = \"y\"` p1_compute_panel(flipped_aes = TRUE) #> No summary function supplied, defaulting to `mean_se()` #>   y group        x     xmin     xmax PANEL flipped_aes #> 1 1    -1 3.500000 2.633975 4.366025     1        TRUE #> 2 2    -1 4.000000 3.367544 4.632456     1        TRUE #> 3 3    -1 3.666667 3.052030 4.281303     1        TRUE #> 4 4    -1 2.000000       NA       NA     1        TRUE #> 5 5    -1 2.333333 1.892375 2.774292     1        TRUE  # We confirm this output to be true when `orientation = \"y\"` p2 <- ggplot(df, aes(x = V1, y = V2)) + stat_summary(orientation = \"y\") p2_compute_panel <- ggtrace_capture_method(p2, method = StatSummary$compute_panel) #> Warning: Removed 1 rows containing missing values (geom_segment).  identical(p1_compute_panel(flipped_aes = TRUE), p2_compute_panel()) #> No summary function supplied, defaulting to `mean_se()` #> No summary function supplied, defaulting to `mean_se()` #> [1] TRUE   # Note that the captured method looks slightly different if the method takes `...` p3 <- ggplot(df, aes(x = V1, y = V2)) + stat_smooth() + geom_jitter() p3 #> `geom_smooth()` using method = 'loess' and formula 'y ~ x'   p3_compute_panel <- ggtrace_capture_method(p3, method = Stat$compute_panel)  # For one, the body is different body(p3_compute_panel) #> { #>     cur_args <- mget(names(formals(rlang::current_fn()))) #>     specs <- names(cur_args) %in% names(formals(inner)) #>     do.call(inner, c(cur_args[specs], cur_args[!specs])) #> }  # The captured method is called internally, stored in the `\"inner\"` attribute attr(p3_compute_panel, \"inner\") #> function (self, data, scales, ...)  #> { #>     if (empty(data))  #>         return(new_data_frame()) #>     groups <- split(data, data$group) #>     stats <- lapply(groups, function(group) { #>         self$compute_group(data = group, scales = scales, ...) #>     }) #>     stats <- mapply(function(new, old) { #>         if (empty(new))  #>             return(new_data_frame()) #>         unique <- uniquecols(old) #>         missing <- !(names(unique) %in% names(new)) #>         cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #>     }, stats, groups, SIMPLIFY = FALSE) #>     rbind_dfs(stats) #> } #> <environment: 0x00000000395196f0>  # Captured arguments are again stored in the formals of the function # Note that arguments passed to the `...` are promoted to function arguments names(formals(p3_compute_panel)) #>  [1] \"self\"        \"data\"        \"scales\"      \"method\"      \"formula\"     #>  [6] \"se\"          \"n\"           \"fullrange\"   \"level\"       \"na.rm\"       #> [11] \"method.args\" \"span\"        \"flipped_aes\" names(ggformals(Stat$compute_panel)) #> [1] \"self\"   \"data\"   \"scales\" \"...\"     # It works the same otherwise - plus you get the benefit of autocomplete head(p3_compute_panel()) #>          x        y     ymin     ymax        se flipped_aes PANEL group #> 1 1.000000 3.800000 2.456618 5.143382 0.6437060       FALSE     1    -1 #> 2 1.050633 3.814934 2.562634 5.067233 0.6000623       FALSE     1    -1 #> 3 1.101266 3.829354 2.645742 5.012967 0.5671495       FALSE     1    -1 #> 4 1.151899 3.843262 2.705881 4.980643 0.5449968       FALSE     1    -1 #> 5 1.202532 3.856658 2.744115 4.969200 0.5330951       FALSE     1    -1 #> 6 1.253165 3.869540 2.762657 4.976424 0.5303834       FALSE     1    -1 head(p3_compute_panel(level = .99)[, c(\"ymin\", \"ymax\")]) #>       ymin     ymax #> 1 1.967038 5.632962 #> 2 2.106247 5.523620 #> 3 2.214388 5.444321 #> 4 2.291376 5.395149 #> 5 2.338661 5.374654 #> 6 2.359266 5.379815 head(p3_compute_panel(flipped_aes = TRUE)) #>          y        x     xmin     xmax        se flipped_aes PANEL group #> 1 1.000000 3.486913 1.996579 4.977247 0.7148639        TRUE     1    -1 #> 2 1.050633 3.537510 2.136220 4.938801 0.6721527        TRUE     1    -1 #> 3 1.101266 3.585828 2.263181 4.908476 0.6344304        TRUE     1    -1 #> 4 1.151899 3.631850 2.377468 4.886232 0.6016854        TRUE     1    -1 #> 5 1.202532 3.675558 2.479204 4.871912 0.5738514        TRUE     1    -1 #> 6 1.253165 3.716935 2.568654 4.865215 0.5507921        TRUE     1    -1"},{"path":"/reference/ggtrace_highjack_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Highjack a method's execution and modify its argument values — ggtrace_highjack_args","title":"Highjack a method's execution and modify its argument values — ggtrace_highjack_args","text":"Highjack method's execution modify argument values","code":""},{"path":"/reference/ggtrace_highjack_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Highjack a method's execution and modify its argument values — ggtrace_highjack_args","text":"","code":"ggtrace_highjack_args(x, method, cond = 1L, values, draw = TRUE)"},{"path":"/reference/ggtrace_highjack_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Highjack a method's execution and modify its argument values — ggtrace_highjack_args","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond return value replaced. Defaults 1L. values named list variable-value pairings. values expressions, evaluated formals. draw Whether draw modified graphical output evaluating x. Defaults TRUE.","code":""},{"path":"/reference/ggtrace_highjack_args.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Highjack a method's execution and modify its argument values — ggtrace_highjack_args","text":"gtable object class <ggtrace_highjacked>","code":""},{"path":"/reference/ggtrace_highjack_args.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Highjack a method's execution and modify its argument values — ggtrace_highjack_args","text":"quoted expressions passed cond value argument workflow functions evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ increments every time function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1L) evaluated TRUE method called first time. cond argument also supports numeric shorthands like cond = 1L evaluates quote(._counter_ == 1L), default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). recommended consult output ggtrace_inspect_n() ggtrace_inspect_which() construct expressions condition ._counter_. highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/ggtrace_highjack_args.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Highjack a method's execution and modify its argument values — ggtrace_highjack_args","text":"","code":"set.seed(1116) library(ggplot2) library(dplyr)   p <- ggplot(mtcars, aes(mpg, hp, color = factor(cyl))) +   geom_point() +   geom_smooth(method = \"lm\") p #> `geom_smooth()` using formula = 'y ~ x'   # Fit predictions from loess regression just for second group ggtrace_highjack_args(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$group[1] == 2),   values = list(method = \"loess\") ) #> `geom_smooth()` using formula = 'y ~ x'   # If value is an expression, it's evaluated in the Tracing Context ggtrace_highjack_args(   x = p,   method = StatSmooth$compute_group,   values = rlang::exprs(      # Every time the method is called, call it with a bigger CI     level = ._counter_ * 0.3,      # Fit models to just a random sample of the data     data = data %>%       slice_sample(prop = .8)    ) ) #> `geom_smooth()` using formula = 'y ~ x'"},{"path":"/reference/ggtrace_highjack_return.html","id":null,"dir":"Reference","previous_headings":"","what":"Highjack a method's execution and make it return a user-supplied value — ggtrace_highjack_return","title":"Highjack a method's execution and make it return a user-supplied value — ggtrace_highjack_return","text":"Highjack method's execution make return user-supplied value","code":""},{"path":"/reference/ggtrace_highjack_return.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Highjack a method's execution and make it return a user-supplied value — ggtrace_highjack_return","text":"","code":"ggtrace_highjack_return(   x,   method,   cond = 1L,   value = quote(returnValue()),   draw = TRUE )"},{"path":"/reference/ggtrace_highjack_return.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Highjack a method's execution and make it return a user-supplied value — ggtrace_highjack_return","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond return value replaced. Defaults 1L. value method return instead. Defaults quote(returnValue()). draw Whether draw modified graphical output evaluating x. Defaults TRUE.","code":""},{"path":"/reference/ggtrace_highjack_return.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Highjack a method's execution and make it return a user-supplied value — ggtrace_highjack_return","text":"gtable object class <ggtrace_highjacked>","code":""},{"path":"/reference/ggtrace_highjack_return.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Highjack a method's execution and make it return a user-supplied value — ggtrace_highjack_return","text":"quoted expressions passed cond value argument workflow functions evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ increments every time function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1L) evaluated TRUE method called first time. cond argument also supports numeric shorthands like cond = 1L evaluates quote(._counter_ == 1L), default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). recommended consult output ggtrace_inspect_n() ggtrace_inspect_which() construct expressions condition ._counter_. highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/ggtrace_highjack_return.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Highjack a method's execution and make it return a user-supplied value — ggtrace_highjack_return","text":"","code":"set.seed(1116) library(ggplot2) library(dplyr)   p1 <- ggplot(diamonds, aes(cut)) +   geom_bar(aes(fill = cut)) +   facet_wrap(~ clarity)  p1   # Highjack `Stat$compute_panel` at the first panel # to return higher values for `count` ggtrace_highjack_return(   x = p1, method = Stat$compute_panel,   value = quote({     returnValue() %>%       mutate(count = count * 100)   }) )   # Highjack `Stat$compute_panel` at the fourth panel # to shuffle bars in the x-axis ggtrace_highjack_return(   x = p1, method = Stat$compute_panel,   cond = quote(data$PANEL[1] == 4),   value = quote({     returnValue() %>%       mutate(x = sample(x))   }) )   # Bars get a black outline and get darker from left-to-right, but only for second panel ggtrace_highjack_return(   x = p1, method = GeomBar$draw_panel,   cond = quote(data$PANEL[1] == 2),   value = quote({     editGrob(returnValue(), gp = gpar(       col = \"black\", alpha = seq(0.2, 1, length.out = nrow(data)     )))   }) )"},{"path":"/reference/ggtrace_inspect_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect the arguments passed into a method — ggtrace_inspect_args","title":"Inspect the arguments passed into a method — ggtrace_inspect_args","text":"Inspect arguments passed method","code":""},{"path":"/reference/ggtrace_inspect_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect the arguments passed into a method — ggtrace_inspect_args","text":"","code":"ggtrace_inspect_args(x, method, cond = 1L, hoist_dots = TRUE, error = FALSE)"},{"path":"/reference/ggtrace_inspect_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect the arguments passed into a method — ggtrace_inspect_args","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond arguments inspected. Defaults 1L. hoist_dots Whether treat arguments passed ... like regular arguments. FALSE, ... treated argument error TRUE, continues inspecting method ggplot errors. useful debugging note can sometimes return incomplete output.","code":""},{"path":"/reference/ggtrace_inspect_args.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inspect the arguments passed into a method — ggtrace_inspect_args","text":"list argument-value pairs method called.","code":""},{"path":"/reference/ggtrace_inspect_args.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Inspect the arguments passed into a method — ggtrace_inspect_args","text":"quoted expressions passed cond value argument workflow functions evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ increments every time function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1L) evaluated TRUE method called first time. cond argument also supports numeric shorthands like cond = 1L evaluates quote(._counter_ == 1L), default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). recommended consult output ggtrace_inspect_n() ggtrace_inspect_which() construct expressions condition ._counter_. highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/ggtrace_inspect_args.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inspect the arguments passed into a method — ggtrace_inspect_args","text":"","code":"library(ggplot2)  p1 <- ggplot(diamonds, aes(cut)) +   geom_bar(aes(fill = cut)) +   facet_wrap(~ clarity)  p1   # Argument value of `Stat$compute_panel` for the first panel compute_panel_args_1 <- ggtrace_inspect_args(x = p1, method = Stat$compute_panel) names(ggformals(Stat$compute_panel)) #> [1] \"self\"   \"data\"   \"scales\" \"...\"    names(compute_panel_args_1) #> [1] \"self\"        \"data\"        \"scales\"      \"width\"       \"flipped_aes\" table(compute_panel_args_1$data$fill) #>  #>      Fair      Good Very Good   Premium     Ideal  #>       210        96        84       205       146   # `hoist_dots` preserves information about which arguments were passed to `...` with_dots <- ggtrace_inspect_args(p1, Stat$compute_panel, hoist_dots = FALSE) names(with_dots) #> [1] \"self\"   \"data\"   \"scales\" \"...\"    with_dots$`...` #> $width #> [1] 0.9 #>  #> $flipped_aes #> [1] FALSE #>"},{"path":"/reference/ggtrace_inspect_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect how many times a method was called — ggtrace_inspect_n","title":"Inspect how many times a method was called — ggtrace_inspect_n","text":"Inspect many times method called","code":""},{"path":"/reference/ggtrace_inspect_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect how many times a method was called — ggtrace_inspect_n","text":"","code":"ggtrace_inspect_n(x, method, error = FALSE)"},{"path":"/reference/ggtrace_inspect_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect how many times a method was called — ggtrace_inspect_n","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method error TRUE, continues inspecting method ggplot errors. useful debugging note can sometimes return incomplete output.","code":""},{"path":"/reference/ggtrace_inspect_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inspect how many times a method was called — ggtrace_inspect_n","text":"number times method called evaluation x","code":""},{"path":"/reference/ggtrace_inspect_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inspect how many times a method was called — ggtrace_inspect_n","text":"","code":"library(ggplot2)  p1 <- ggplot(diamonds, aes(cut)) +   geom_bar(aes(fill = cut)) +   facet_wrap(~ clarity)  p1   # 1 call to Stat$compute_layer ggtrace_inspect_n(p1, Stat$compute_layer) #> [1] 1  # 8 calls to Stat$compute_panel ggtrace_inspect_n(p1, Stat$compute_panel) #> [1] 8  # Note that there are 0 calls to Stat$compute_group ... ggtrace_inspect_n(p1, Stat$compute_group) #> [1] 0  # because StatCount has its own \"compute_group\" method defined ggtrace_inspect_n(p1, StatCount$compute_group) #> [1] 40  # How about if we add a second layer that uses StatCount? p2 <- p1 + geom_text(   aes(label = after_stat(count)),   stat = StatCount, position = position_nudge(y = 500) )  p2   # Now there are double the calls to Stat/StatCount methods ggtrace_inspect_n(p2, Stat$compute_layer) #> [1] 2 ggtrace_inspect_n(p2, Stat$compute_panel) #> [1] 16 ggtrace_inspect_n(p2, StatCount$compute_group) #> [1] 80  # But separate calls to each layer's respective Geoms ggtrace_inspect_n(p2, GeomBar$draw_panel) #> [1] 8 ggtrace_inspect_n(p2, GeomText$draw_panel) #> [1] 8"},{"path":"/reference/ggtrace_inspect_on_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Get information about a ggproto method on error — ggtrace_inspect_on_error","title":"Get information about a ggproto method on error — ggtrace_inspect_on_error","text":"Get information ggproto method error","code":""},{"path":"/reference/ggtrace_inspect_on_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get information about a ggproto method on error — ggtrace_inspect_on_error","text":"","code":"ggtrace_inspect_on_error(x, method)"},{"path":"/reference/ggtrace_inspect_on_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get information about a ggproto method on error — ggtrace_inspect_on_error","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method","code":""},{"path":"/reference/ggtrace_inspect_on_error.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get information about a ggproto method on error — ggtrace_inspect_on_error","text":"list three elements: counter, args, env.","code":""},{"path":"/reference/ggtrace_inspect_on_error.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get information about a ggproto method on error — ggtrace_inspect_on_error","text":"","code":"if (FALSE) { # interactive() library(ggplot2) erroring_barplot <- ggplot(mtcars, aes(mpg, hp)) +   stat_summary() +   geom_bar() ggtrace_inspect_on_error(erroring_barplot, StatCount$setup_params) ggtrace_inspect_on_error(erroring_barplot, ggplot2:::Layer$compute_statistic) }"},{"path":"/reference/ggtrace_inspect_return.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect the return value of a method — ggtrace_inspect_return","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"Inspect return value method","code":""},{"path":"/reference/ggtrace_inspect_return.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"","code":"ggtrace_inspect_return(x, method, cond = 1L, error = FALSE)"},{"path":"/reference/ggtrace_inspect_return.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond return value inspected. Defaults 1L. error TRUE, continues inspecting method ggplot errors. useful debugging note can sometimes return incomplete output.","code":""},{"path":"/reference/ggtrace_inspect_return.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"return value method called.","code":""},{"path":"/reference/ggtrace_inspect_return.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"quoted expressions passed cond value argument workflow functions evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ increments every time function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1L) evaluated TRUE method called first time. cond argument also supports numeric shorthands like cond = 1L evaluates quote(._counter_ == 1L), default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). recommended consult output ggtrace_inspect_n() ggtrace_inspect_which() construct expressions condition ._counter_. highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/ggtrace_inspect_return.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"","code":"library(ggplot2)  p1 <- ggplot(diamonds, aes(cut)) +   geom_bar(aes(fill = cut)) +   facet_wrap(~ clarity)  p1   # Return value of `Stat$compute_panel` for the first panel ggtrace_inspect_return(x = p1, method = Stat$compute_panel) #>   count prop x width flipped_aes      fill PANEL group #> 1   210    1 1   0.9       FALSE      Fair     1     1 #> 2    96    1 2   0.9       FALSE      Good     1     2 #> 3    84    1 3   0.9       FALSE Very Good     1     3 #> 4   205    1 4   0.9       FALSE   Premium     1     4 #> 5   146    1 5   0.9       FALSE     Ideal     1     5  # Return value for 4th panel ggtrace_inspect_return(x = p1, method = Stat$compute_panel,                        cond = 4L) #>   count prop x width flipped_aes      fill PANEL group #> 1   261    1 1   0.9       FALSE      Fair     4     1 #> 2   978    1 2   0.9       FALSE      Good     4     2 #> 3  2591    1 3   0.9       FALSE Very Good     4     3 #> 4  3357    1 4   0.9       FALSE   Premium     4     4 #> 5  5071    1 5   0.9       FALSE     Ideal     4     5  # Return value for 4th panel, 2nd group (bar) ggtrace_inspect_return(   x = p1, method = StatCount$compute_group,   cond = quote(data$PANEL[1] == 4 && data$group[1] == 2) ) #>   count prop x width flipped_aes #> 1   978    1 2   0.9       FALSE"},{"path":"/reference/ggtrace_inspect_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect the value of variables from a method — ggtrace_inspect_vars","title":"Inspect the value of variables from a method — ggtrace_inspect_vars","text":"Inspect value variables method","code":""},{"path":"/reference/ggtrace_inspect_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect the value of variables from a method — ggtrace_inspect_vars","text":"","code":"ggtrace_inspect_vars(   x,   method,   cond = 1L,   at = \"all\",   vars,   by_var = TRUE,   error = FALSE )"},{"path":"/reference/ggtrace_inspect_vars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect the value of variables from a method — ggtrace_inspect_vars","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond return value inspected. Defaults 1L. steps method body values vars retrieved. Defaults special value evaluated steps method body. vars character vector variable names by_var Boolean controls format output: TRUE (default): returns list variables, values step. also drops steps within variable variable value changed previous step specified . FALSE: returns list steps, element holds value vars step . Unchanged variable values dropped. error TRUE, continues inspecting method ggplot errors. useful debugging note can sometimes return incomplete output.","code":""},{"path":"/reference/ggtrace_inspect_vars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inspect the value of variables from a method — ggtrace_inspect_vars","text":"list values vars step . Simplifies vars /length-1.","code":""},{"path":"/reference/ggtrace_inspect_vars.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Inspect the value of variables from a method — ggtrace_inspect_vars","text":"quoted expressions passed cond value argument workflow functions evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ increments every time function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1L) evaluated TRUE method called first time. cond argument also supports numeric shorthands like cond = 1L evaluates quote(._counter_ == 1L), default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). recommended consult output ggtrace_inspect_n() ggtrace_inspect_which() construct expressions condition ._counter_. highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/ggtrace_inspect_vars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inspect the value of variables from a method — ggtrace_inspect_vars","text":"","code":"library(ggplot2)  p1 <- ggplot(mtcars[1:10,], aes(mpg, hp)) +   geom_smooth() p1 #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'   # The `data` variable is bound to two unique values in `compute_group` method: ggtrace_inspect_vars(p1, StatSmooth$compute_group, vars = \"data\") #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x' #> $Step1 #>       x   y PANEL group #> 1  21.0 110     1    -1 #> 2  21.0 110     1    -1 #> 3  22.8  93     1    -1 #> 4  21.4 110     1    -1 #> 5  18.7 175     1    -1 #> 6  18.1 105     1    -1 #> 7  14.3 245     1    -1 #> 8  24.4  62     1    -1 #> 9  22.8  95     1    -1 #> 10 19.2 123     1    -1 #>  #> $Step5 #>       x   y PANEL group weight #> 1  21.0 110     1    -1      1 #> 2  21.0 110     1    -1      1 #> 3  22.8  93     1    -1      1 #> 4  21.4 110     1    -1      1 #> 5  18.7 175     1    -1      1 #> 6  18.1 105     1    -1      1 #> 7  14.3 245     1    -1      1 #> 8  24.4  62     1    -1      1 #> 9  22.8  95     1    -1      1 #> 10 19.2 123     1    -1      1 #>   # Note that elements of this list capture the method's state upon entering a step, # so \"Step1\" and \"Step5\" should be interpreted as the value of `data` at the start # the method's execution (before \"Step1\") and its value as a result of running Step4 # (before \"Step5\"). Indeed, we see that the `weight` column is defined in Step4, so # the data is flagged as changed at the start of Step5 ggbody(StatSmooth$compute_group)[[4]] #> if (is.null(data$weight)) data$weight <- 1   # Comparing the \"Steps\" themselves can be useful p2 <- p1 +   scale_x_continuous(trans = \"log\") +   scale_y_continuous(trans = \"log\") p2 #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'   # Comparing the original plot to one with log-transformed scales reveals a change # in data detected at the beginning of Step 14 names(ggtrace_inspect_vars(p1, ggplot2:::ggplot_build.ggplot, vars = \"data\")) #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x' #> [1] \"Step6\"  \"Step8\"  \"Step11\" \"Step12\" \"Step18\" \"Step29\" names(ggtrace_inspect_vars(p2, ggplot2:::ggplot_build.ggplot, vars = \"data\")) #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x' #> [1] \"Step6\"  \"Step8\"  \"Step11\" \"Step12\" \"Step13\" \"Step18\" \"Step29\"  # We can pinpoint the calculation of scale transformations to Step 13: ggbody(ggplot2:::ggplot_build.ggplot)[[13]] #> scale_x <- function() scales$get_scales(\"x\")   # With `by_vars = FALSE`, elements of the returned list are steps instead of values. # Note that this does not drop unchanged values: ggtrace_inspect_vars(p1, StatSmooth$compute_group, vars = \"data\", at = 1:6, by_var = FALSE) #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x' #> $Step1 #> $Step1$data #>       x   y PANEL group #> 1  21.0 110     1    -1 #> 2  21.0 110     1    -1 #> 3  22.8  93     1    -1 #> 4  21.4 110     1    -1 #> 5  18.7 175     1    -1 #> 6  18.1 105     1    -1 #> 7  14.3 245     1    -1 #> 8  24.4  62     1    -1 #> 9  22.8  95     1    -1 #> 10 19.2 123     1    -1 #>  #>  #> $Step2 #> $Step2$data #>       x   y PANEL group #> 1  21.0 110     1    -1 #> 2  21.0 110     1    -1 #> 3  22.8  93     1    -1 #> 4  21.4 110     1    -1 #> 5  18.7 175     1    -1 #> 6  18.1 105     1    -1 #> 7  14.3 245     1    -1 #> 8  24.4  62     1    -1 #> 9  22.8  95     1    -1 #> 10 19.2 123     1    -1 #>  #>  #> $Step3 #> $Step3$data #>       x   y PANEL group #> 1  21.0 110     1    -1 #> 2  21.0 110     1    -1 #> 3  22.8  93     1    -1 #> 4  21.4 110     1    -1 #> 5  18.7 175     1    -1 #> 6  18.1 105     1    -1 #> 7  14.3 245     1    -1 #> 8  24.4  62     1    -1 #> 9  22.8  95     1    -1 #> 10 19.2 123     1    -1 #>  #>  #> $Step4 #> $Step4$data #>       x   y PANEL group #> 1  21.0 110     1    -1 #> 2  21.0 110     1    -1 #> 3  22.8  93     1    -1 #> 4  21.4 110     1    -1 #> 5  18.7 175     1    -1 #> 6  18.1 105     1    -1 #> 7  14.3 245     1    -1 #> 8  24.4  62     1    -1 #> 9  22.8  95     1    -1 #> 10 19.2 123     1    -1 #>  #>  #> $Step5 #> $Step5$data #>       x   y PANEL group weight #> 1  21.0 110     1    -1      1 #> 2  21.0 110     1    -1      1 #> 3  22.8  93     1    -1      1 #> 4  21.4 110     1    -1      1 #> 5  18.7 175     1    -1      1 #> 6  18.1 105     1    -1      1 #> 7  14.3 245     1    -1      1 #> 8  24.4  62     1    -1      1 #> 9  22.8  95     1    -1      1 #> 10 19.2 123     1    -1      1 #>  #>  #> $Step6 #> $Step6$data #>       x   y PANEL group weight #> 1  21.0 110     1    -1      1 #> 2  21.0 110     1    -1      1 #> 3  22.8  93     1    -1      1 #> 4  21.4 110     1    -1      1 #> 5  18.7 175     1    -1      1 #> 6  18.1 105     1    -1      1 #> 7  14.3 245     1    -1      1 #> 8  24.4  62     1    -1      1 #> 9  22.8  95     1    -1      1 #> 10 19.2 123     1    -1      1 #>  #>"},{"path":"/reference/ggtrace_inspect_which.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect which calls to a ggproto method met a particular condition — ggtrace_inspect_which","title":"Inspect which calls to a ggproto method met a particular condition — ggtrace_inspect_which","text":"Inspect calls ggproto method met particular condition","code":""},{"path":"/reference/ggtrace_inspect_which.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect which calls to a ggproto method met a particular condition — ggtrace_inspect_which","text":"","code":"ggtrace_inspect_which(x, method, cond, error = FALSE)"},{"path":"/reference/ggtrace_inspect_which.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect which calls to a ggproto method met a particular condition — ggtrace_inspect_which","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond Expression evaluating logical inside method x evaluated. error TRUE, continues inspecting method ggplot errors. useful debugging note can sometimes return incomplete output.","code":""},{"path":"/reference/ggtrace_inspect_which.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inspect which calls to a ggproto method met a particular condition — ggtrace_inspect_which","text":"values tracing context variable ._counter_ cond evaluated TRUE.","code":""},{"path":"/reference/ggtrace_inspect_which.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Inspect which calls to a ggproto method met a particular condition — ggtrace_inspect_which","text":"quoted expressions passed cond value argument workflow functions evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ increments every time function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1L) evaluated TRUE method called first time. cond argument also supports numeric shorthands like cond = 1L evaluates quote(._counter_ == 1L), default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). recommended consult output ggtrace_inspect_n() ggtrace_inspect_which() construct expressions condition ._counter_. highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/ggtrace_inspect_which.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inspect which calls to a ggproto method met a particular condition — ggtrace_inspect_which","text":"","code":"library(ggplot2)  p1 <- ggplot(diamonds, aes(cut)) +   geom_bar(aes(fill = cut)) +   facet_wrap(~ clarity) p1    # Values of `._counter_` when `compute_group` is called for groups in the second panel: ggtrace_inspect_which(p1, StatCount$compute_group, quote(data$PANEL[1] == 2)) #> [1]  6  7  8  9 10   # How about if we add a second layer that uses StatCount? p2 <- p1 + geom_text(   aes(label = after_stat(count)),   stat = StatCount, position = position_nudge(y = 500) ) p2   ggtrace_inspect_which(p2, StatCount$compute_group, quote(data$PANEL[1] == 2)) #>  [1]  6  7  8  9 10 46 47 48 49 50   # Behaves like `base::which()` and returns `integer(0)` when no matches are found ggtrace_inspect_which(p2, StatBoxplot$compute_group, quote(data$PANEL[1] == 2)) #> integer(0)"},{"path":"/reference/ggtrace_modify_return.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify the return value of a method — ggtrace_modify_return","title":"Modify the return value of a method — ggtrace_modify_return","text":"Modify return value method","code":""},{"path":"/reference/ggtrace_modify_return.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify the return value of a method — ggtrace_modify_return","text":"","code":"ggtrace_modify_return(x, method, value, cond = TRUE, draw = TRUE)"},{"path":"/reference/ggtrace_modify_return.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify the return value of a method — ggtrace_modify_return","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method value Value method return called cond return value replaced draw Whether draw modified plot","code":""},{"path":"/reference/ggtrace_modify_return.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modify the return value of a method — ggtrace_modify_return","text":"gtable object class <ggtrace_modified>","code":""},{"path":"/reference/gguntrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove any existing traces — gguntrace","title":"Remove any existing traces — gguntrace","text":"Used explicitly calling untrace() ggproto object.","code":""},{"path":"/reference/gguntrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove any existing traces — gguntrace","text":"","code":"gguntrace(method, ...)"},{"path":"/reference/gguntrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove any existing traces — gguntrace","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Ignored. Designed ease calling function modifying call earlier {ggtrace} function interactive contexts.","code":""},{"path":"/reference/gguntrace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove any existing traces — gguntrace","text":"Unlike base::untrace(), adverse side effect repeatedly calling gguntrace() ggproto method. gguntrace() throw error method found. method valid, gguntrace() one two things: Inform successfully removed trace (untracing) Inform existing trace (nothing)","code":""},{"path":[]},{"path":"/reference/gguntrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove any existing traces — gguntrace","text":"","code":"library(ggplot2)  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` not currently being traced.  is_traced(Stat$compute_layer) #> [1] FALSE  ggtrace(Stat$compute_layer, 1) #> `Stat$compute_layer` now being traced.  is_traced(Stat$compute_layer) #> [1] TRUE  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` no longer being traced.  is_traced(Stat$compute_layer) #> [1] FALSE  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` not currently being traced."},{"path":"/reference/global_ggtrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"global_ggtrace() list trace dumps collected across multiple traces, recommended use ggtrace(= FALSE) expect trace independently triggered multiple times (example, tracing (compute/draw)_group method multiple groups, plot multiple layers call method traced).","code":""},{"path":"/reference/global_ggtrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"","code":"global_ggtrace()  set_global_ggtrace(value)  clear_global_ggtrace()  global_ggtrace_state(state)  global_ggtrace_on()  global_ggtrace_off()"},{"path":"/reference/global_ggtrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"state missing, returns whether global tracedump currently active. global tracedump inactive default (state FALSE). activated, every time trace created ggtrace() triggered tracedump added global tracedump storage, can inspected global_ggtrace(). global tracedump can turned /setting state TRUE/FALSE.","code":""},{"path":"/reference/global_ggtrace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"List logical indicating current state global trace dump. state provided, changes state first, returns state invisibly.","code":""},{"path":"/reference/global_ggtrace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"clear_global_ggtrace() sets value global_ggtrace() NULL returns NULL. can inspect state global trace dump global_ggtrace_state() activate deactivate global_ggtrace_on() global_ggtrace_off(), aliases global_ggtrace_state(TRUE) global_ggtrace_state(FALSE), respectively.","code":""},{"path":"/reference/global_ggtrace.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"trace dump pushed global_ggtrace(), gets named ggproto method hex code identifying method's runtime environment, e.g. \"Stat$compute_layer-00000267437FD3D8\".","code":""},{"path":[]},{"path":"/reference/global_ggtrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"","code":"library(ggplot2)  global_ggtrace_state() # global tracedump is inactive by default since v0.4.3 #> [1] FALSE global_ggtrace_on()    # alias for global_ggtrace_state(TRUE) #> Global tracedump activated. clear_global_ggtrace() #> Global tracedump cleared.  ggtrace(   GeomBoxplot$draw_group,   trace_steps = -1,   once = FALSE,   verbose = FALSE ) #> `GeomBoxplot$draw_group` now being traced. #> Creating a persistent trace. Remember to `gguntrace(GeomBoxplot$draw_group)`!  ggplot(mpg, aes(class, hwy)) + geom_boxplot() #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group`   gguntrace(GeomBoxplot$draw_group) #> `GeomBoxplot$draw_group` no longer being traced.  boxplot_group_tracedump <- global_ggtrace()  length(boxplot_group_tracedump) #> [1] 7  boxplot_group_tracedump <- unlist(   boxplot_group_tracedump,   recursive = FALSE,   use.names = FALSE )  patchwork::wrap_plots(boxplot_group_tracedump, nrow = 1)   clear_global_ggtrace() #> Global tracedump cleared. global_ggtrace() #> NULL  global_ggtrace_off() # alias for global_ggtrace_state(FALSE) #> Global tracedump deactivated."},{"path":"/reference/is_traced.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a method is being traced — is_traced","title":"Check if a method is being traced — is_traced","text":"Check method traced","code":""},{"path":"/reference/is_traced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a method is being traced — is_traced","text":"","code":"is_traced(method)"},{"path":"/reference/is_traced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a method is being traced — is_traced","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method","code":""},{"path":"/reference/is_traced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if a method is being traced — is_traced","text":"logical","code":""},{"path":"/reference/is_traced.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if a method is being traced — is_traced","text":"","code":"library(ggplot2)  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` not currently being traced.  is_traced(Stat$compute_layer) #> [1] FALSE  ggtrace(Stat$compute_layer, 1) #> `Stat$compute_layer` now being traced.  is_traced(Stat$compute_layer) #> [1] TRUE  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` no longer being traced.  is_traced(Stat$compute_layer) #> [1] FALSE  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` not currently being traced."},{"path":"/reference/last_ggtrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","title":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","text":"last_ggtrace() retrieves last trace dump created ggtrace() - .e., last time trace triggered.","code":""},{"path":"/reference/last_ggtrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","text":"","code":"last_ggtrace()  set_last_ggtrace(value)  clear_last_ggtrace()"},{"path":"/reference/last_ggtrace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","text":"List","code":""},{"path":"/reference/last_ggtrace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","text":"tracedump refers output expression evaluated inside traced function trace triggered. context ggtrace(), tracedump list long number step-expression pairs, element output expression (trace_exprs) evaluated step (trace_steps) inside execution environment function ggproto method. clear_last_ggtrace() sets value last_ggtrace() NULL returns NULL.","code":""},{"path":[]},{"path":"/reference/last_ggtrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","text":"","code":"library(ggplot2)  ggtrace(StatSmooth$compute_group, trace_steps = -1, trace_exprs = quote(head(prediction))) #> `StatSmooth$compute_group` now being traced.  ggplot(mtcars, aes(mpg, hp)) + geom_point() + geom_smooth(method = 'lm') #> `geom_smooth()` using formula = 'y ~ x' #> Triggering trace on `StatSmooth$compute_group` #> Untracing `StatSmooth$compute_group` on exit.   last_ggtrace() #> [[1]] #>          x        y     ymin     ymax       se flipped_aes #> 1 10.40000 232.2531 201.8649 262.6414 14.87963       FALSE #> 2 10.69747 229.6265 199.9139 259.3392 14.54880       FALSE #> 3 10.99494 227.0000 197.9569 256.0430 14.22094       FALSE #> 4 11.29241 224.3734 195.9934 252.7534 13.89627       FALSE #> 5 11.58987 221.7468 194.0230 249.4707 13.57502       FALSE #> 6 11.88734 219.1203 192.0450 246.1956 13.25743       FALSE #>   ggtrace(   StatSmooth$compute_group,   trace_steps = -1,   trace_exprs = quote(prediction),   verbose = FALSE ) #> `StatSmooth$compute_group` now being traced.  ggplot(mtcars, aes(mpg, hp)) + geom_point() + geom_smooth(method = 'lm') #> `geom_smooth()` using formula = 'y ~ x' #> Triggering trace on `StatSmooth$compute_group` #> Untracing `StatSmooth$compute_group` on exit.   head(last_ggtrace()[[1]]) #>          x        y     ymin     ymax       se flipped_aes #> 1 10.40000 232.2531 201.8649 262.6414 14.87963       FALSE #> 2 10.69747 229.6265 199.9139 259.3392 14.54880       FALSE #> 3 10.99494 227.0000 197.9569 256.0430 14.22094       FALSE #> 4 11.29241 224.3734 195.9934 252.7534 13.89627       FALSE #> 5 11.58987 221.7468 194.0230 249.4707 13.57502       FALSE #> 6 11.88734 219.1203 192.0450 246.1956 13.25743       FALSE"},{"path":"/reference/last_layer_errorcontext.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the internal context of the last (sub-)layer error — last_layer_errorcontext","title":"Get the internal context of the last (sub-)layer error — last_layer_errorcontext","text":"last_layer_errorcontext() returns error context level Layer ggproto. last_sublayer_errorcontext() (EXPERIMENTAL) returns error context sub-Layer level (e.g., Stat Geom).","code":""},{"path":"/reference/last_layer_errorcontext.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the internal context of the last (sub-)layer error — last_layer_errorcontext","text":"","code":"last_layer_errorcontext(reprint_error = FALSE, ggtrace_notes = TRUE)  last_sublayer_errorcontext(reprint_error = FALSE, ggtrace_notes = TRUE)"},{"path":"/reference/last_layer_errorcontext.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the internal context of the last (sub-)layer error — last_layer_errorcontext","text":"reprint_error Re-prints original error message console. Defaults FALSE. ggtrace_notes Prints ggtrace_inspect_args() call used inspect error context. Defaults TRUE.","code":""},{"path":"/reference/last_layer_errorcontext.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the internal context of the last (sub-)layer error — last_layer_errorcontext","text":"dynamically constructed evaluated call ggtrace_inspect_args(). Prioritizes showing state layer data whenever possible (extracting data argument).","code":""},{"path":"/reference/last_layer_errorcontext.html","id":"scope","dir":"Reference","previous_headings":"","what":"Scope","title":"Get the internal context of the last (sub-)layer error — last_layer_errorcontext","text":"functions can retrieve information errors propagating Layer ggproto methods. non-technical terms, work errors \"Error occured Nth layer\" message ({ggplot2} >= 3.4.0). scope last_sublayer_errorcontext() narrower, since Layer methods call sub-Layer method. function intended developers - cases users can get information necessary debug layer code last_layer_errorcontext() (many ways break ggplot user-facing code).","code":""},{"path":[]},{"path":"/reference/last_layer_errorcontext.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the internal context of the last (sub-)layer error — last_layer_errorcontext","text":"","code":"if (FALSE) { # interactive() library(ggplot2) erroring_barplot1 <- ggplot(mtcars, aes(mpg, hp)) +   stat_summary() +   geom_bar()  # Render to trigger error erroring_barplot1  # Both return the same snapshot of layer data # but at different levels of specificity last_layer_errorcontext() last_sublayer_errorcontext()  erroring_barplot2 <- ggplot(mtcars, aes(mpg, hp)) +   stat_summary() +   geom_bar(aes(y = c(1, 2))) erroring_barplot2  # This works: last_layer_errorcontext() # This doesn't: there's no sub-layer ggproto involved in this error last_sublayer_errorcontext()  library(ggforce) erroring_sina <- ggplot(mtcars, aes(mpg)) +   geom_bar() +   geom_sina() erroring_sina  # The two return different snapshots of layer data here - # see `ggplot2:::Layer$compute_statistic` for why. last_layer_errorcontext() last_sublayer_errorcontext() }"},{"path":"/reference/one-offs.html","id":null,"dir":"Reference","previous_headings":"","what":"Debugonce a ggproto method — one-offs","title":"Debugonce a ggproto method — one-offs","text":"Debugonce ggproto method Inspect call stack","code":""},{"path":"/reference/one-offs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Debugonce a ggproto method — one-offs","text":"","code":"ggdebugonce(method, ...)  ggtraceback(method, ...)"},{"path":"/reference/one-offs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Debugonce a ggproto method — one-offs","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Arguments passed rlang::trace_back top first frame environment included backtrace. becomes top backtrace tree represents oldest call backtrace. needed particular call trace_back() indirectly larger context, example tests inside RMarkdown document want knitr evaluation mechanisms appear backtrace. bottom last frame environment included backtrace. becomes rightmost leaf backtrace tree represents youngest call backtrace. Set like capture backtrace without capture context. Can also integer passed caller_env().","code":""},{"path":"/reference/one-offs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Debugonce a ggproto method — one-offs","text":"Calls rlang::trace_back() upon first entering function method. Note ggtraceback() ever prints back trace calls gguntrace() first time triggered. complex inspections call stack, ggedit() recommended.","code":""},{"path":"/reference/one-offs.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Debugonce a ggproto method — one-offs","text":"output rlang::trace_back() logged tracedumps (last_ggtrace() global_ggtrace())","code":""},{"path":"/reference/sublayer-data.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect snapshots of sub-layer data — sublayer-data","title":"Inspect snapshots of sub-layer data — sublayer-data","text":"layer_before_stat(), layer_after_stat(), layer_before_geom(), layer_after_scale() helper functions return snapshot layer's data internals.","code":""},{"path":"/reference/sublayer-data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect snapshots of sub-layer data — sublayer-data","text":"","code":"layer_before_stat(plot, i = 1L, ..., error = FALSE)  layer_after_stat(plot, i = 1L, ..., error = FALSE)  layer_before_geom(plot, i = 1L, ..., error = FALSE)  layer_after_scale(plot, i = 1L, ..., error = FALSE)"},{"path":"/reference/sublayer-data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect snapshots of sub-layer data — sublayer-data","text":"plot ggplot object. missing, defaults ggplot2::last_plot(). Index layer inspect. Defaults 1L. ... Unused. error debugging. TRUE, continues inspecting method ggplot errors.","code":""},{"path":"/reference/sublayer-data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inspect snapshots of sub-layer data — sublayer-data","text":"dataframe","code":""},{"path":"/reference/sublayer-data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inspect snapshots of sub-layer data — sublayer-data","text":"","code":"library(ggplot2) p1 <- ggplot(mpg, aes(displ, class)) +   geom_boxplot(outlier.shape = NA) +   geom_text(     aes(       label = after_stat(xmax),       x = stage(displ, after_stat = xmax)     ),     stat = \"boxplot\", hjust = -0.5   ) p1   # Before Stat snapshot of first layer's data layer_before_stat() #> ✔ Executed `ggtrace_inspect_args(last_plot(), ggplot2:::Layer$compute_statistic)$data` #> # A tibble: 234 × 4 #>        x y          PANEL group #>    <dbl> <mppd_dsc> <fct> <int> #>  1   1.8 2          1         2 #>  2   1.8 2          1         2 #>  3   2   2          1         2 #>  4   2   2          1         2 #>  5   2.8 2          1         2 #>  6   2.8 2          1         2 #>  7   3.1 2          1         2 #>  8   1.8 2          1         2 #>  9   1.8 2          1         2 #> 10   2   2          1         2 #> # … with 224 more rows  # After Stat snapshot of first layer's data layer_after_stat() #> ✔ Executed `ggtrace_inspect_return(last_plot(), ggplot2:::Layer$compute_statistic)` #> # A tibble: 7 × 14 #>    xmin xlower xmiddle xupper  xmax outliers notch…¹ notch…²     y width relva…³ #>   <dbl>  <dbl>   <dbl>  <dbl> <dbl> <list>     <dbl>   <dbl> <dbl> <dbl>   <dbl> #> 1   5.7    5.7    6.2    6.2    6.2 <dbl>       6.55    5.85     1  0.75    2.24 #> 2   1.8    2      2.2    2.8    3.3 <dbl>       2.38    2.02     2  0.75    6.86 #> 3   1.8    2.4    2.8    3.5    4.2 <dbl>       3.07    2.53     3  0.75    6.40 #> 4   3      3.3    3.3    3.8    4   <dbl>       3.54    3.06     4  0.75    3.32 #> 5   2.7    3.9    4.7    4.7    5.9 <dbl>       4.92    4.48     5  0.75    5.74 #> 6   1.6    1.9    2.2    3.25   4.6 <dbl>       2.56    1.84     6  0.75    5.92 #> 7   2.5    4      4.65   5.3    6.5 <dbl>       4.91    4.39     7  0.75    7.87 #> # … with 3 more variables: flipped_aes <lgl>, PANEL <fct>, group <int>, and #> #   abbreviated variable names ¹​notchupper, ²​notchlower, ³​relvarwidth  # First and second layer's data are identical for those two stages identical(layer_before_stat(), layer_before_stat(i = 2)) #> ✔ Executed `ggtrace_inspect_args(last_plot(), ggplot2:::Layer$compute_statistic)$data` #> ✔ Executed `ggtrace_inspect_args(last_plot(), ggplot2:::Layer$compute_statistic, cond = 2)$data` #> [1] TRUE identical(layer_after_stat(), layer_after_stat(i = 2)) #> ✔ Executed `ggtrace_inspect_return(last_plot(), ggplot2:::Layer$compute_statistic)` #> ✔ Executed `ggtrace_inspect_return(last_plot(), ggplot2:::Layer$compute_statistic, cond = 2)` #> [1] TRUE  # `after_stat()` mappings add new columns to the second layer's data # by the time the geom receives the data in the Before Geom stage library(dplyr) layer_before_geom(i = 2) #> ✔ Executed `ggtrace_inspect_args(last_plot(), ggplot2:::Layer$compute_geom_1, cond = 2)$data` #> # A tibble: 7 × 16 #>       x label  xmin xlower xmiddle xupper  xmax outliers  notchu…¹ notch…²     y #>   <dbl> <dbl> <dbl>  <dbl>   <dbl>  <dbl> <dbl> <list>       <dbl>   <dbl> <dbl> #> 1   6.2   6.2   5.7    5.7    6.2    6.2    6.2 <dbl [1]>     6.55    5.85     1 #> 2   3.3   3.3   1.8    2      2.2    2.8    3.3 <dbl [0]>     2.38    2.02     2 #> 3   4.2   4.2   1.8    2.4    2.8    3.5    4.2 <dbl [1]>     3.07    2.53     3 #> 4   4     4     3      3.3    3.3    3.8    4   <dbl [1]>     3.54    3.06     4 #> 5   5.9   5.9   2.7    3.9    4.7    4.7    5.9 <dbl [0]>     4.92    4.48     5 #> 6   4.6   4.6   1.6    1.9    2.2    3.25   4.6 <dbl [1]>     2.56    1.84     6 #> 7   6.5   6.5   2.5    4      4.65   5.3    6.5 <dbl [0]>     4.91    4.39     7 #> # … with 5 more variables: width <dbl>, relvarwidth <dbl>, flipped_aes <lgl>, #> #   PANEL <fct>, group <int>, and abbreviated variable names ¹​notchupper, #> #   ²​notchlower  # After Scale data reflects `after_scale()` mappings p2 <- ggplot(mpg, aes(as.factor(cyl), hwy, color = as.factor(cyl))) +   theme(legend.position = 0) p2a <- p2 +   geom_boxplot(aes(fill = as.factor(cyl))) p2b <- p2 +   geom_boxplot(aes(fill = after_scale(alpha(color, .6))))  library(patchwork) p2a + p2b   layer_after_scale(p2a)$fill #> ✔ Executed `ggtrace_inspect_return(p2a, ggplot2:::Layer$compute_geom_2)` #> [1] \"#F8766D\" \"#7CAE00\" \"#00BFC4\" \"#C77CFF\" layer_after_scale(p2b)$fill #> ✔ Executed `ggtrace_inspect_return(p2b, ggplot2:::Layer$compute_geom_2)` #> [1] \"#F8766D99\" \"#7CAE0099\" \"#00BFC499\" \"#C77CFF99\" alpha( layer_after_scale(p2a)$fill, .6 ) #> ✔ Executed `ggtrace_inspect_return(p2a, ggplot2:::Layer$compute_geom_2)` #> [1] \"#F8766D99\" \"#7CAE0099\" \"#00BFC499\" \"#C77CFF99\""},{"path":"/reference/topic-tracing-context.html","id":null,"dir":"Reference","previous_headings":"","what":"Context-dependent workflow expressions in the tracing context — topic-tracing-context","title":"Context-dependent workflow expressions in the tracing context — topic-tracing-context","text":"Context-dependent workflow expressions tracing context","code":""},{"path":"/reference/topic-tracing-context.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Context-dependent workflow expressions in the tracing context — topic-tracing-context","text":"quoted expressions passed cond value argument workflow functions evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ increments every time function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1L) evaluated TRUE method called first time. cond argument also supports numeric shorthands like cond = 1L evaluates quote(._counter_ == 1L), default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). recommended consult output ggtrace_inspect_n() ggtrace_inspect_which() construct expressions condition ._counter_. highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/with_ggtrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic workflow function which localizes a ggtrace call to a single ggplot object — with_ggtrace","title":"Generic workflow function which localizes a ggtrace call to a single ggplot object — with_ggtrace","text":"with_ggtrace() provides functional interface ggtrace(). takes ggplot object parameters passed ggtrace() returns immediate tracedump /graphical output without side effects.","code":""},{"path":"/reference/with_ggtrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic workflow function which localizes a ggtrace call to a single ggplot object — with_ggtrace","text":"","code":"with_ggtrace(x, method, ..., out = c(\"tracedump\", \"gtable\", \"both\"))"},{"path":"/reference/with_ggtrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic workflow function which localizes a ggtrace call to a single ggplot object — with_ggtrace","text":"x ggplot object whose evaluation triggers trace specified ... method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Arguments passed ggtrace trace_steps sorted numeric vector positions method's body trace. Negative indices reference steps last, -1 references last step body. trace_exprs list expressions evaluate position specified trace_steps. single expression provided, recycled match length trace_steps. simply run step return output, can use ~step keyword. step assign expression, value assigned variable returned. trace_exprs provided, ggtrace() called ~step default. Whether untrace() method exit. FALSE, creates persistent trace active gguntrace() called method. Defaults TRUE. use_names Whether trace dump use names trace_exprs. Defaults TRUE. print_output Whether print() output expression console. Defaults TRUE. verbose Whether logs printed trace triggered. Encompasses print_output, meaning verbose = FALSE also triggers effect print_output = FALSE consequence. Defaults FALSE. Whether function return output triggered traces (\"tracedump\"), resulting graphical object evaluating ggplot (\"gtable\"), \"\", returns tracedump also renders resulting plot side effect. Partial matching supported, options also specified \"t\", \"g\", \"b\". Defaults \"tracedump\".","code":""},{"path":"/reference/with_ggtrace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic workflow function which localizes a ggtrace call to a single ggplot object — with_ggtrace","text":"list gtable object class <ggtrace_highjacked>","code":""},{"path":"/reference/with_ggtrace.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generic workflow function which localizes a ggtrace call to a single ggplot object — with_ggtrace","text":"trigger evaluation x, function ggeval_silent(x) called internally.","code":""},{"path":[]},{"path":"/reference/with_ggtrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generic workflow function which localizes a ggtrace call to a single ggplot object — with_ggtrace","text":"","code":"library(ggplot2)  # Long-form `ggtrace()` method: boxplot_plot <- ggplot(diamonds[1:500,], aes(cut, depth)) + geom_boxplot() ggtrace(  method = StatBoxplot$compute_group,  trace_steps = -1, trace_exprs = quote(~step) ) #> `StatBoxplot$compute_group` now being traced. boxplot_plot #> Triggering trace on `StatBoxplot$compute_group` #> Untracing `StatBoxplot$compute_group` on exit.  first_tracedump <- last_ggtrace()  # Short-form functional `with_ggtrace()` method: second_tracedump <- with_ggtrace(   x = boxplot_plot,   method = StatBoxplot$compute_group,   trace_steps = -1, trace_exprs = quote(~step) )  identical(first_tracedump, second_tracedump) #> [1] TRUE   # An example with `out = \"gtable\"` (or `\"g\"`) grid_plot <- ggplot(mtcars, aes(mpg, hp)) +   geom_point() +   facet_grid(am ~ cyl) grid_plot   outline <- grid::rectGrob(   x = 0.5, y = 0.5, width = 1, height = 1,   gp = grid::gpar(col = \"red\", lwd = 5, fill = NA) )  with_ggtrace(   x = grid_plot,   method = Layout$render,   trace_steps = 5,   trace_exprs = rlang::expr({     panels[c(3, 5)] <- lapply(panels[c(3, 5)], function(panel) {       gTree(children = gList(panel, !!outline))     })   }),   out = \"gtable\" # or \"g\" )    # With `once = FALSE` for persistent tracing (still cleaned up after) lm_plot <- ggplot(mpg, aes(displ, hwy, color = drv)) +   geom_point() +   geom_smooth(method = \"lm\") lm_plot #> `geom_smooth()` using formula = 'y ~ x'   with_ggtrace(   x = lm_plot,   method = StatSmooth$compute_group,   trace_steps = c(1, 11),   trace_exprs = list(     group = quote(data$group[1]),     coef = quote(model$coef)   ) ) #> $group #> [1] 1 #>  #> $coef #> (Intercept)           x  #>   30.683113   -2.878486  #>   with_ggtrace(   x = lm_plot,   method = StatSmooth$compute_group,   trace_steps = 1,   trace_exprs = quote(method <- c(\"loess\", \"lm\", \"loess\")[data$group[1]]),   out = \"g\" # or \"gtable\" )    # `with_ggtrace()` is useful for making calculations that are parasitic # on a plot's execution environment.  library(grid)  square_plot <- ggplot(mtcars, aes(mpg, hp, color = factor(cyl))) +   geom_point() +   theme(aspect.ratio = 1) square_plot   rotation_vp <- viewport(width = .7, height = .7, angle = 45)  parasitic_evaluations <- with_ggtrace(   x = square_plot,   method = ggplot2:::ggplot_gtable.ggplot_built,   trace_steps = c(9, 13, -1),   trace_exprs = rlang::exprs(     plot_tbl = .plot_table <- editGrob(plot_table, vp = !!rotation_vp),     legend   = .legend <- editGrob(legend_box, vp = viewport(x = 0.15, y = 0.8)),     modified = gTree(children = gList(.plot_table, .legend))   ) )  grid.newpage() grid.draw(parasitic_evaluations$modified) #> Warning: cannot clip to rotated viewport"},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"bug-fixes-development-version","dir":"Changelog","previous_headings":"ggtrace 0.6.1","what":"Bug fixes","title":"ggtrace (development version)","text":"get_method_inheritance() now works correctly top-level ggprotos - ex: get_method_inheritance(Geom) (#99; thanks @yjing14 bug report).","code":""},{"path":"/news/index.html","id":"ggtrace-development-version-2","dir":"Changelog","previous_headings":"","what":"ggtrace 0.6.0","title":"ggtrace (development version)","text":"Significant usability improvements, including cli integration.","code":""},{"path":"/news/index.html","id":"new-features-development-version","dir":"Changelog","previous_headings":"ggtrace 0.6.0","what":"New Features","title":"ggtrace (development version)","text":"Convenience functions layer_before_stat(), layer_after_stat(), layer_before_geom(), layer_after_scale() returns snapshot layer data internals. Inspired ggplot2::layer_data() similar interface. (#97; thanks @JoFrhwld suggestion) Interactive debugging functions last_layer_errorcontext() last_sublayer_errorcontext() return internal context layer errors level Layer sub-Layer (e.g., Stat Geom) ggproto methods, respectively. last_sublayer_errorcontext() still experimental phase (error-prone, may removed future). New catch-Inspect workflow function ggtrace_inspect_on_error() dumps information method errors rendering x.","code":""},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"new-features-0-5","dir":"Changelog","previous_headings":"ggtrace 0.5.3","what":"New Features","title":"ggtrace 0.5.x","text":"Inspect workflow functions gain error = TRUE argument, allows inspection earlier intermediate step even ggplot rendering process fails line (#89)","code":""},{"path":"/news/index.html","id":"bug-fixes-0-5","dir":"Changelog","previous_headings":"ggtrace 0.5.3","what":"Bug fixes","title":"ggtrace 0.5.x","text":"Internal .ggtrace_placeholder() returns scalar logical (#94)","code":""},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-5","dir":"Changelog","previous_headings":"ggtrace 0.5.2","what":"Breaking Changes","title":"ggtrace 0.5.x","text":"ggtrace_inspect_vars() simplifies output length 1.","code":""},{"path":"/news/index.html","id":"bug-fixes-0-5-1","dir":"Changelog","previous_headings":"ggtrace 0.5.2","what":"Bug fixes","title":"ggtrace 0.5.x","text":"ggtrace_capture_env() removes ggtrace-internal variables snapshotting environment (#88)","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-5-1","dir":"Changelog","previous_headings":"ggtrace 0.5.1","what":"New Features","title":"ggtrace 0.5.x","text":"cond argument workflow functions now support integer shorthand conditioning counter. E.g., cond = 1L converted cond = quote(._counter_ == 1L). Multi-length integer vector supported highjack workflows. (#84)","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-5-2","dir":"Changelog","previous_headings":"ggtrace 0.5.0","what":"New Features","title":"ggtrace 0.5.x","text":"Added complements base::debug() family functions compatible ggproto methods - ggdebug(), ggdebugonce(), ggundebug() get_method_inheritance() get list methods self parent ggprotos ggtrace_inspect_n() get number times method called evaluation ggplot ggtrace_inspect_which() get indices condition cond evaluated true inside method ggtrace_inspect_vars() get value variables specified steps method’s execution ggtrace_inspect_args() get value arguments passed method ggtrace_highjack_args() modify formals method execution with_ggtrace() gets argument can take 1 three options: “t” “tracedump” (default): returns local tracedump triggering traces method ggplot x evaluated “g” “gtable”: Invisibly returns <gtable> grob evaluating x injected expressions method. “b” “”: returns tracedump rendering gtable (grid::grid.draw()) side effect. Low-level functions ggtrace()/gguntrace() wrapper with_ggtrace() can now take quosures method argument, allows used programmatically.","code":""},{"path":"/news/index.html","id":"breaking-changes-0-5-1","dir":"Changelog","previous_headings":"ggtrace 0.5.0","what":"Breaking Changes","title":"ggtrace 0.5.x","text":"ggtrace_capture_env() default value changed -1L, captures snapshot runtime environment right method returns. first element used length > 1 “modify” workflows renamed “highjack” (starting ggtrace_highjack_return()) reflect fact always return graphical output (gtable grob) (#78)","code":""},{"path":"/news/index.html","id":"bug-fixes-0-5-2","dir":"Changelog","previous_headings":"ggtrace 0.5.0","what":"Bug Fixes","title":"ggtrace 0.5.x","text":"Fixed issue trace fail remove ggtrace(= TRUE) triggered copy traced function (#59)","code":""},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"new-features-0-4","dir":"Changelog","previous_headings":"ggtrace 0.4.8","what":"New Features","title":"ggtrace 0.4.x","text":"Added with_ggtrace() functional interface ggtrace() Added ggtrace_capture_fn() ggtrace_capture_env(), return snapshot function/environment ggproto method execution time Added ggtrace_inspect_return() ggtrace_modify_return() grab swap return values method’s execution","code":""},{"path":"/news/index.html","id":"miscellaneous-0-4","dir":"Changelog","previous_headings":"ggtrace 0.4.8","what":"Miscellaneous","title":"ggtrace 0.4.x","text":"Added workflows section docs/references","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-4-1","dir":"Changelog","previous_headings":"ggtrace 0.4.7","what":"New Features","title":"ggtrace 0.4.x","text":"Added ggformals() returns formals() functions ggproto methods ggbody() gains .list argument control whether output body() turned list Exported set_last_ggtrace() set_global_ggtrace() tracedumps","code":""},{"path":"/news/index.html","id":"bug-fix-0-4","dir":"Changelog","previous_headings":"ggtrace 0.4.7","what":"Bug Fix","title":"ggtrace 0.4.x","text":"Fixed compatibility issues {rlang} v1.0.0 new changes call expression API","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-4-2","dir":"Changelog","previous_headings":"ggtrace 0.4.6","what":"New Features","title":"ggtrace 0.4.x","text":"Added get_method() returns ggproto methods functions Added wrappers one-workflows ggdebugonce() ggtraceback()","code":""},{"path":"/news/index.html","id":"improvements-0-4","dir":"Changelog","previous_headings":"ggtrace 0.4.6","what":"Improvements","title":"ggtrace 0.4.x","text":"default value verbose argument ggtrace() changed FALSE.","code":""},{"path":[]},{"path":"/news/index.html","id":"improvements-0-4-1","dir":"Changelog","previous_headings":"ggtrace 0.4.5","what":"Improvements","title":"ggtrace 0.4.x","text":"Deparsed expressions printed messages now wrapped backticks (#57) ggedit() now works isTRUE(interactive()) (#62)","code":""},{"path":"/news/index.html","id":"new-features-0-4-3","dir":"Changelog","previous_headings":"ggtrace 0.4.5","what":"New Features","title":"ggtrace 0.4.x","text":"Added global_ggtrace_on/() aliases global_ggtrace_state(TRUE/FALSE) (#63)","code":""},{"path":"/news/index.html","id":"miscellaneous-0-4-1","dir":"Changelog","previous_headings":"ggtrace 0.4.5","what":"Miscellaneous","title":"ggtrace 0.4.x","text":"Added exploratory debugging case study vignette","code":""},{"path":[]},{"path":"/news/index.html","id":"improvements-0-4-2","dir":"Changelog","previous_headings":"ggtrace 0.4.4","what":"Improvements","title":"ggtrace 0.4.x","text":"clear_(last|global)_ggtrace() functions now print message saying trace dump cleared. Better error handling closures aren’t searchable environments","code":""},{"path":"/news/index.html","id":"bug-fix-0-4-1","dir":"Changelog","previous_headings":"ggtrace 0.4.4","what":"Bug Fix","title":"ggtrace 0.4.x","text":"Fixed methods class  treated bare functions. Now closures methods outside ggproto objects (e.g., R6 classes) can traced .","code":""},{"path":"/news/index.html","id":"miscellaneous-0-4-2","dir":"Changelog","previous_headings":"ggtrace 0.4.4","what":"Miscellaneous","title":"ggtrace 0.4.x","text":"Added FAQ vignette","code":""},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-4","dir":"Changelog","previous_headings":"ggtrace 0.4.3","what":"Breaking changes","title":"ggtrace 0.4.x","text":"Global tracedump turned default (global_ggtrace_state() FALSE load) must explicitly activated global_ggtrace_state(TRUE).","code":""},{"path":"/news/index.html","id":"improvements-0-4-3","dir":"Changelog","previous_headings":"ggtrace 0.4.3","what":"Improvements","title":"ggtrace 0.4.x","text":"Improved messages global_ggtrace_state()","code":""},{"path":[]},{"path":"/news/index.html","id":"bug-fixes-0-4","dir":"Changelog","previous_headings":"ggtrace 0.4.2","what":"Bug Fixes","title":"ggtrace 0.4.x","text":"Fixed bug print_output = TRUE evaluate expression twice (problematic Inject workflows causing general slowdowns)","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-4-4","dir":"Changelog","previous_headings":"ggtrace 0.4.1","what":"New Features","title":"ggtrace 0.4.x","text":"Global collection tracedumps can turned /global_ggtrace_state(). still active default memory become concern, can turned global_ggtrace_state(state = FALSE).","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-4-5","dir":"Changelog","previous_headings":"ggtrace 0.4.0","what":"New Features","title":"ggtrace 0.4.x","text":"functions package now support tracing/untracing arbitrary functions (exported, unexported, user-defined, etc.). also includes S3/S4 methods like ggplo2:::ggplot_build.ggplot ggplot2:::ggplot_add.Layer. examples ’s now possible.","code":""},{"path":"/news/index.html","id":"improvements-0-4-4","dir":"Changelog","previous_headings":"ggtrace 0.4.0","what":"Improvements","title":"ggtrace 0.4.x","text":"ggtrace() gains ... extensibility future updates. ggedit() gains remove_trace argument. TRUE, untraces first editing. Improved error messages invalid expressions passed method argument ggbody()","code":""},{"path":"/news/index.html","id":"bug-fixes-0-4-1","dir":"Changelog","previous_headings":"ggtrace 0.4.0","what":"Bug Fixes","title":"ggtrace 0.4.x","text":"Fix bug ggtrace() fails evaluate first line ’s reachable line (#44)","code":""},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"bug-fixes-0-3","dir":"Changelog","previous_headings":"ggtrace 0.3.7","what":"Bug Fixes","title":"ggtrace 0.3.x","text":"Fixed bug incomplete traces due early returns logged without special warning. ggtrace() now throws warning actual number traced steps match expected number traced steps (.e., length trace_steps) logs incomplete tracedumps (#44)","code":""},{"path":[]},{"path":"/news/index.html","id":"improvements-0-3","dir":"Changelog","previous_headings":"ggtrace 0.3.6","what":"Improvements","title":"ggtrace 0.3.x","text":"ggtrace(..., = TRUE) less noisy persistent trace. now sends line message saying persistent trace created. ’s triggered, ’ll tell persistent trace methodbut remind untrace later print corresponding gguntrace() code .","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-1","dir":"Changelog","previous_headings":"ggtrace 0.3.6","what":"Bug Fixes","title":"ggtrace 0.3.x","text":"Fixed bug trace_exprs evaluating NULL removed tracedump (#38)","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-3","dir":"Changelog","previous_headings":"ggtrace 0.3.5","what":"New features","title":"ggtrace 0.3.x","text":"New function is_traced() checks whether method currently traced","code":""},{"path":"/news/index.html","id":"improvements-0-3-1","dir":"Changelog","previous_headings":"ggtrace 0.3.5","what":"Improvements","title":"ggtrace 0.3.x","text":"ggtrace() now breaks early informative message method function (ex: Stat$extra_params, 1-length character vector \"na.rm\") ggbody() now warns ’s returning body method ’s currently traced (#35) ggedit() now informs ’re editing top existing trace/edit.","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-2","dir":"Changelog","previous_headings":"ggtrace 0.3.5","what":"Bug Fixes","title":"ggtrace 0.3.x","text":"Fixed bug trace_exprs fail recycled list length-1. Now 1-length list expression well expression get recycled match number steps passed trace_steps. Fixed bug ggtrace() wouldn’t loop trace_exprs first time ’s triggered persistent tracing (= TRUE). Issue due failing reset internal counter time trace triggered.","code":""},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-3","dir":"Changelog","previous_headings":"ggtrace 0.3.4","what":"Breaking changes","title":"ggtrace 0.3.x","text":".print argument ggtrace() renamed print_output make functionality transparent.","code":""},{"path":"/news/index.html","id":"new-features-0-3-1","dir":"Changelog","previous_headings":"ggtrace 0.3.4","what":"New features","title":"ggtrace 0.3.x","text":"Several options finer control printing formatting output ggtrace(), addition existing .print argument: ggtrace() gets use_names argument. TRUE, uses names list expressions passed trace_exprs names tracedump set last_ggtrace() added global_ggtrace(). ggtrace() gets verbose argument. FALSE, suppresses display non-message() information, including information expression evaluated , well output expressions evaluated (can selectively suppressed .print finer control). verbose TRUE default. Setting options(ggtrace.suppressMessages = TRUE) also suppress messages()s method traced, whether trace triggered method, whether exists persistent trace, etc. information important using option recommended, made available. option set FALSE package load. Setting options(ggtrace.as_tibble = TRUE) return evaluated expressions tibbles output data frame. Using option may convenient interactive inspections recommended testing debugging (see related {ggplot2} Github issue). option set FALSE package load.","code":""},{"path":"/news/index.html","id":"improvements-0-3-2","dir":"Changelog","previous_headings":"ggtrace 0.3.4","what":"Improvements","title":"ggtrace 0.3.x","text":"Tracedumps accumulated global_ggtrace() named method (+ hexadecimal ID) ease searching. (#31) Triggering trace now informed via message() instead cat() (#29)","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-3","dir":"Changelog","previous_headings":"ggtrace 0.3.4","what":"Bug Fixes","title":"ggtrace 0.3.x","text":"ggtrace() correctly throws error trace_steps ordered. checked negative index conversion, something like trace_steps = c(1, -1) still works fine).","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-3-2","dir":"Changelog","previous_headings":"ggtrace 0.3.3","what":"New features","title":"ggtrace 0.3.x","text":"New function global_ggtrace() returns accumulated tracedumps ggtrace(). useful conjunction ggtrace(= FALSE) tracing method expect called multiple times (ex: Stat$compute_group gets triggered number times number groups panel). New function clear_global_ggtrace() clears global_ggtrace() setting NULL.","code":""},{"path":"/news/index.html","id":"improvements-0-3-3","dir":"Changelog","previous_headings":"ggtrace 0.3.3","what":"Improvements","title":"ggtrace 0.3.x","text":"Functions now pass around quosures instead expressions (#29) Testing setup (#28)","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-4","dir":"Changelog","previous_headings":"ggtrace 0.3.3","what":"Bug Fixes","title":"ggtrace 0.3.x","text":"Fixed bug number expressions passed trace_exprs allowed different number trace_steps, causing ggtrace() silently fail. now throws error.","code":""},{"path":[]},{"path":"/news/index.html","id":"improvements-0-3-4","dir":"Changelog","previous_headings":"ggtrace 0.3.2","what":"Improvements","title":"ggtrace 0.3.x","text":"trace_exprs argument can now take named list expressions (#21) Improved documentation ggbody() informative messages ggtrace() gguntrace()","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-5","dir":"Changelog","previous_headings":"ggtrace 0.3.2","what":"Bug fixes","title":"ggtrace 0.3.x","text":"longer errors exit creating persistence trace = FALSE","code":""},{"path":[]},{"path":"/news/index.html","id":"improvements-0-3-5","dir":"Changelog","previous_headings":"ggtrace 0.3.1","what":"Improvements","title":"ggtrace 0.3.x","text":"unary functions ggedit() gguntrace() gain dynamic dots ... second argument, gets ignored. now makes easy call function modifying call earlierggtrace function console interactive contexts. Significant re-write ggbody() better error handling (#23) Aborts method call accepted form, specific error messages . method doesn’t exist parent, directs users call ggbody(, inherit = TRUE) recursive search inherit = TRUE fails, directs users load relevant packages Notifies inherit = TRUE method defined object, inherited Better error handling gguntrace() method longer traced (#24) Uses re-written ggbody() validate method Unlike base::untrace(), longer errors given method currently traced. now prints message saying instead Standardization messages printed ggtrace functions. Messages now informative refer ggproto method callable format ggproto$method.","code":""},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-3-1","dir":"Changelog","previous_headings":"ggtrace 0.3.0","what":"Breaking changes","title":"ggtrace 0.3.x","text":"obj argument completely removed functions package. constraint supplying methods expressions forces users intentional tracing ggproto methods provide code. also allows functions return informative messages, main motivation breaking change. obj argument designed compatibility get(\"method\", ggproto) syntax retrieving function body ggproto methods, affect interactive workflows. fact, shortform method = ggproto$method convenient always recommended passing ggproto method ggtrace functions. reminder, functions take ggproto method method argument expects expression following forms (part hasn’t changed): ggproto$method namespace::ggproto$method namespace:::ggproto$method","code":""},{"path":"/news/index.html","id":"improvements-0-3-6","dir":"Changelog","previous_headings":"ggtrace 0.3.0","what":"Improvements","title":"ggtrace 0.3.x","text":"Accurate string conversion ggproto objects (#9), made possible breaking change. trace_steps argument can now take negative indices (#22) better error handling range indices. Better deparsing split_ggproto_method() internal. Added Tips & Tricks section documentation ggtrace().","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-6","dir":"Changelog","previous_headings":"ggtrace 0.3.0","what":"Bug fixes","title":"ggtrace 0.3.x","text":"Internal variable .store renamed .ggtrace_storage prevent overriding ggplot2::.store (#18)","code":""},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-2","dir":"Changelog","previous_headings":"ggtrace 0.2.0","what":"Breaking changes","title":"ggtrace 0.2.x","text":"~line keyword ggtrace() renamed ~step consistency argument name trace_steps (#14) safety reasons, ~step keyword now substituted expression current step ~step (.e., exact match) (#16, #11). example, ~step substituted quote(head(~step)) passed trace_exprs. Users encouraged return method’s environment quote(environment()) interactively debug ggedit() want manipulate expression. position obj argument ggtrace() moved second fourth, allow shortcuts like ggtrace(method = ..., 2:3, quote(data)), evaluate store output data variable second third steps method body. (#15)","code":""},{"path":"/news/index.html","id":"new-features-0-2","dir":"Changelog","previous_headings":"ggtrace 0.2.0","what":"New features","title":"ggtrace 0.2.x","text":"trace_exprs argument ggtrace() now optional. provided, defaults ~step (#13) can now tell ggbody() (recursively) search method parents inherit = TRUE (#12)","code":""},{"path":"/news/index.html","id":"improvements-0-2","dir":"Changelog","previous_headings":"ggtrace 0.2.0","what":"Improvements","title":"ggtrace 0.2.x","text":"Documentation functions now contain Gotchas section explanations / solutions common problems (#10)","code":""},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"new-features-0-1","dir":"Changelog","previous_headings":"ggtrace 0.1.2","what":"New features","title":"ggtrace 0.1.x","text":"New function gguntrace() syntax specifying ggproto method. ggtrace() gains = TRUE argument, can set FALSE persistent tracing","code":""},{"path":"/news/index.html","id":"bug-fixes-0-1","dir":"Changelog","previous_headings":"ggtrace 0.1.2","what":"Bug fixes","title":"ggtrace 0.1.x","text":"Fix bug ggtrace() step_deparsed returned multi-length vector","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-1-1","dir":"Changelog","previous_headings":"ggtrace 0.1.1","what":"New features","title":"ggtrace 0.1.x","text":"New function ggedit() interactive debugging via directly editing source code.","code":""},{"path":"/news/index.html","id":"improvements-0-1","dir":"Changelog","previous_headings":"ggtrace 0.1.1","what":"Improvements","title":"ggtrace 0.1.x","text":"Refactored ggtrace(). package now depends rlang. Significant re-write readme / documentation","code":""},{"path":[]},{"path":"/news/index.html","id":"initial-release-0-1","dir":"Changelog","previous_headings":"ggtrace 0.1.0","what":"Initial release","title":"ggtrace 0.1.x","text":"pkgdown site: https://yjunechoe.github.io/ggtrace Functions: ggtrace() ggbody() last_ggtrace()","code":""}]
