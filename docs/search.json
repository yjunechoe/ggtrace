[{"path":"/articles/casestudy-after_scale.html","id":"motivating-thing","dir":"Articles","previous_headings":"","what":"Motivating thing","title":"Case Study: inspecting aes evaluation with `after_scale()`","text":"vignette starts question - happens ggplot internals something? Often times can make inferences surface form, surface form shares thing? ’ve hit roadblock traditional tools users, develop mental models. vignette shows can test hypotheses competing (mental) models ggplot internals make predictions (.e., plots “look” ). Going approach like scientific endeavor - fancy way saying kind trial--error way self-learning many useRs comfortable ","code":""},{"path":"/articles/casestudy-after_scale.html","id":"the-research-question","dir":"Articles","previous_headings":"","what":"The research question","title":"Case Study: inspecting aes evaluation with `after_scale()`","text":"know can map variable aesthetic. – plot also know taht can grab mapped aesthetics statistical transofmration scaling applied, after_stat() after_scale() respectivelyt. – plots also know can override aes constant supplied directly aes. (2-layer plot global aes inheritance)","code":""},{"path":"/articles/casestudy-after_scale.html","id":"under-construction","dir":"Articles","previous_headings":"","what":"Under construction","title":"Case Study: inspecting aes evaluation with `after_scale()`","text":"Slides ggplot internals / {ggtrace} talk December 4th 2021: https://yjunechoe.github.io/ggtrace-talk","code":"library(ggtrace)"},{"path":"/articles/casestudy-ggxmean.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Debugging an extension package","text":"like follow along, can install version {ggxmean} package containing bug vignette address. use devtools::dev_mode() install inspect version {ggxmean} development mode (except skip installation already version dev directory). ’ve also attached code relevant issue hand , like familiarize begin (though assume prior knowledge ).","code":"library(ggtrace) library(ggplot2) theme_set(theme_minimal()) library(devtools) #> Loading required package: usethis  # Current installation version devtools::package_info(\"ggxmean\", FALSE, FALSE)$source #> [1] \"local\"  # Activate development mode devtools::dev_mode(on = TRUE, path = getOption(\"devtools.path\")) #> v Dev mode: ON  # devtools::install_github(\"EvaMaeRey/ggxmean@cbb909c\")  # Prior version installed for dev mode devtools::package_info(\"ggxmean\", FALSE, FALSE)$source #> [1] \"Github (EvaMaeRey/ggxmean@cbb909c)\"  library(ggxmean) # https://github.com/EvaMaeRey/ggxmean/blob/cbb909cee7d4f0a4395722020a75330641e5f54c/R/geom_x_line.R  GeomXline <- ggplot2::ggproto(\"GeomXline\", ggplot2::Geom,                      draw_panel = function(data, panel_params, coord) {                        ranges <- coord$backtransform_range(panel_params)                        data$x    <- data$x                        data$xend <- data$x                        data$y    <- ranges$y[1]                        data$yend <- ranges$y[2]                        GeomSegment$draw_panel(unique(data), panel_params, coord)                      },                      default_aes = ggplot2::aes(colour = \"black\", size = 0.5,                                        linetype = 1, alpha = NA),                      required_aes = \"x\",                      draw_key = ggplot2::draw_key_vline )  # https://github.com/EvaMaeRey/ggxmean/blob/cbb909cee7d4f0a4395722020a75330641e5f54c/R/geom_x_mean.R StatXmean <- ggplot2::ggproto(\"StatXmean\",                               ggplot2::Stat,                               compute_group = function(data, scales) {                                 data.frame(x = mean(data$x))                               },                               required_aes = c(\"x\") )  geom_x_mean <- function(mapping = NULL, data = NULL,                         position = \"identity\", na.rm = FALSE, show.legend = NA,                         inherit.aes = TRUE, ...) {   ggplot2::layer(     stat = StatXmean, geom = GeomXline, data = data, mapping = mapping,     position = position, show.legend = show.legend, inherit.aes = inherit.aes,     params = list(na.rm = na.rm, ...)   ) }"},{"path":"/articles/casestudy-ggxmean.html","id":"introduction-of-the-issue","dir":"Articles","previous_headings":"","what":"Introduction of the issue","title":"Debugging an extension package","text":"{ggxmean} {ggplot2} extension package offers many features, including layer geom_x_mean() can used draw line mean value variable represented x-axis.  geom_x_mean() works smoothly groups facets, might expect experience ggplot.  However, something somewhat unexpected happens pass map discrete variable aesthetic understandable geom_x_mean(). Despite fact lines understand fill aesthetic, aesthetic mapping fill = drv nevertheless highjacks calculation grouping geom_x_mean().","code":"ggplot(mpg, aes(x = hwy)) +   geom_histogram() +   geom_x_mean() #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(mpg, aes(x = hwy, group = drv)) +   geom_histogram() +   geom_x_mean() +   facet_wrap(~drv) #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(mpg, aes(x = hwy, fill = drv)) +   geom_histogram() +   geom_x_mean() #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`."},{"path":"/articles/casestudy-ggxmean.html","id":"making-a-reprex","dir":"Articles","previous_headings":"Introduction of the issue","what":"Making a reprex","title":"Debugging an extension package","text":"isolate problem, let’s remove geom_histogram() examples. minimal reprex (reproducible example) issue:  can pinpoint formalize issue help layer_data(). see expected group = drv unexpected fill = drv cases, end three unique groups (lines) indicated values group column.","code":"ggplot(mpg) +   aes(x = hwy, fill = drv) +   geom_x_mean() p <- ggplot(mpg) +   aes(x = hwy) +   geom_x_mean() layer_data(p + aes(group = drv)) #>          x group PANEL colour size linetype alpha #> 1 19.17476     1     1  black  0.5        1    NA #> 2 28.16038     2     1  black  0.5        1    NA #> 3 21.00000     3     1  black  0.5        1    NA layer_data(p + aes(fill = drv)) #>      fill        x PANEL group colour size linetype alpha #> 1 #F8766D 19.17476     1     1  black  0.5        1    NA #> 2 #00BA38 28.16038     1     2  black  0.5        1    NA #> 3 #619CFF 21.00000     1     3  black  0.5        1    NA"},{"path":"/articles/casestudy-ggxmean.html","id":"expected-cases","dir":"Articles","previous_headings":"Introduction of the issue","what":"Expected cases","title":"Debugging an extension package","text":", correctly get groups category drv lines understand color aesthetic.  also correctly get groups category drv set group aesthetic explicitly.","code":"p + aes(color = drv) layer_data(p + aes(color = drv))$group #> [1] 1 2 3 p + aes(group = drv) layer_data(p + aes(group = drv))$group #> [1] 1 2 3"},{"path":"/articles/casestudy-ggxmean.html","id":"unexpected-cases","dir":"Articles","previous_headings":"Introduction of the issue","what":"Unexpected cases","title":"Debugging an extension package","text":", ’d like 1 group/line lines don’t understand shape aesthetic  , ’d like 3 groups drv mapped color. Categories fl variable interact drv creation groups lines don’t understand fill aesthetic.","code":"p + aes(shape = drv) layer_data(p + aes(shape = drv))$group #> [1] 1 2 3 p + aes(fill = fl, color = drv) layer_data(p + aes(fill = fl, color = drv))$group #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12"},{"path":[]},{"path":[]},{"path":"/articles/casestudy-ggxmean.html","id":"starting-at-ggplot_build","dir":"Articles","previous_headings":"Step 1 - Locating the problem","what":"1.1 Starting at ggplot_build()","title":"Debugging an extension package","text":"first step, let’s see groups calculated added data inspecting ggplot_build(), main engine behind ggplot. exploratory debugging ggplot internals, inspecting data transformation pipeline ggplot_build() often best place start. first exposure ggplot_build(), just need know output basically ’s returned layer_data() function demoed . use ggbody() function {ggtrace} grab body ggplot_build() list, , metaprogramming rlang, pick steps data gets transformed. Note syntax ggplot2:::ggplot_build.ggplot reflects fact ggplot_build() S3 generic defined class <<ggplot>>. can inspect source code ggplot_build() ggplot2 Github repo, output ggbody(ggplot2:::ggplot_build.ggplot) also available : data transformation step (steps + 1L), let’s log data first () layer reprex plot. , tracedump1 list data looked like data-transformation step inside ggplot_build(). ’s list data frames ’s lot , ’s looks like ’s cleaned tibble::as_tibble() can now map every element list see group column first present. Step 12 ggplot_build() group first appears. suspect ’s group computed assigned code Step 12 ggplot_build() calls compute_aesthetics method layer l. by_layer() function defined Step 7 ggplot_build() ’s .","code":"layer_data #> function (plot, i = 1L)  #> { #>     ggplot_build(plot)$data[[i]] #> } #> <bytecode: 0x0000000034b78fd0> #> <environment: namespace:ggplot2> build_pipeline <- ggbody(ggplot2:::ggplot_build.ggplot) data_assigns <- sapply(build_pipeline,   function(x) {     rlang::is_call(x) &&       !is.null(rlang::call_name(x)) &&        rlang::call_name(x) == \"<-\" &&       rlang::call_args(x)[[1]] == \"data\"   } ) which(data_assigns) # Steps of the build pipeline where data is transformed #>  [1]  8  9 11 12 13 17 18 19 21 22 26 29 30 31 ggbody(ggplot2:::ggplot_build.ggplot) #> [[1]] #> `{` #>  #> [[2]] #> plot <- plot_clone(plot) #>  #> [[3]] #> if (length(plot$layers) == 0) { #>     plot <- plot + geom_blank() #> } #>  #> [[4]] #> layers <- plot$layers #>  #> [[5]] #> layer_data <- lapply(layers, function(y) y$layer_data(plot$data)) #>  #> [[6]] #> scales <- plot$scales #>  #> [[7]] #> by_layer <- function(f) { #>     out <- vector(\"list\", length(data)) #>     for (i in seq_along(data)) { #>         out[[i]] <- f(l = layers[[i]], d = data[[i]]) #>     } #>     out #> } #>  #> [[8]] #> data <- layer_data #>  #> [[9]] #> data <- by_layer(function(l, d) l$setup_layer(d, plot)) #>  #> [[10]] #> layout <- create_layout(plot$facet, plot$coordinates) #>  #> [[11]] #> data <- layout$setup(data, plot$data, plot$plot_env) #>  #> [[12]] #> data <- by_layer(function(l, d) l$compute_aesthetics(d, plot)) #>  #> [[13]] #> data <- lapply(data, scales_transform_df, scales = scales) #>  #> [[14]] #> scale_x <- function() scales$get_scales(\"x\") #>  #> [[15]] #> scale_y <- function() scales$get_scales(\"y\") #>  #> [[16]] #> layout$train_position(data, scale_x(), scale_y()) #>  #> [[17]] #> data <- layout$map_position(data) #>  #> [[18]] #> data <- by_layer(function(l, d) l$compute_statistic(d, layout)) #>  #> [[19]] #> data <- by_layer(function(l, d) l$map_statistic(d, plot)) #>  #> [[20]] #> scales_add_missing(plot, c(\"x\", \"y\"), plot$plot_env) #>  #> [[21]] #> data <- by_layer(function(l, d) l$compute_geom_1(d)) #>  #> [[22]] #> data <- by_layer(function(l, d) l$compute_position(d, layout)) #>  #> [[23]] #> layout$reset_scales() #>  #> [[24]] #> layout$train_position(data, scale_x(), scale_y()) #>  #> [[25]] #> layout$setup_panel_params() #>  #> [[26]] #> data <- layout$map_position(data) #>  #> [[27]] #> npscales <- scales$non_position_scales() #>  #> [[28]] #> if (npscales$n() > 0) { #>     lapply(data, scales_train_df, scales = npscales) #>     data <- lapply(data, scales_map_df, scales = npscales) #> } #>  #> [[29]] #> data <- by_layer(function(l, d) l$compute_geom_2(d)) #>  #> [[30]] #> data <- by_layer(function(l, d) l$finish_statistics(d)) #>  #> [[31]] #> data <- layout$finish_data(data) #>  #> [[32]] #> plot$labels$alt <- get_alt_text(plot) #>  #> [[33]] #> structure(list(data = data, layout = layout, plot = plot), class = \"ggplot_built\") ggtrace(   method = ggplot2:::ggplot_build.ggplot,   trace_steps = which(data_assigns) + 1, # After each data transformation step ...   trace_exprs = quote(data[[1]]),        # ... return the data for the first layer   verbose = FALSE ) #> `ggplot2:::ggplot_build.ggplot` now being traced.  # plot not printed for space p + aes(fill = drv) #> Triggering trace on `ggplot2:::ggplot_build.ggplot` #> Untracing `ggplot2:::ggplot_build.ggplot` on exit.  tracedump1 <- last_ggtrace() lapply(tracedump1, tibble::as_tibble) #> [[1]] #> # A tibble: 234 x 11 #>    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class #>    <chr>        <chr>      <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> #>  1 audi         a4           1.8  1999     4 auto~ f        18    29 p     comp~ #>  2 audi         a4           1.8  1999     4 manu~ f        21    29 p     comp~ #>  3 audi         a4           2    2008     4 manu~ f        20    31 p     comp~ #>  4 audi         a4           2    2008     4 auto~ f        21    30 p     comp~ #>  5 audi         a4           2.8  1999     6 auto~ f        16    26 p     comp~ #>  6 audi         a4           2.8  1999     6 manu~ f        18    26 p     comp~ #>  7 audi         a4           3.1  2008     6 auto~ f        18    27 p     comp~ #>  8 audi         a4 quattro   1.8  1999     4 manu~ 4        18    26 p     comp~ #>  9 audi         a4 quattro   1.8  1999     4 auto~ 4        16    25 p     comp~ #> 10 audi         a4 quattro   2    2008     4 manu~ 4        20    28 p     comp~ #> # ... with 224 more rows #>  #> [[2]] #> # A tibble: 234 x 11 #>    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class #>    <chr>        <chr>      <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> #>  1 audi         a4           1.8  1999     4 auto~ f        18    29 p     comp~ #>  2 audi         a4           1.8  1999     4 manu~ f        21    29 p     comp~ #>  3 audi         a4           2    2008     4 manu~ f        20    31 p     comp~ #>  4 audi         a4           2    2008     4 auto~ f        21    30 p     comp~ #>  5 audi         a4           2.8  1999     6 auto~ f        16    26 p     comp~ #>  6 audi         a4           2.8  1999     6 manu~ f        18    26 p     comp~ #>  7 audi         a4           3.1  2008     6 auto~ f        18    27 p     comp~ #>  8 audi         a4 quattro   1.8  1999     4 manu~ 4        18    26 p     comp~ #>  9 audi         a4 quattro   1.8  1999     4 auto~ 4        16    25 p     comp~ #> 10 audi         a4 quattro   2    2008     4 manu~ 4        20    28 p     comp~ #> # ... with 224 more rows #>  #> [[3]] #> # A tibble: 234 x 12 #>    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class #>    <chr>        <chr>      <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr> #>  1 audi         a4           1.8  1999     4 auto~ f        18    29 p     comp~ #>  2 audi         a4           1.8  1999     4 manu~ f        21    29 p     comp~ #>  3 audi         a4           2    2008     4 manu~ f        20    31 p     comp~ #>  4 audi         a4           2    2008     4 auto~ f        21    30 p     comp~ #>  5 audi         a4           2.8  1999     6 auto~ f        16    26 p     comp~ #>  6 audi         a4           2.8  1999     6 manu~ f        18    26 p     comp~ #>  7 audi         a4           3.1  2008     6 auto~ f        18    27 p     comp~ #>  8 audi         a4 quattro   1.8  1999     4 manu~ 4        18    26 p     comp~ #>  9 audi         a4 quattro   1.8  1999     4 auto~ 4        16    25 p     comp~ #> 10 audi         a4 quattro   2    2008     4 manu~ 4        20    28 p     comp~ #> # ... with 224 more rows, and 1 more variable: PANEL <fct> #>  #> [[4]] #> # A tibble: 234 x 4 #>    fill      x PANEL group #>    <chr> <int> <fct> <int> #>  1 f        29 1         2 #>  2 f        29 1         2 #>  3 f        31 1         2 #>  4 f        30 1         2 #>  5 f        26 1         2 #>  6 f        26 1         2 #>  7 f        27 1         2 #>  8 4        26 1         1 #>  9 4        25 1         1 #> 10 4        28 1         1 #> # ... with 224 more rows #>  #> [[5]] #> # A tibble: 234 x 4 #>    fill      x PANEL group #>    <chr> <int> <fct> <int> #>  1 f        29 1         2 #>  2 f        29 1         2 #>  3 f        31 1         2 #>  4 f        30 1         2 #>  5 f        26 1         2 #>  6 f        26 1         2 #>  7 f        27 1         2 #>  8 4        26 1         1 #>  9 4        25 1         1 #> 10 4        28 1         1 #> # ... with 224 more rows #>  #> [[6]] #> # A tibble: 234 x 4 #>    fill      x PANEL group #>    <chr> <dbl> <fct> <int> #>  1 f        29 1         2 #>  2 f        29 1         2 #>  3 f        31 1         2 #>  4 f        30 1         2 #>  5 f        26 1         2 #>  6 f        26 1         2 #>  7 f        27 1         2 #>  8 4        26 1         1 #>  9 4        25 1         1 #> 10 4        28 1         1 #> # ... with 224 more rows #>  #> [[7]] #> # A tibble: 3 x 4 #>       x fill  PANEL group #>   <dbl> <chr> <fct> <int> #> 1  19.2 4     1         1 #> 2  28.2 f     1         2 #> 3  21   r     1         3 #>  #> [[8]] #> # A tibble: 3 x 4 #>       x fill  PANEL group #>   <dbl> <chr> <fct> <int> #> 1  19.2 4     1         1 #> 2  28.2 f     1         2 #> 3  21   r     1         3 #>  #> [[9]] #> # A tibble: 3 x 4 #>       x fill  PANEL group #>   <dbl> <chr> <fct> <int> #> 1  19.2 4     1         1 #> 2  28.2 f     1         2 #> 3  21   r     1         3 #>  #> [[10]] #> # A tibble: 3 x 4 #>       x fill  PANEL group #>   <dbl> <chr> <fct> <int> #> 1  19.2 4     1         1 #> 2  28.2 f     1         2 #> 3  21   r     1         3 #>  #> [[11]] #> # A tibble: 3 x 4 #>       x fill  PANEL group #>   <dbl> <chr> <fct> <int> #> 1  19.2 4     1         1 #> 2  28.2 f     1         2 #> 3  21   r     1         3 #>  #> [[12]] #> # A tibble: 3 x 8 #>   fill        x PANEL group colour  size linetype alpha #>   <chr>   <dbl> <fct> <int> <chr>  <dbl>    <dbl> <lgl> #> 1 #F8766D  19.2 1         1 black    0.5        1 NA    #> 2 #00BA38  28.2 1         2 black    0.5        1 NA    #> 3 #619CFF  21   1         3 black    0.5        1 NA    #>  #> [[13]] #> # A tibble: 3 x 8 #>   fill        x PANEL group colour  size linetype alpha #>   <chr>   <dbl> <fct> <int> <chr>  <dbl>    <dbl> <lgl> #> 1 #F8766D  19.2 1         1 black    0.5        1 NA    #> 2 #00BA38  28.2 1         2 black    0.5        1 NA    #> 3 #619CFF  21   1         3 black    0.5        1 NA    #>  #> [[14]] #> # A tibble: 3 x 8 #>   fill        x PANEL group colour  size linetype alpha #>   <chr>   <dbl> <fct> <int> <chr>  <dbl>    <dbl> <lgl> #> 1 #F8766D  19.2 1         1 black    0.5        1 NA    #> 2 #00BA38  28.2 1         2 black    0.5        1 NA    #> 3 #619CFF  21   1         3 black    0.5        1 NA group_present1 <- sapply(tracedump1, function(x) {   \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3 }) group_present1 #>  [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE #> [13]  TRUE  TRUE which(data_assigns)[min(which(group_present1))] #> [1] 12 ggbody(ggplot2:::ggplot_build.ggplot)[[12]] #> data <- by_layer(function(l, d) l$compute_aesthetics(d, plot)) ggbody(ggplot2:::ggplot_build.ggplot)[[7]] #> by_layer <- function(f) { #>     out <- vector(\"list\", length(data)) #>     for (i in seq_along(data)) { #>         out[[i]] <- f(l = layers[[i]], d = data[[i]]) #>     } #>     out #> }"},{"path":"/articles/casestudy-ggxmean.html","id":"digging-deeper-into-layercompute_aesthetics","dir":"Articles","previous_headings":"Step 1 - Locating the problem","what":"1.2 Digging deeper into Layer$compute_aesthetics()","title":"Debugging an extension package","text":"point realize go little deeper ggplot_build(). need inspect Layer$compute_aesthetics - compute_aesthetics method Layer ggproto. (Check quick aside Layer ggproto first time encountering , purposes vignette just need know Layer$compute_aesthetics function called inside ggplot_build() think group calculated.) Layer object returned ggplot2::layer(). don’t see function often, ’s gets returned geom_*() stat_*() functions, ’ve actually seen lot. example, call geom_bar() , ’ll get back object class LayerInstance/Layer body geom_bar() just calls layer() defaults optimized drawing bar plots. two practically : Layer objects various properties methods, including compute_aesthetics. compute_aesthetics method defined parent Layer ggproto unexported. layer returned geom_bar() simply inherits method, reflected fact class LayerInstance, also . Let’s now repeat know-nothing, brute-force exploratory process inside Layer$compute_aesthetics. , inspect output every line using ~step keyword inside trace_exprs argument locate group get computed. Step 21 Layer$compute_aesthetics seems happens. , calls unexported internal utility function called add_group(), look source code can confirm indeed located group calculated assigned. gets us half-way solving issue can’t/shouldn’t modify Layer ggproto extension packages - ’s unexported! Plus, want change behavior geom_x_mean() specifically, aesthetics can’t understand ignored calculation groups, groups layers.","code":"geom_bar() #> geom_bar: width = NULL, na.rm = FALSE, orientation = NA #> stat_count: width = NULL, na.rm = FALSE, orientation = NA #> position_stack class(geom_bar()) #> [1] \"LayerInstance\" \"Layer\"         \"ggproto\"       \"gg\" body(geom_bar) #> { #>     layer(data = data, mapping = mapping, stat = stat, geom = GeomBar,  #>         position = position, show.legend = show.legend, inherit.aes = inherit.aes,  #>         params = list(width = width, na.rm = na.rm, orientation = orientation,  #>             ...)) #> } geom_bar() #> geom_bar: width = NULL, na.rm = FALSE, orientation = NA #> stat_count: width = NULL, na.rm = FALSE, orientation = NA #> position_stack layer(   geom = GeomBar, stat = StatCount, position = PositionStack,   params = list(width = NULL, na.rm = FALSE, orientation = NA) ) #> geom_bar: width = NULL, na.rm = FALSE, orientation = NA #> stat_count: width = NULL, na.rm = FALSE, orientation = NA #> position_stack names(as.list(geom_bar())) #>  [1] \"mapping\"              \"geom_params\"          \"layer_data\"           #>  [4] \"compute_statistic\"    \"computed_mapping\"     \"compute_aesthetics\"   #>  [7] \"stat_params\"          \"map_statistic\"        \"draw_geom\"            #> [10] \"stat\"                 \"setup_layer\"          \"inherit.aes\"          #> [13] \"finish_statistics\"    \"geom\"                 \"compute_position\"     #> [16] \"position\"             \"print\"                \"data\"                 #> [19] \"aes_params\"           \"computed_stat_params\" \"computed_geom_params\" #> [22] \"compute_geom_1\"       \"compute_geom_2\"       \"show.legend\" class(ggplot2:::Layer) #> [1] \"Layer\"   \"ggproto\" \"gg\" class(geom_bar()) #> [1] \"LayerInstance\" \"Layer\"         \"ggproto\"       \"gg\" ggbody(ggplot2:::Layer$compute_aesthetics) #> [[1]] #> `{` #>  #> [[2]] #> aesthetics <- self$computed_mapping #>  #> [[3]] #> set <- names(aesthetics) %in% names(self$aes_params) #>  #> [[4]] #> calculated <- is_calculated_aes(aesthetics) #>  #> [[5]] #> modifiers <- is_scaled_aes(aesthetics) #>  #> [[6]] #> aesthetics <- aesthetics[!set & !calculated & !modifiers] #>  #> [[7]] #> if (!is.null(self$geom_params$group)) { #>     aesthetics[[\"group\"]] <- self$aes_params$group #> } #>  #> [[8]] #> scales_add_defaults(plot$scales, data, aesthetics, plot$plot_env) #>  #> [[9]] #> env <- child_env(baseenv(), stage = stage) #>  #> [[10]] #> evaled <- lapply(aesthetics, eval_tidy, data = data, env = env) #>  #> [[11]] #> evaled <- compact(evaled) #>  #> [[12]] #> warn_for_aes_extract_usage(aesthetics, data[setdiff(names(data),  #>     \"PANEL\")]) #>  #> [[13]] #> nondata_cols <- check_nondata_cols(evaled) #>  #> [[14]] #> if (length(nondata_cols) > 0) { #>     msg <- paste0(\"Aesthetics must be valid data columns. Problematic aesthetic(s): \",  #>         paste0(vapply(nondata_cols, function(x) { #>             paste0(x, \" = \", as_label(aesthetics[[x]])) #>         }, character(1)), collapse = \", \"), \". \\nDid you mistype the name of a data column or forget to add after_stat()?\") #>     abort(msg) #> } #>  #> [[15]] #> n <- nrow(data) #>  #> [[16]] #> if (n == 0) { #>     if (length(evaled) == 0) { #>         n <- 0 #>     } #>     else { #>         n <- max(vapply(evaled, length, integer(1))) #>     } #> } #>  #> [[17]] #> check_aesthetics(evaled, n) #>  #> [[18]] #> if (empty(data) && n > 0) { #>     evaled$PANEL <- 1 #> } else { #>     evaled$PANEL <- data$PANEL #> } #>  #> [[19]] #> evaled <- lapply(evaled, unname) #>  #> [[20]] #> evaled <- as_gg_data_frame(evaled) #>  #> [[21]] #> evaled <- add_group(evaled) #>  #> [[22]] #> evaled ggtrace(   method = ggplot2:::Layer$compute_aesthetics,   trace_steps = seq_along(ggbody(ggplot2:::Layer$compute_aesthetics)),   trace_exprs = quote(~step),   verbose = FALSE ) #> `ggplot2:::Layer$compute_aesthetics` now being traced.  # plot not printed for space p + aes(fill = drv) #> Triggering trace on `ggplot2:::Layer$compute_aesthetics` #> Untracing `ggplot2:::Layer$compute_aesthetics` on exit.  tracedump2 <- last_ggtrace()  group_present2 <- sapply(tracedump2, function(x) {   \"group\" %in% colnames(x) && sort(unique(x$group)) == 1:3 }) length(group_present2) #> [1] 22 which(group_present2) #> [1] 21 22 min(which(group_present2)) #> [1] 21 ggbody(ggplot2:::Layer$compute_aesthetics)[[21]] #> evaled <- add_group(evaled)"},{"path":"/articles/casestudy-ggxmean.html","id":"step-2---identifying-the-extension-point","dir":"Articles","previous_headings":"","what":"Step 2 - Identifying the extension point","title":"Debugging an extension package","text":"point, hunt next time Layer dispatches Stat Geom ggproto method transformed data group calculated, can undo grouping calculation inside Stat/Geom necessary (since Stat Geom exported recommended extension points). Going back ggplot_build(), next l$<method> call l$compute_aesthetics compute_statistic method Step 18 Let’s see happens inside Layer$compute_statistic method see next time data gets transformed passed Layer$compute_statistic setup_data method layer’s Stat ggproto Step 4. Let’s see kind information stage, whether information sufficient us implement desired design change geom_x_mean()","code":"ggbody(ggplot2:::ggplot_build.ggplot)[[18]] #> data <- by_layer(function(l, d) l$compute_statistic(d, layout)) ggbody(ggplot2:::Layer$compute_statistic) #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(new_data_frame()) #>  #> [[3]] #> self$computed_stat_params <- self$stat$setup_params(data, self$stat_params) #>  #> [[4]] #> data <- self$stat$setup_data(data, self$computed_stat_params) #>  #> [[5]] #> self$stat$compute_layer(data, self$computed_stat_params, layout) ggbody(ggplot2:::Layer$compute_statistic)[[4]] #> data <- self$stat$setup_data(data, self$computed_stat_params)"},{"path":"/articles/casestudy-ggxmean.html","id":"step-2-1---inspecting-the-setup_data-method","dir":"Articles","previous_headings":"Step 2 - Identifying the extension point","what":"Step 2.1 - Inspecting the setup_data method","title":"Debugging an extension package","text":"First, let’s figure Stat ggproto associated geom_x_mean() let’s inspect setup_data method looks like setup_data inherited parent ggproto. candidate looking class() Stat parent ggproto. decide change behavior setup_data StatXmean, ’ll need define version method, instead simlpy inherit Stat$setup_data. now, let’s grab inherited method Stat proceed inspecting behavior. inherit = TRUE argument inside ggbody(), confirm StatXmean indeed inherits Stat$setup_data Okay method just returns data default. data look like practice?","code":"class(geom_x_mean()$stat)[1] #> [1] \"StatXmean\" ggbody(ggxmean:::StatXmean$setup_data) # errors! #> Error: #> ! Method 'setup_data' is not defined for `ggxmean:::StatXmean` #> Check inheritance with `get_method(ggxmean:::StatXmean$setup_data, inherit = TRUE)` class(ggxmean:::StatXmean) #> [1] \"StatXmean\" \"Stat\"      \"ggproto\"   \"gg\" ggbody(ggxmean:::StatXmean$setup_data, inherit = TRUE) #> Method inherited from `Stat$setup_data` #> [[1]] #> `{` #>  #> [[2]] #> data"},{"path":"/articles/casestudy-ggxmean.html","id":"step-2-2---logging-the-execution-of-statsetup_data","dir":"Articles","previous_headings":"Step 2 - Identifying the extension point","what":"Step 2.2 - Logging the execution of Stat$setup_data","title":"Debugging an extension package","text":"following ggtrace() code shorthand inserting trace simply returns output last step (-1) method: see data contains information supplied aesthetics calculated PANEL group information. sufficient information purposes.","code":"ggtrace(Stat$setup_data, -1, verbose = FALSE) #> `Stat$setup_data` now being traced.  # plot not printed for space p + aes(fill = drv) #> Triggering trace on `Stat$setup_data` #> Untracing `Stat$setup_data` on exit. tibble::as_tibble(last_ggtrace()[[1]]) #> # A tibble: 234 x 4 #>    fill      x PANEL group #>    <chr> <dbl> <fct> <int> #>  1 f        29 1         2 #>  2 f        29 1         2 #>  3 f        31 1         2 #>  4 f        30 1         2 #>  5 f        26 1         2 #>  6 f        26 1         2 #>  7 f        27 1         2 #>  8 4        26 1         1 #>  9 4        25 1         1 #> 10 4        28 1         1 #> # ... with 224 more rows"},{"path":[]},{"path":"/articles/casestudy-ggxmean.html","id":"step-3-1---devising-a-plan-pseudo-code-outline","dir":"Articles","previous_headings":"Step 3 - Developing a solution","what":"Step 3.1 - Devising a plan (pseudo-code outline)","title":"Debugging an extension package","text":"’s plan. Instead setup_data method just return data receives, let’s check two conditions: , leave data alone. Otherwise… , leave data alone. Otherwise, re-calculate groups dropping extraneous variables passing data ggplot2:::add_group() .","code":""},{"path":"/articles/casestudy-ggxmean.html","id":"step-3-2---setting-up-for-testing","dir":"Articles","previous_headings":"Step 3 - Developing a solution","what":"Step 3.2 - Setting up for testing","title":"Debugging an extension package","text":"One biggest perks {ggtrace} ability log output triggered traces. ’ve seeing bit last_ggtrace() can scale . Using global_ggtrace() persistent tracing ggtrace(= FALSE), can capture data looks like inside setup_data method across two expected two unexpected cases reprex. Now tracedump3 holds value data inside setup_data method four plots interest.","code":"# Turn the global tracedump on global_ggtrace_on() #> Global tracedump activated.  ggtrace(Stat$setup_data, -1, once = FALSE, verbose = FALSE) #> `Stat$setup_data` now being traced. #> Creating a persistent trace. Remember to `gguntrace(Stat$setup_data)`!  # plots not printed for space p + aes(color = drv) #> Triggering persistent trace on `Stat$setup_data` p + aes(group = drv) #> Triggering persistent trace on `Stat$setup_data` p + aes(shape = drv) #> Triggering persistent trace on `Stat$setup_data` p + aes(fill = fl, color = drv) #> Triggering persistent trace on `Stat$setup_data`  tracedump3 <- global_ggtrace() tracedump3 <- lapply(tracedump3, `[[`, 1) # simplify  # Clean up and turn the global tracedump back off gguntrace(Stat$setup_data) #> `Stat$setup_data` no longer being traced. clear_global_ggtrace() #> Global tracedump cleared. global_ggtrace_off() #> Global tracedump deactivated.  # Label the trace dumps names(tracedump3) <- c(paste0(\"expected\", 1:2), paste0(\"unexpected\", 1:2)) names(tracedump3) #> [1] \"expected1\"   \"expected2\"   \"unexpected1\" \"unexpected2\" lapply(tracedump3, tibble::as_tibble) #> $expected1 #> # A tibble: 234 x 4 #>    colour     x PANEL group #>    <chr>  <dbl> <fct> <int> #>  1 f         29 1         2 #>  2 f         29 1         2 #>  3 f         31 1         2 #>  4 f         30 1         2 #>  5 f         26 1         2 #>  6 f         26 1         2 #>  7 f         27 1         2 #>  8 4         26 1         1 #>  9 4         25 1         1 #> 10 4         28 1         1 #> # ... with 224 more rows #>  #> $expected2 #> # A tibble: 234 x 3 #>        x group PANEL #>    <dbl> <int> <fct> #>  1    29     2 1     #>  2    29     2 1     #>  3    31     2 1     #>  4    30     2 1     #>  5    26     2 1     #>  6    26     2 1     #>  7    27     2 1     #>  8    26     1 1     #>  9    25     1 1     #> 10    28     1 1     #> # ... with 224 more rows #>  #> $unexpected1 #> # A tibble: 234 x 4 #>    shape     x PANEL group #>    <chr> <dbl> <fct> <int> #>  1 f        29 1         2 #>  2 f        29 1         2 #>  3 f        31 1         2 #>  4 f        30 1         2 #>  5 f        26 1         2 #>  6 f        26 1         2 #>  7 f        27 1         2 #>  8 4        26 1         1 #>  9 4        25 1         1 #> 10 4        28 1         1 #> # ... with 224 more rows #>  #> $unexpected2 #> # A tibble: 234 x 5 #>    fill  colour     x PANEL group #>    <chr> <chr>  <dbl> <fct> <int> #>  1 p     f         29 1         8 #>  2 p     f         29 1         8 #>  3 p     f         31 1         8 #>  4 p     f         30 1         8 #>  5 p     f         26 1         8 #>  6 p     f         26 1         8 #>  7 p     f         27 1         8 #>  8 p     4         26 1         7 #>  9 p     4         25 1         7 #> 10 p     4         28 1         7 #> # ... with 224 more rows"},{"path":[]},{"path":"/articles/casestudy-ggxmean.html","id":"part-1---check-if-group-is-derived","dir":"Articles","previous_headings":"Step 3 - Developing a solution > Step 3.3 - Tackling the problem piece by piece","what":"Part 1 - Check if group is derived","title":"Debugging an extension package","text":"first condition checking whether group explicitly supplied actually easy implement. Going back Layer$compute_aesthetics, can see PANEL column assigned first group column assigned afterwards. means group already exist, ’d appear right PANEL. exist , ’d just modified original position appear left PANEL (since PANEL can never exist ). can confirm two expected cases: can make function checks position group column relative PANEL column, use tracedump validate ","code":"colnames(tracedump3$expected1) # `aes(color = drv)` #> [1] \"colour\" \"x\"      \"PANEL\"  \"group\" colnames(tracedump3$expected2) # `aes(group = drv)` #> [1] \"x\"     \"group\" \"PANEL\" group_is_derived <- function(data) {   # Do \"group\" and \"PANEL\" appear out of order?   is.unsorted(match(c(\"group\", \"PANEL\"), colnames(data))) } group_is_derived(tracedump3$expected1) #> [1] TRUE group_is_derived(tracedump3$expected2) #> [1] FALSE"},{"path":"/articles/casestudy-ggxmean.html","id":"part-2---check-if-the-geom-can-understand-all-discrete-aesthetics","dir":"Articles","previous_headings":"Step 3 - Developing a solution > Step 3.3 - Tackling the problem piece by piece","what":"Part 2 - Check if the geom can understand all discrete aesthetics","title":"Debugging an extension package","text":"second condition, need figure aesthetics geom can understand. First, check geom geom_x_mean() uses. see uses unexported geom ggxmean:::GeomXline. gather aesthetics can handle just want check among non-positional aesthetics, set want: can now write function returns discrete variables data understood GeomXline. validate function tracedump","code":"class(geom_x_mean()$geom)[1] #> [1] \"GeomXline\" understandable_aes <- unique(c(   ggxmean:::GeomXline$required_aes,   names(ggxmean:::GeomXline$default_aes),   ggxmean:::GeomXline$optional_aes )) understandable_aes #> [1] \"x\"        \"colour\"   \"size\"     \"linetype\" \"alpha\" understandable_aes[!understandable_aes %in% c(\"x\", \"y\")] #> [1] \"colour\"   \"size\"     \"linetype\" \"alpha\" not_understandable_aes <- function(data) {   discretes <- colnames(data)[sapply(data, ggplot2:::is.discrete)]   discretes <- discretes[!discretes %in% c(\"group\", \"PANEL\")]   discretes[!discretes %in% c(\"colour\", \"size\", \"linetype\", \"alpha\")] } lengths(lapply(tracedump3, not_understandable_aes)) > 0 #>   expected1   expected2 unexpected1 unexpected2  #>       FALSE       FALSE        TRUE        TRUE not_understandable_aes(tracedump3$unexpected1) #> [1] \"shape\" not_understandable_aes(tracedump3$unexpected2) #> [1] \"fill\""},{"path":"/articles/casestudy-ggxmean.html","id":"part-3---handle-the-exception","dir":"Articles","previous_headings":"Step 3 - Developing a solution > Step 3.3 - Tackling the problem piece by piece","what":"Part 3 - Handle the exception","title":"Debugging an extension package","text":"Lastly, case groups computed using discrete variables mapped aesthetics GeomXline doesn’t understand, want re-assign groups. following function takes data, strips offending variables/columns, returns vector new groupings. returns us expected number groups unexpected reprex cases (recall unexpected2 used 12 groups now 3 ’s correctly ignoring interaction fill = fl).","code":"retrained_groups <- function(data) {   not_understandables <- not_understandable_aes(data)   data <- data[!colnames(data) %in% c(\"group\", not_understandables)]   ggplot2:::add_group(data)$group } lapply(tracedump3[3:4], function(x) { sort(unique(retrained_groups(x))) }) #> $unexpected1 #> [1] -1 #>  #> $unexpected2 #> [1] 1 2 3"},{"path":"/articles/casestudy-ggxmean.html","id":"part-4---bring-it-together","dir":"Articles","previous_headings":"Step 3 - Developing a solution > Step 3.3 - Tackling the problem piece by piece","what":"Part 4 - Bring it together","title":"Debugging an extension package","text":"Now melt functions Parts 1-3 single function become new setup_data method StatXmean. validate expected unexpected cases see indeed works! *Note ’re still using unexported ggplot2 functions like .discrete add_group. ’d normally refactor copy releasing fix, ’ll skip sake time.","code":"setup_data_new <- function(data) {   if (is.unsorted(match(c(\"group\", \"PANEL\"), colnames(data)))) {     discretes <- colnames(data)[sapply(data, ggplot2:::is.discrete)]     discretes <- discretes[!discretes %in% c(\"group\", \"PANEL\")]     not_understandables <- discretes[!discretes %in% c(\"colour\", \"size\", \"linetype\", \"alpha\")]     if (length(not_understandables) > 0) {       dummy_data <- data[!colnames(data) %in% c(\"group\", not_understandables)]       data$group <- ggplot2:::add_group(dummy_data)$group     }   }   data } tracedump3_modified <- lapply(tracedump3, setup_data_new) lapply(tracedump3_modified, function(x) sort(unique(x$group) )) #> $expected1 #> [1] 1 2 3 #>  #> $expected2 #> [1] 1 2 3 #>  #> $unexpected1 #> [1] -1 #>  #> $unexpected2 #> [1] 1 2 3"},{"path":"/articles/casestudy-ggxmean.html","id":"step-3-4---implementing-the-solution","dir":"Articles","previous_headings":"Step 3 - Developing a solution","what":"Step 3.4 - Implementing the solution","title":"Debugging an extension package","text":"’d like test whole solution user-facing layer call day. just two important pieces : create ggproto class called StatXmean2 exact copy StatXmean except also defines setup_data method defined . create layer called geom_x_mean2() exact copy geom_x_mean() except stat argument ofggplot2::layer() StatXmean2 final check original reprexes shows works intended","code":"StatXmean2 <- ggplot2::ggproto(   \"StatXmean2\",   ggplot2::Stat,   setup_data = function(data, params) {     if (is.unsorted(match(c(\"group\", \"PANEL\"), colnames(data)))) {       discretes <- colnames(data)[sapply(data, ggplot2:::is.discrete)]       discretes <- discretes[!discretes %in% c(\"group\", \"PANEL\")]       not_understandables <- discretes[!discretes %in% c(\"colour\", \"size\", \"linetype\", \"alpha\")]       if (length(not_understandables) > 0) {         dummy_data <- data[!colnames(data) %in% c(\"group\", not_understandables)]         data$group <- ggplot2:::add_group(dummy_data)$group       }     }     data   },   compute_group = function(data, scales) {     data.frame(x = mean(data$x))   },   required_aes = c(\"x\") )  geom_x_mean2 <- function(mapping = NULL, data = NULL,                         position = \"identity\", na.rm = FALSE, show.legend = NA,                         inherit.aes = TRUE, ...) {   ggplot2::layer(     stat = StatXmean2, geom = ggxmean:::GeomXline, data = data, mapping = mapping,     position = position, show.legend = show.legend, inherit.aes = inherit.aes,     params = list(na.rm = na.rm, ...)   ) } p2 <- ggplot(mpg) +   aes(x = hwy) +   geom_x_mean2()  p2 + aes(color = drv) p2 + aes(group = drv) p2 + aes(shape = drv) p2 + aes(fill = fl, color = drv)"},{"path":"/articles/casestudy-ggxmean.html","id":"step-3-5---testing-the-solution","dir":"Articles","previous_headings":"Step 3 - Developing a solution","what":"Step 3.5 - Testing the solution","title":"Debugging an extension package","text":"want write tests, can also check whether solution generalizes cases. , can see correctly works facets even groups missing facet, ’s good  can also see fails way ’s supplied explicit group aesthetic also receives another discrete mapping color  ’s one unique match fl == \"c\" drv== \"f\", unique value drv four fl categories. color scale assigns color one lines four lines just gives returns NAs (colored grey default)","code":"p2 +   aes(color = drv) +   facet_wrap(~fl) p2 + aes(group = fl, color = drv) table(mpg$drv, mpg$fl) #>     #>      c  d  e  p  r #>   4  0  2  6 20 75 #>   f  1  3  1 25 76 #>   r  0  0  1  7 17 p2 +   aes(group = fl, color = drv) +   geom_label(aes(label = fl, y = 0), stat = StatXmean2)"},{"path":"/articles/casestudy-ggxmean.html","id":"wrapping-up","dir":"Articles","previous_headings":"","what":"Wrapping up","title":"Debugging an extension package","text":"’re satisfied can now turn development mode , lets us access current installation {ggxmean} . can now also test solution current version package see whether ’d still work (although skip step ). Finally, since vignette covered real-world debugging scenario, solution submitted PR! Many thanks Gina allowing use {ggxmean} case study exploratory debugging {ggtrace}!","code":"devtools::dev_mode(on = FALSE) #> v Dev mode: OFF devtools::package_info(\"ggxmean\", FALSE, FALSE)$source #> [1] \"local\""},{"path":[]},{"path":"/articles/comparisons.html","id":"sneak-peak","dir":"Articles","previous_headings":"","what":"Sneak peak:","title":"Comparison of debugging methods","text":"debug()/debugonce() browser() + load_all() layer_data() trace() Hiroaki Yutani’s blog post {ggplot2} + browser() Pedro J. Aphalo’s {gginnards} Brodie Gaslam’s {ggbg} ggplot2 internals reference document Dewey Dunnington’s {ggdebug}, also features function name ggdebug::ggtrace use trace(). Maybe things changed last 2-3 years, trace() untrace() work ggproto methods, package shows!","code":""},{"path":"/articles/FAQ.html","id":"is-ggtrace-safe","dir":"Articles","previous_headings":"","what":"Is ggtrace() safe?","title":"Frequently asked questions","text":"ggtrace() essentially just wrapper around base::trace() designed make easy safe programmatically trace/untrace functions methods. short answer ggtrace() least safe trace(). safe trace()? beauty trace() modified function traced masks original function without overwriting . allows non-destructive modifications execution behavior. simple example, add trace replace() multiples value x 10 function enters last step. traced function looks strange runs different behavior , non-destructive. original function body safely stored away \"original\" attribute traced function original function can recovered removing trace call untrace() Beyond , ggtrace also offers extra built-safety measures: Cleans untracing exit (default behavior = TRUE) Always untraces tracing, prevents nested traces created Provides ample messages whethere existing trace (can also check is_traced()) Exits early possible method expression ill-formed informative error messages can actually act Prevents traces created functions aren’t bound variable way (.e., prevents creating traces can’t trigger) However, expression pass ggtrace() delayed evaluation without consequences. need careful running functions side effects making assignments environments (ex: self$method <- ... modify place). isn’t problem ggtrace - follow general rules reference semantics R.","code":"body(replace) #> { #>     x[list] <- values #>     x #> }  replace(1:5, 3, 30) #> [1]  1  2 30  4  5  as.list(body(replace)) #> [[1]] #> `{` #>  #> [[2]] #> x[list] <- values #>  #> [[3]] #> x  trace(replace, tracer = quote(x <- x * 10), at = 3) #> Tracing function \"replace\" in package \"base\" #> [1] \"replace\" class(replace) #> [1] \"functionWithTrace\" #> attr(,\"package\") #> [1] \"methods\"  body(replace) #> { #>     x[list] <- values #>     { #>         .doTrace(x <- x * 10, \"step 3\") #>         x #>     } #> }  replace(1:5, 3, 30) #> Tracing replace(1:5, 3, 30) step 3 #> [1]  10  20 300  40  50 attr(replace, \"original\") #> function (x, list, values)  #> { #>     x[list] <- values #>     x #> } #> <bytecode: 0x0000000014b1f8f8> #> <environment: namespace:base> untrace(replace) #> Untracing function \"replace\" in package \"base\"  body(replace) #> { #>     x[list] <- values #>     x #> }  replace(1:5, 3, 30) #> [1]  1  2 30  4  5"},{"path":[]},{"path":"/articles/FAQ.html","id":"functions","dir":"Articles","previous_headings":"What can you ggtrace()?","what":"Functions","title":"Frequently asked questions","text":"{base} functions Imported functions Custom functions","code":"sample(letters, 5) #> [1] \"g\" \"f\" \"n\" \"z\" \"l\" ggtrace(sample, 1, quote(x <- LETTERS), verbose = FALSE) #> `sample` now being traced. sample(letters, 5) #> Triggering trace on `sample` #> Untracing `sample` on exit. #> [1] \"T\" \"F\" \"Y\" \"X\" \"N\" sample(letters, 5) #> [1] \"e\" \"o\" \"g\" \"i\" \"l\" ggtrace(ggplot2::mean_se, 1, quote(cat(\"Running...\\n\")), verbose = FALSE) #> `ggplot2::mean_se` now being traced. ggplot2::mean_se(mtcars$mpg) #> Triggering trace on `ggplot2::mean_se` #> Running... #> Untracing `ggplot2::mean_se` on exit. #>          y    ymin     ymax #> 1 20.09062 19.0252 21.15605 please_return_number <- function() {   result <- runif(1)   result } please_return_number() #> [1] 0.5456977  ggtrace(please_return_number, -1, quote(result <- \"no\"), verbose = FALSE) #> `please_return_number` now being traced. please_return_number() #> Triggering trace on `please_return_number` #> Untracing `please_return_number` on exit. #> [1] \"no\""},{"path":"/articles/FAQ.html","id":"ggproto-methods","dir":"Articles","previous_headings":"What can you ggtrace()?","what":"ggproto methods","title":"Frequently asked questions","text":"Default tracing behavior untracing exit Persistent trace = FALSE explicit untracing gguntrace()","code":"library(ggplot2) boxplot_plot <- ggplot(mpg, aes(drv, hwy)) +   geom_boxplot()  boxplot_plot ggtrace(StatBoxplot$compute_group, -1, verbose = FALSE) #> `StatBoxplot$compute_group` now being traced.  # Plot not printed to save space boxplot_plot #> Triggering trace on `StatBoxplot$compute_group` #> Untracing `StatBoxplot$compute_group` on exit.  last_ggtrace() #> [[1]] #>   ymin lower middle upper ymax outliers notchupper notchlower x width #> 1   12    17     18    22   28            18.77841   17.22159 1  0.75 #>   relvarwidth flipped_aes #> 1    10.14889       FALSE global_ggtrace_state() #> [1] FALSE global_ggtrace_state(TRUE) #> Global tracedump activated. clear_global_ggtrace() #> Global tracedump cleared.  ggtrace(StatBoxplot$compute_group, -1, once = FALSE, verbose = FALSE) #> `StatBoxplot$compute_group` now being traced. #> Creating a persistent trace. Remember to `gguntrace(StatBoxplot$compute_group)`!  # Plot not printed to save space boxplot_plot #> Triggering persistent trace on `StatBoxplot$compute_group` #> Triggering persistent trace on `StatBoxplot$compute_group` #> Triggering persistent trace on `StatBoxplot$compute_group`  gguntrace(StatBoxplot$compute_group) #> `StatBoxplot$compute_group` no longer being traced.  global_ggtrace() #> $`StatBoxplot$compute_group-0x000000002465b890` #> $`StatBoxplot$compute_group-0x000000002465b890`[[1]] #>   ymin lower middle upper ymax outliers notchupper notchlower x width #> 1   12    17     18    22   28            18.77841   17.22159 1  0.75 #>   relvarwidth flipped_aes #> 1    10.14889       FALSE #>  #>  #> $`StatBoxplot$compute_group-0x00000000243122c8` #> $`StatBoxplot$compute_group-0x00000000243122c8`[[1]] #>   ymin lower middle upper ymax                                   outliers #> 1   22    26     28    29   33 17, 21, 34, 36, 36, 35, 37, 35, 44, 44, 41 #>   notchupper notchlower x width relvarwidth flipped_aes #> 1   28.46039   27.53961 2  0.75    10.29563       FALSE #>  #>  #> $`StatBoxplot$compute_group-0x000000002507d798` #> $`StatBoxplot$compute_group-0x000000002507d798`[[1]] #>   ymin lower middle upper ymax outliers notchupper notchlower x width #> 1   15    17     21    24   26              23.212     18.788 3  0.75 #>   relvarwidth flipped_aes #> 1           5       FALSE  global_ggtrace_state(FALSE) #> Global tracedump deactivated."},{"path":"/articles/FAQ.html","id":"s3s4-generics","dir":"Articles","previous_headings":"What can you ggtrace()?","what":"S3/S4 generics","title":"Frequently asked questions","text":"exported generic function ggplot_build() ggplot2 meaningful, unexported method <ggplot> class ggplot_build.ggplot() contains actual data transformation pipeline. can trace ggplot_build() method defined <ggplot> way functions","code":"body(ggplot_build) #> { #>     UseMethod(\"ggplot_build\") #> }  attr(utils::methods(\"ggplot_build\"), \"info\") #>                     visible                                 from      generic #> ggplot_build.ggplot   FALSE registered S3method for ggplot_build ggplot_build #>                      isS4 #> ggplot_build.ggplot FALSE ggtrace(ggplot2:::ggplot_build.ggplot, -1, verbose = FALSE) #> `ggplot2:::ggplot_build.ggplot` now being traced.  boxplot_plot #> Triggering trace on `ggplot2:::ggplot_build.ggplot` #> Untracing `ggplot2:::ggplot_build.ggplot` on exit. last_ggtrace()[[1]]$data[[1]] #>   ymin lower middle upper ymax                                   outliers #> 1   12    17     18    22   28                                            #> 2   22    26     28    29   33 17, 21, 34, 36, 36, 35, 37, 35, 44, 44, 41 #> 3   15    17     21    24   26                                            #>   notchupper notchlower x flipped_aes PANEL group ymin_final ymax_final  xmin #> 1   18.77841   17.22159 1       FALSE     1     1         12         28 0.625 #> 2   28.46039   27.53961 2       FALSE     1     2         17         44 1.625 #> 3   23.21200   18.78800 3       FALSE     1     3         15         26 2.625 #>    xmax xid newx new_width weight colour  fill size alpha shape linetype #> 1 1.375   1    1      0.75      1 grey20 white  0.5    NA    19    solid #> 2 2.375   2    2      0.75      1 grey20 white  0.5    NA    19    solid #> 3 3.375   3    3      0.75      1 grey20 white  0.5    NA    19    solid  identical(last_ggtrace()[[1]]$data[[1]], layer_data(boxplot_plot, 1)) #> [1] TRUE"},{"path":"/articles/FAQ.html","id":"r6-methods","dir":"Articles","previous_headings":"What can you ggtrace()?","what":"R6 methods","title":"Frequently asked questions","text":"Adopted Advanced R Ch. 14.2","code":"library(R6) Accumulator <- R6Class(\"Accumulator\", list(   sum = 0,   add = function(x = 1) {     self$sum <- self$sum + x      invisible(self)   }) ) x <- Accumulator$new() x$add(1) x$sum #> [1] 1 ggtrace(   method = x$add,   trace_steps = c(1, -1),   trace_exprs = list(     before = quote(self$sum),     after = quote(self$sum)   ),   once = FALSE,   verbose = FALSE ) #> `x$add` now being traced. #> Creating a persistent trace. Remember to `gguntrace(x$add)`! x$add(10) #> Triggering persistent trace on `x$add` last_ggtrace() #> $before #> [1] 1 #>  #> $after #> [1] 11 x$add(100) #> Triggering persistent trace on `x$add` last_ggtrace() #> $before #> [1] 11 #>  #> $after #> [1] 111 gguntrace(x$add) #> `x$add` no longer being traced. x$add(1000) x$sum #> [1] 1111"},{"path":"/articles/FAQ.html","id":"what-cant-you-ggtrace","dir":"Articles","previous_headings":"","what":"What can’t you ggtrace()?","title":"Frequently asked questions","text":"Non-functions (ex: constants, object properties). can still inspect values ggbody() Functions defined environment (ex: can’t define function trace --spot inside ggtrace()) Limited support closures (LHS $ must environment function can searched )","code":""},{"path":"/articles/FAQ.html","id":"how-can-i-save-a-modified-ggplot","dir":"Articles","previous_headings":"","what":"How can I save a modified ggplot?","title":"Frequently asked questions","text":"trace internals ggplot, doesn’t directly modify instructions plotting. Instead, changes certain components behave executed. means get different ggplot following code original_plot traced modifications, since original_plot executed . looks like worked first print …  variable modified_pot doesn’t hold modified code generating plot. Instead, just happened trigger trace ggplot_build.ggplot(). next time runs, ’s ran normal behavior original_plot.  capture actual figure generated ggplot, can use ggplotGrob(), returns Graphical object representation plot: get object class <gtable>, can draw device like grob:  can also use ggsave() render <gtable> image: Still, modified_plot graphical representation plot ggplot object can’t keep adding layers . grobs limiting sense. ’s totally limiting like raster image figure. example, patchwork patchwork::wrap_ggplot_grob() allows <gtable> properly aligned ggplots.","code":"original_plot <- ggplot(mtcars, aes(hp, mpg)) + geom_point()  ggtrace(ggplot2:::ggplot_build.ggplot, -1, quote(data[[1]]$colour <- \"red\"), verbose = FALSE) #> `ggplot2:::ggplot_build.ggplot` now being traced.  modified_plot <- original_plot modified_plot #> Triggering trace on `ggplot2:::ggplot_build.ggplot` #> Untracing `ggplot2:::ggplot_build.ggplot` on exit. modified_plot ggtrace(ggplot2:::ggplot_build.ggplot, -1, quote(data[[1]]$colour <- \"red\"), verbose = FALSE) #> `ggplot2:::ggplot_build.ggplot` now being traced.  modified_plot <- ggplotGrob(original_plot) #> Triggering trace on `ggplot2:::ggplot_build.ggplot` #> Untracing `ggplot2:::ggplot_build.ggplot` on exit.  modified_plot #> TableGrob (12 x 9) \"layout\": 18 grobs #>     z         cells       name                                          grob #> 1   0 ( 1-12, 1- 9) background               rect[plot.background..rect.357] #> 2   5 ( 6- 6, 4- 4)     spacer                                zeroGrob[NULL] #> 3   7 ( 7- 7, 4- 4)     axis-l           absoluteGrob[GRID.absoluteGrob.345] #> 4   3 ( 8- 8, 4- 4)     spacer                                zeroGrob[NULL] #> 5   6 ( 6- 6, 5- 5)     axis-t                                zeroGrob[NULL] #> 6   1 ( 7- 7, 5- 5)      panel                      gTree[panel-1.gTree.337] #> 7   9 ( 8- 8, 5- 5)     axis-b           absoluteGrob[GRID.absoluteGrob.341] #> 8   4 ( 6- 6, 6- 6)     spacer                                zeroGrob[NULL] #> 9   8 ( 7- 7, 6- 6)     axis-r                                zeroGrob[NULL] #> 10  2 ( 8- 8, 6- 6)     spacer                                zeroGrob[NULL] #> 11 10 ( 5- 5, 5- 5)     xlab-t                                zeroGrob[NULL] #> 12 11 ( 9- 9, 5- 5)     xlab-b titleGrob[axis.title.x.bottom..titleGrob.348] #> 13 12 ( 7- 7, 3- 3)     ylab-l   titleGrob[axis.title.y.left..titleGrob.351] #> 14 13 ( 7- 7, 7- 7)     ylab-r                                zeroGrob[NULL] #> 15 14 ( 4- 4, 5- 5)   subtitle         zeroGrob[plot.subtitle..zeroGrob.353] #> 16 15 ( 3- 3, 5- 5)      title            zeroGrob[plot.title..zeroGrob.352] #> 17 16 (10-10, 5- 5)    caption          zeroGrob[plot.caption..zeroGrob.355] #> 18 17 ( 2- 2, 2- 2)        tag              zeroGrob[plot.tag..zeroGrob.354] class(modified_plot) #> [1] \"gtable\" \"gTree\"  \"grob\"   \"gDesc\"  library(grid) grid.newpage() grid.draw(modified_plot) # Not ran  ggsave(filename = \"modified_plot.png\", plot = modified_plot, ...) library(patchwork) original_plot_titled <- original_plot + ggtitle(\"original plot\")  # Panels get aligned since `modified_plot` contains info about that original_plot_titled + wrap_ggplot_grob(modified_plot)"},{"path":"/articles/intro.html","id":"under-construction","dir":"Articles","previous_headings":"","what":"Under construction","title":"Introduction to ggtrace()","text":"Slides ggplot internals / {ggtrace} talk December 4th 2021: https://yjunechoe.github.io/ggtrace-talk","code":"library(ggtrace)"},{"path":"/articles/showcase-aes_evaluation.html","id":"under-construction","dir":"Articles","previous_headings":"","what":"Under construction","title":"Showcase: aes evaluation","text":"","code":"library(ggtrace) library(ggplot2)"},{"path":"/articles/showcase-aes_evaluation.html","id":"sneak-peak","dir":"Articles","previous_headings":"","what":"Sneak peak:","title":"Showcase: aes evaluation","text":"Read draft!","code":""},{"path":"/articles/showcase-ggplot_build.html","id":"under-construction","dir":"Articles","previous_headings":"","what":"Under construction","title":"Showcase: ggplot build","text":"","code":"library(ggtrace) library(ggplot2)"},{"path":"/articles/showcase-ggplot_build.html","id":"sneak-peak","dir":"Articles","previous_headings":"","what":"Sneak peak:","title":"Showcase: ggplot build","text":"Read draft!","code":""},{"path":[]},{"path":"/articles/technical-details.html","id":"sneak-peak","dir":"Articles","previous_headings":"","what":"Sneak peak:","title":"Technical details","text":"quick trace (tracer, , edit) ’s best debugging tool ever Getting arbitrary expressions evaluated inside tracer ggtrace works","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"June Choe. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Choe J (2022). ggtrace: Programmatically debug ggproto methods trace. https://yjunechoe.github.io/ggtrace, https://github.com/yjunechoe/ggtrace.","code":"@Manual{,   title = {ggtrace: Programmatically debug ggproto methods with trace},   author = {June Choe},   year = {2022},   note = {https://yjunechoe.github.io/ggtrace, https://github.com/yjunechoe/ggtrace}, }"},{"path":[]},{"path":[]},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"ggtrace","text":"can install development version GitHub : 📦 package website: https://yjunechoe.github.io/ggtrace","code":"# install.packages(\"remotes\") remotes::install_github(\"yjunechoe/ggtrace\")  library(ggtrace) # v0.5.0"},{"path":"/index.html","id":"extending-basetrace-with-ggtrace","dir":"","previous_headings":"","what":"Extending base::trace() with ggtrace()","title":"ggtrace","text":"low-level function ggtrace() designed interacting functions ggproto methods ggplot2 ecosystem, “outside”. Formally put, ggtrace() allows user inject arbitrary expressions (called traces) functions methods evaluated execution ggplot. “triggered” evaluation ggplot, traces may modify resulting graphical output, may simply log values “tracedump” inspection user. Check FAQ vignette details. Briefly, three key arguments ggtrace(): - method: function/method trace - trace_steps: method body inject expressions - trace_exprs expressions inject step simple example: Essentially, ggtrace() allows inject code function safely/temporarily change execution behavior. following code injects code z <- z * 10 right dummy_fn enters third “step” body. Note value trace_exprs must type “language”, ’re simply calling “code” . idea give ggtrace() code evaluate inside function ran later. often, typing actual code wrapping quote() suffices, complex injections see Expressions chapter Advanced R ggtrace() call, next time dummy_fn called run injected code. Essentially, dummy_fn ran following modified code just now: know ’s line targeted trace_steps = 3 ggtrace() call? function ggbody() returns body function/method list, allows inspect expressions body evaluated step. ggtrace() injects expression right entering step specified trace_steps, setting value 3 tell inject z <- z * 10 right ggbody(dummy_fn)[[3]] evaluated. Note trace placed ggtrace() triggered, original function/method restored (.e., trace removed). can also check whether function currently traced is_traced(). prevent trace removing exit, can set = FALSE makes trace persistent, meaning explicitly removed gguntrace() Beyond basic capabilities, ggtrace() offers two features:","code":"dummy_fn <- function(x = 1, y = 2) {   z <- x + y   x <- 10   return(z) } dummy_fn() #> [1] 3 ggtrace(   method = dummy_fn,   trace_steps = 3,   trace_exprs = quote(z <- z * 10) ) #> `dummy_fn` now being traced. dummy_fn() #> Triggering trace on `dummy_fn` #> Untracing `dummy_fn` on exit. #> [1] 30 dummy_fn_TRACED1 <- function(x = 1, y = 2) {   z <- x + y   z <- z * 10 #< Look here!   x <- 10   return(z) } dummy_fn_TRACED1() #> [1] 30 ggbody(dummy_fn) #> [[1]] #> `{` #>  #> [[2]] #> z <- x + y #>  #> [[3]] #> x <- 10 #>  #> [[4]] #> return(z)  ggbody(dummy_fn)[[3]] #> x <- 10 dummy_fn() #> [1] 3 is_traced(dummy_fn) #> [1] FALSE ggtrace(   method = dummy_fn,   trace_steps = 3,   trace_exprs = quote(z <- z * 10),   once = FALSE #< here! ) #> `dummy_fn` now being traced. #> Creating a persistent trace. Remember to `gguntrace(dummy_fn)`!  dummy_fn() #> Triggering persistent trace on `dummy_fn` #> [1] 30 dummy_fn() #> Triggering persistent trace on `dummy_fn` #> [1] 30  is_traced(dummy_fn) #> [1] TRUE  gguntrace(dummy_fn) #> `dummy_fn` no longer being traced. is_traced(dummy_fn) #> [1] FALSE"},{"path":"/index.html","id":"1-shared-state-across-trace-expressions","dir":"","previous_headings":"Extending base::trace() with ggtrace()","what":"1. Shared state across trace expressions","title":"ggtrace","text":"values trace_steps trace_exprs can length > 1 , multiply z 10 right dummy_fn enters Steps 3 4 function just ran following modified code: Thus, even though injected multiple expressions, evaluated environment thus part single trace created ggtrace(). Also, note trace_exprs recycled meet length trace_steps. explicit spellout look like following:","code":"ggtrace(   method = dummy_fn,   trace_steps = c(3, 4),   trace_exprs = quote(z <- z * 10) ) #> `dummy_fn` now being traced. dummy_fn() #> Triggering trace on `dummy_fn` #> Untracing `dummy_fn` on exit. #> [1] 300 dummy_fn_TRACED2 <- function(x = 1, y = 2) {   z <- x + y   z <- z * 10 #< Look here!   x <- 10   z <- z * 10 #< Look here!   return(z) } dummy_fn_TRACED2() #> [1] 300 ggtrace(   method = dummy_fn,   trace_steps = c(3, 4),   trace_exprs = list(     quote(z <- z * 10),     quote(z <- z * 10)   ) )"},{"path":"/index.html","id":"2-logging-of-evaluated-trace-expressions","dir":"","previous_headings":"Extending base::trace() with ggtrace()","what":"2. Logging of evaluated trace expressions","title":"ggtrace","text":"output injected expressions logged “tracedumps”, two. First, last_ggtrace() stores output last trace. , evaluate x upon entering dummy_fn (Step 1), right returns (Step 4). Note can target last step negative indices like -1, count backwards last step. course return value changed, can inspect output evaluating x two places last_ggtrace(): trace_exprs named list expressions, tracedump carry names well Second, global_ggtrace() stores output traces. particularly useful conjunction = FALSE want inspect multiple ggtrace()s . usecases don’t need go far, need documentation page information.","code":"ggtrace(   method = dummy_fn,   trace_steps = c(1, -1),   trace_exprs = quote(x), ) #> `dummy_fn` now being traced. dummy_fn() #> Triggering trace on `dummy_fn` #> Untracing `dummy_fn` on exit. #> [1] 3 last_ggtrace() #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 10 ggtrace(   method = dummy_fn,   trace_steps = c(1, -1),   trace_exprs = list(     \"x_after_begin\" = quote(x),     \"x_before_end\"  = quote(x)   ), ) #> `dummy_fn` now being traced. dummy_fn() #> Triggering trace on `dummy_fn` #> Untracing `dummy_fn` on exit. #> [1] 3  last_ggtrace() #> $x_after_begin #> [1] 1 #>  #> $x_before_end #> [1] 10"},{"path":"/index.html","id":"workflows-for-interacting-with-ggplot-internals","dir":"","previous_headings":"","what":"Workflows for interacting with ggplot internals","title":"ggtrace","text":"Admittedly, ggtrace() bit clunky interactive explorations ggplot internals. address , offer “workflow” functions form ggtrace_{action}_{value}(). grouped three workflows: Inspect, Capture, Highjack. NOTE: Making workflow functions requires hint knowledge ggplot internals, namely fact ggproto objects like Stat Geom exists, ggprotos methods step different parts ggplot build/render pipeline modify data. completely new concepts, least watch Thomas Lin Pedersen’s talk Extending ability extend ggplot2 proceeding.","code":"library(ggplot2)"},{"path":"/index.html","id":"walkthrough-with-geom_smooth","dir":"","previous_headings":"Workflows for interacting with ggplot internals","what":"Walkthrough with geom_smooth()","title":"ggtrace","text":"Say want learn geom_smooth() layer works, exactly , ’re going adopt example ggplot2 internals chapter ggplot book  Let’s focus Stat ggproto. see geom_smooth() uses StatSmooth ggproto bulk work Stat done compute_* family methods. ’ll focus compute_group , looks like following:","code":"class(geom_smooth()) #> [1] \"LayerInstance\" \"Layer\"         \"ggproto\"       \"gg\"  geom_smooth() #> geom_smooth: na.rm = FALSE, orientation = NA, se = TRUE #> stat_smooth: na.rm = FALSE, orientation = NA, se = TRUE #> position_identity p <- ggplot(mpg, aes(displ, hwy, color = drv)) +    geom_point(position = position_jitter(seed = 1116)) +   geom_smooth(method = \"lm\", formula = y ~ x) +    facet_wrap(vars(year)) +    ggtitle(\"A plot for expository purposes\") p class(geom_smooth()$stat) #> [1] \"StatSmooth\" \"Stat\"       \"ggproto\"    \"gg\" identical(StatSmooth, geom_smooth()$stat) #> [1] TRUE get_method(StatSmooth$compute_group) #> function (data, scales, method = NULL, formula = NULL, se = TRUE,  #>     n = 80, span = 0.75, fullrange = FALSE, xseq = NULL, level = 0.95,  #>     method.args = list(), na.rm = FALSE, flipped_aes = NA)  #> { #>     data <- flip_data(data, flipped_aes) #>     if (length(unique(data$x)) < 2) { #>         return(new_data_frame()) #>     } #>     if (is.null(data$weight))  #>         data$weight <- 1 #>     if (is.null(xseq)) { #>         if (is.integer(data$x)) { #>             if (fullrange) { #>                 xseq <- scales$x$dimension() #>             } #>             else { #>                 xseq <- sort(unique(data$x)) #>             } #>         } #>         else { #>             if (fullrange) { #>                 range <- scales$x$dimension() #>             } #>             else { #>                 range <- range(data$x, na.rm = TRUE) #>             } #>             xseq <- seq(range[1], range[2], length.out = n) #>         } #>     } #>     if (identical(method, \"loess\")) { #>         method.args$span <- span #>     } #>     if (is.character(method)) { #>         if (identical(method, \"gam\")) { #>             method <- mgcv::gam #>         } #>         else { #>             method <- match.fun(method) #>         } #>     } #>     if (identical(method, mgcv::gam) && is.null(method.args$method)) { #>         method.args$method <- \"REML\" #>     } #>     base.args <- list(quote(formula), data = quote(data), weights = quote(weight)) #>     model <- do.call(method, c(base.args, method.args)) #>     prediction <- predictdf(model, xseq, se, level) #>     prediction$flipped_aes <- flipped_aes #>     flip_data(prediction, flipped_aes) #> } #> <bytecode: 0x0000000018ef18f8> #> <environment: namespace:ggplot2>"},{"path":"/index.html","id":"inspect","dir":"","previous_headings":"Workflows for interacting with ggplot internals","what":"Inspect","title":"ggtrace","text":"introduce first workflow function ggtrace_inspect_n(), takes ggplot first argument ggproto method second argument, returning number times ggproto method called ggplot’s evaluation: might guessed, StatSmooth$compute_group called fitted line (group) plot can saw get_method(), compute_group just good ol’ function. function actually return? can answer another workflow function ggtrace_inspect_return(), shares similar syntax: Note ggtrace_inspect_return() gave us 1 dataframe, corresponding return value StatSmooth$compute_group first time called. comes default value third argument cond set quote(._counter_ == 1). might guessed, ._counter_ internal variable keeps track many times method called. case, ggtrace_inspect_return() giving us return value method first run, .e., first group first panel. instead wanted get return value StatSmooth$compute_group third group second panel, example, can one two ways: Set value cond expression evaluates true panel group: Find counter value condition satisfied ggtrace_inspect_which(), simply check value ._counter_ back ggtrace_inspect_return(): two approaches work :","code":"ggtrace_inspect_n(x = p, method = StatSmooth$compute_group) #> [1] 6 return_val <- ggtrace_inspect_return(x = p, method = StatSmooth$compute_group) nrow(return_val) #> [1] 80 head(return_val) #>          x        y     ymin     ymax        se flipped_aes #> 1 1.800000 24.33592 23.07845 25.59339 0.6250675       FALSE #> 2 1.859494 24.17860 22.94830 25.40890 0.6115600       FALSE #> 3 1.918987 24.02127 22.81795 25.22460 0.5981528       FALSE #> 4 1.978481 23.86395 22.68738 25.04052 0.5848527       FALSE #> 5 2.037975 23.70663 22.55658 24.85668 0.5716673       FALSE #> 6 2.097468 23.54931 22.42554 24.67307 0.5586045       FALSE return_val_2_3_A <- ggtrace_inspect_return(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$PANEL[1] == 2 && data$group[1] == 3) ) ggtrace_inspect_which(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$PANEL[1] == 2 && data$group[1] == 3) ) #> [1] 6  return_val_2_3_B <- ggtrace_inspect_return(   x = p,   method = StatSmooth$compute_group,   cond = quote(._counter_ == 6) ) identical(return_val_2_3_A, return_val_2_3_B) #> [1] TRUE"},{"path":"/index.html","id":"capture","dir":"","previous_headings":"Workflows for interacting with ggplot internals","what":"Capture","title":"ggtrace","text":"Okay, know StatSmooth$compute_group returns, return value change different input? generally put, StatSmooth$compute_group behave different contexts? answer making bunch different plots using geom_smooth() repeating inspection workflow. Alternatively, can capture call StatSmooth$compute_group extract function ggtrace_capture_fn(): captured_fn_2_3 essentially snapshot compute_group called third group second panel. Simply calling captured_fn_2_2 gives us expected return value: true power “capture” workflow functions lies ability interact captured. case ggtrace_capture_fn(), returned function arguments passed execution stored formals. words, “pre-filled” original values, can inspect formals(): makes convenient us explore behavior different arguments passed . example, flipped_aes = TRUE, get xmin xmax columns replacing ymin ymax: sense, can effectively simulate happens geom_smooth(orientation = \"y\") without needing construct entirely different ggplot. another example, set confidence interval 10% level = 0.1, ymin ymax values deviate less y value: Lastly, let’s talk data variable ’ve using inside cond argument workflow functions. data$group data$PANEL? know data looks like? answer actually simple: ’s argument passed StatSmooth$compute_group. already saw value briefly formals(captured_fn_2_3), target explcitly can also use ggtrace_inspect_vars(): see PANEL group columns conveniently give us information panel group compute_group calculations .","code":"captured_fn_2_3 <- ggtrace_capture_fn(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$PANEL[1] == 2 && data$group[1] == 3) ) identical(return_val_2_3_A, captured_fn_2_3()) #> [1] TRUE formals(captured_fn_2_3) #> $data #>      x  y colour PANEL group #> 10 5.3 20      r     2     3 #> 11 5.3 15      r     2     3 #> 12 5.3 20      r     2     3 #> 13 6.0 17      r     2     3 #> 14 6.2 26      r     2     3 #> 15 6.2 25      r     2     3 #> 16 7.0 24      r     2     3 #> 43 5.4 18      r     2     3 #> 48 4.0 26      r     2     3 #> 49 4.0 24      r     2     3 #> 50 4.6 23      r     2     3 #> 51 4.6 22      r     2     3 #> 52 5.4 20      r     2     3 #> 73 5.4 18      r     2     3 #>  #> $scales #> $scales$x #> <ScaleContinuousPosition> #>  Range:  1.56 -- 7.02 #>  Limits: 1.56 -- 7.02 #>  #> $scales$y #> <ScaleContinuousPosition> #>  Range:  10.4 -- 44.2 #>  Limits: 10.4 -- 44.2 #>  #>  #> $method #> [1] \"lm\" #>  #> $formula #> y ~ x #> <environment: 0x000000001ac3e960> #>  #> $se #> [1] TRUE #>  #> $n #> [1] 80 #>  #> $span #> [1] 0.75 #>  #> $fullrange #> [1] FALSE #>  #> $xseq #> NULL #>  #> $level #> [1] 0.95 #>  #> $method.args #> list() #>  #> $na.rm #> [1] FALSE #>  #> $flipped_aes #> [1] FALSE head(captured_fn_2_3(flipped_aes = TRUE)) #>          y        x     xmin     xmax        se flipped_aes #> 1 15.00000 5.450710 4.369619 6.531802 0.4961840        TRUE #> 2 15.13924 5.448163 4.385577 6.510749 0.4876904        TRUE #> 3 15.27848 5.445616 4.401438 6.489794 0.4792416        TRUE #> 4 15.41772 5.443068 4.417196 6.468941 0.4708400        TRUE #> 5 15.55696 5.440521 4.432846 6.448196 0.4624882        TRUE #> 6 15.69620 5.437974 4.448381 6.427566 0.4541888        TRUE head(captured_fn_2_3(level = 0.1)) #>          x        y     ymin     ymax       se flipped_aes #> 1 4.000000 21.70513 21.46539 21.94487 1.867921       FALSE #> 2 4.037975 21.69321 21.45840 21.92801 1.829458       FALSE #> 3 4.075949 21.68128 21.45137 21.91119 1.791313       FALSE #> 4 4.113924 21.66936 21.44430 21.89442 1.753509       FALSE #> 5 4.151899 21.65743 21.43718 21.87769 1.716067       FALSE #> 6 4.189873 21.64551 21.43001 21.86101 1.679011       FALSE # Get value of `data` at the start of the method `at = 1L`\"  ggtrace_inspect_vars(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$PANEL[1] == 2 && data$group[1] == 3),   at = 1L,   vars = \"data\" ) #> $Step1 #>      x  y colour PANEL group #> 10 5.3 20      r     2     3 #> 11 5.3 15      r     2     3 #> 12 5.3 20      r     2     3 #> 13 6.0 17      r     2     3 #> 14 6.2 26      r     2     3 #> 15 6.2 25      r     2     3 #> 16 7.0 24      r     2     3 #> 43 5.4 18      r     2     3 #> 48 4.0 26      r     2     3 #> 49 4.0 24      r     2     3 #> 50 4.6 23      r     2     3 #> 51 4.6 22      r     2     3 #> 52 5.4 20      r     2     3 #> 73 5.4 18      r     2     3  # Alternatively, `formals(captured_fn_2_3)$data` also works in this case"},{"path":"/index.html","id":"highjack","dir":"","previous_headings":"Workflows for interacting with ggplot internals","what":"Highjack","title":"ggtrace","text":"understanding StatSmooth$compute_group works, may want test hypotheses happen method returned something else. Let’s revisit examples Capture workflow. third group second panel calculated conservative confidence interval (level = 0.1)? effect graphical output? answer question, use ggtrace_highjack_return() method return entirely different value, help rlang package. First store modified return value variable: target group inside cond pass modified values value argument using !! rlang::expr()  confidence band nearly invisible fitted line ’s capturing 10% confidence interval! ’s another example make method fit predictions loess regression instead. use ggtrace_highjack_return() -line calculation new return value using captured function captured_fn_2_3() (value = rlang::expr(!!captured_fn_2_3(method = \"loess\"))). achieve directly, can use ggtrace_highjack_args() set values list(method = \"loess\"):  Lastly, value argument ggtrace_highjack_return() exposes internal function called returnValue() simply returns original return value. Computing allows --fly modifications graphical output. example, can “intercept” dataframe output, data wrangling , method return instead. , hack data group make look like ’s absurd degree heteroskedasticity:","code":"modified_return_smooth <- captured_fn_2_3(level = 0.1) ggtrace_highjack_return(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$PANEL[1] == 2 && data$group[1] == 3),   value = rlang::expr(!!modified_return_smooth) ) ggtrace_highjack_args(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$PANEL[1] == 2 && data$group[1] == 3),   values = list(method = \"loess\") ) library(dplyr) #> Warning: package 'dplyr' was built under R version 4.1.2 #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union ggtrace_highjack_return(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$PANEL[1] == 2 && data$group[1] == 3),   value = quote({          spread_seq <- seq(0, 10, length.out = nrow(returnValue()))     returnValue() %>%        mutate(         ymin = y - se * spread_seq[row_number()],         ymax = y + se * spread_seq[row_number()]       )        }) )"},{"path":"/index.html","id":"middle-ground-approach-with_ggtrace","dir":"","previous_headings":"","what":"Middle-ground approach with_ggtrace()","title":"ggtrace","text":"far ’ve seen low-level function ggtrace() high-level family workflow functions ggtrace_{action}_{value}(). get familiar ggplot internals start using ggtrace() “hack ” internals (moving learner developer, sense), might want exploit power convenience ggtrace provides across two designs. provide with_ggtrace(), wraps around ggtrace() give access full power, keeping effects localized (e.g., side-effects) therefore making fitting functional programming workflow. Like ggtrace(), can inject code different steps method runs:  like workflow functions, can conditional traces evaluate condition met, using statements inside trace_exprs = FALSE.  course, limited objects ggplot2 package . can fun hacking extension packages well!","code":"with_ggtrace(   x = p + facet_grid(year ~ drv),   method = Layout$render,   trace_steps = c(5, 8),   trace_exprs = rlang::exprs(          {       # First, turn all panels except the 4th semi-transparent       panels[-4] <- lapply(panels[-4], function(panel) {         editGrob(panel, gp = gpar(alpha = .4))       })       # Second, give red outline and fill to 4th panel       panels[[4]] <- gTree(children = gList(panels[[4]],         rectGrob(x = 0.5, y = 0.5, width = 1, height = 1,                  gp = gpar(col = \"red\", lwd = 5, fill = \"red\", alpha = 0.1))       ))     },          {       # Third, give it some emphasis by connecting to facet strips       outline_rect <- rectGrob(         x = 0.5, y = 0.5, width = 1, height = 1,         gp = gpar(col = \"red\", lwd = 2, fill = NA)       )       plot_table <- gtable_add_grob(         plot_table, outline_rect,         t = 1, l = 2, b = 5, r = 2, z = Inf       )       plot_table <- gtable_add_grob(         plot_table, outline_rect,         t = 5, l = 2, b = 5, r = 7, z = Inf       )     }        ),   out = \"g\" ) with_ggtrace(   p,   GeomRibbon$draw_group,   trace_steps = -1,   trace_exprs = quote({     # Give gradient fill to the confidence bands for group 3     if (data$group[1] == 3) {       g_poly <- editGrob(         g_poly,         gp = gpar(fill = linearGradient(           colours = c(\"purple\", \"skyblue\", \"pink\"),           stops = c(0, 0.5, 1),           x1 = 0, x2 = 1, y1 = 0, y2 = 0         ))       )     }   }),   once = FALSE,   out = \"g\" ) library(ggh4x)  # Example from - https://teunbrand.github.io/ggh4x/articles/Facets.html ----  ## Base plot ==== p <- ggplot(mpg, aes(displ, hwy, colour = as.factor(cyl))) + geom_point() +   labs(x = \"Engine displacement\", y = \"Highway miles per gallon\") +   guides(colour = \"none\")  ## Fixed-aspect plot with free & independent scales using `ggh4x::facet_grid2()` ==== p2 <- p +   ggh4x::facet_grid2(vars(year), vars(drv), scales = \"free\", independent = \"all\") +   theme_grey(base_size = 9) +   theme(aspect.ratio = 1)  # Highjacking the plot's execution using `ggtrace::with_ggtrace()` ---- with_ggtrace(      ## Argument 1: The ggplot to interact with durings its execution ====   x = p2,      ## Argument 2: The method to inject code into ====   method = FacetGrid2$draw_panels,      ## Argument 3: The step in the method right before `panels` and `axes` ====   ## are merged into the `panel_table` <gtable> and shipped off   trace_steps = 13, # See `ggbody(FacetGrid2$draw_panels)`      ## Argument 4: The code injection to rotate the 2nd panel (1st row, 2nd column) ====   trace_exprs = quote({          ### FIRST, specify row/column of panel to target ####     row <- 1     col <- 2     target_panel <- layout[layout$ROW == row & layout$COL == col, ]$PANEL     left_axis    <- axes$left[[row, col]]     bottom_axis  <- axes$bottom[[row, col]]          ### SECOND, replace target panelwith a version of itself ####     ### that has its axes attached to itself, using `grid::gTree()`     panels[[target_panel]] <- gTree(              ##### Argument `children`: a list (`grid::gTree()`) of three grobs:       children = gList(                  ###### 1. The original panel itself         panels[[target_panel]],                  ###### 2. Resized/reoriented left y-axis for that panel         editGrob(           left_axis,           vp = viewport(             x = unit(0.5, \"npc\") - grobWidth(left_axis) / 2,             just = c(\"right\")           )         ),                  ###### 3. Resized/repositioned bottom x-axis for that panel         editGrob(           bottom_axis,           vp = viewport(             y = unit(0.5, \"npc\") - grobHeight(bottom_axis) / 2,             just = c(\"top\")           )         )                ),              ##### Argument `vp`: Rotation for this combination of three grobs       vp = viewport(width = .7, height = .7, angle = 45)            )          ### THIRD, \"remove\" the original axes for that panel ####     axes$left[[row, col]]    <- zeroGrob()      axes$bottom[[row, col]]  <- zeroGrob()        }),      ## Argument `out`: The return value for `with_ggtrace()` ====   ## \"gtable\" returns the graphical output after injecting the code   out = \"gtable\" # you can also use the \"g\" shorthand    )"},{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2021 June Choe Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/reference/get_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Get information about ggproto methods — get_method","title":"Get information about ggproto methods — get_method","text":"Get information ggproto methods","code":""},{"path":"/reference/get_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get information about ggproto methods — get_method","text":"","code":"get_method(method, inherit = FALSE)  get_method_inheritance(obj, trim_overriden = TRUE)  ggbody(method, inherit = FALSE, as.list = TRUE)  ggformals(method, inherit = FALSE)"},{"path":"/reference/get_method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get information about ggproto methods — get_method","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method inherit Whether method searched closest parent. Defaults FALSE. TRUE, returns parent's method corresponding ggbody() code message. obj ggproto object trim_overriden Whether get_method_inheritance recursively hide methods defined parent. .list Whether ggbody() return body method list. Defaults TRUE.","code":""},{"path":"/reference/get_method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get information about ggproto methods — get_method","text":"list","code":""},{"path":"/reference/get_method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get information about ggproto methods — get_method","text":"get_method() returns method. get_method_inheritance() lists available methods self parent ggprotos. ggbody() returns body method. ggformals() returns formals method.","code":""},{"path":"/reference/get_method.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Get information about ggproto methods — get_method","text":"get_method() calls get(\"method\", ggproto) hood. get(\"method\", ggproto) syntax long form ggproto$method retrieves actual function body. subtle important difference inspecting ggproto methods. example, works: debugonce(get(\"compute_group\", StatCount)) fails insert break point: debugonce(StatCount$compute_group) get_method() designed worry distinction.","code":""},{"path":"/reference/get_method.html","id":"gotchas","dir":"Reference","previous_headings":"","what":"Gotchas","title":"Get information about ggproto methods — get_method","text":"method traced via ggtrace() ggedit(), get_method() return current modified state method. v0.3.5, calling get_method() method trace return warning emphasize fact. using inherit = TRUE, make sure ggproto objects class(ggproto) available (loading packages defined, example). hood, get_method() loops parents search method, needs able evaluate element class(ggproto) object.","code":""},{"path":"/reference/get_method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get information about ggproto methods — get_method","text":"","code":"library(ggplot2)  # Uninformative StatCount$compute_group #> <ggproto method> #>   <Wrapper function> #>     function (...)  #> f(..., self = self) #>  #>   <Inner function (f)> #>     function (self, data, scales, width = NULL, flipped_aes = FALSE)  #> { #>     data <- flip_data(data, flipped_aes) #>     x <- data$x #>     weight <- data$weight %||% rep(1, length(x)) #>     count <- as.numeric(tapply(weight, x, sum, na.rm = TRUE)) #>     count[is.na(count)] <- 0 #>     bars <- new_data_frame(list(count = count, prop = count/sum(abs(count)),  #>         x = sort(unique(x)), width = width, flipped_aes = flipped_aes),  #>         n = length(count)) #>     flip_data(bars, flipped_aes) #> } formals(StatCount$compute_group) #> $... #>  #>  body(StatCount$compute_group) #> f(..., self = self)  # Errors # get(StatCount$compute_group)  # Informative get_method(StatCount$compute_group) #> function (self, data, scales, width = NULL, flipped_aes = FALSE)  #> { #>     data <- flip_data(data, flipped_aes) #>     x <- data$x #>     weight <- data$weight %||% rep(1, length(x)) #>     count <- as.numeric(tapply(weight, x, sum, na.rm = TRUE)) #>     count[is.na(count)] <- 0 #>     bars <- new_data_frame(list(count = count, prop = count/sum(abs(count)),  #>         x = sort(unique(x)), width = width, flipped_aes = flipped_aes),  #>         n = length(count)) #>     flip_data(bars, flipped_aes) #> } #> <bytecode: 0x000000002c964488> #> <environment: namespace:ggplot2> ggformals(StatCount$compute_group) # formals(get_method(StatCount$compute_group)) #> $self #>  #>  #> $data #>  #>  #> $scales #>  #>  #> $width #> NULL #>  #> $flipped_aes #> [1] FALSE #>  ggbody(StatCount$compute_group)    # body(get_method(StatCount$compute_group)) #> [[1]] #> `{` #>  #> [[2]] #> data <- flip_data(data, flipped_aes) #>  #> [[3]] #> x <- data$x #>  #> [[4]] #> weight <- data$weight %||% rep(1, length(x)) #>  #> [[5]] #> count <- as.numeric(tapply(weight, x, sum, na.rm = TRUE)) #>  #> [[6]] #> count[is.na(count)] <- 0 #>  #> [[7]] #> bars <- new_data_frame(list(count = count, prop = count/sum(abs(count)),  #>     x = sort(unique(x)), width = width, flipped_aes = flipped_aes),  #>     n = length(count)) #>  #> [[8]] #> flip_data(bars, flipped_aes) #>   # Works for ggproto in extension packages  ggbody(ggforce::StatDelaunaySegment$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> if (any(duplicated(data[, c(\"x\", \"y\")]))) { #>     warning(\"stat_delaunay_segment: dropping duplicated points\",  #>         call. = FALSE) #> } #>  #> [[3]] #> if (normalize) { #>     x_range <- range(data$x, na.rm = TRUE, finite = TRUE) #>     y_range <- range(data$y, na.rm = TRUE, finite = TRUE) #>     data$x <- rescale(data$x, from = x_range) * asp.ratio #>     data$y <- rescale(data$y, from = y_range) #>     if (!is.null(bound)) { #>         bound[1:2] <- rescale(bound[1:2], from = x_range) * asp.ratio #>         bound[3:4] <- rescale(bound[3:4], from = x_range) #>     } #> } #>  #> [[4]] #> vor <- deldir::deldir(data$x, data$y, rw = bound, eps = eps,  #>     suppressMsge = TRUE) #>  #> [[5]] #> segments <- vor$delsgs[, 1:5] #>  #> [[6]] #> names(segments) <- c(\"x\", \"y\", \"xend\", \"yend\", \"group\") #>  #> [[7]] #> segments$group <- vor$ind.orig[segments$group] #>  #> [[8]] #> data <- cbind(segments[, 1:4], data[segments$group, !names(data) %in%  #>     c(\"x\", \"y\"), drop = FALSE]) #>  #> [[9]] #> if (normalize) { #>     data$x <- rescale(data$x/asp.ratio, to = x_range, from = c(0,  #>         1)) #>     data$xend <- rescale(data$xend/asp.ratio, to = x_range, from = c(0,  #>         1)) #>     data$y <- rescale(data$y, to = y_range, from = c(0, 1)) #>     data$yend <- rescale(data$yend, to = y_range, from = c(0,  #>         1)) #> } #>  #> [[10]] #> data #>   library(ggforce) ggbody(StatBezier$compute_panel) #> [[1]] #> `{` #>  #> [[2]] #> if (is.null(data)) return(data) #>  #> [[3]] #> nControls <- table(data$group) #>  #> [[4]] #> controlRange <- range(nControls) #>  #> [[5]] #> if (min(controlRange) < 3 || max(controlRange) > 4) { #>     stop(\"Only support for quadratic and cubic beziers\") #> } #>  #> [[6]] #> data <- data[order(data$group), ] #>  #> [[7]] #> groups <- unique(data$group) #>  #> [[8]] #> paths <- getBeziers(data$x, data$y, match(data$group, groups),  #>     n) #>  #> [[9]] #> paths <- data.frame(x = paths$paths[, 1], y = paths$paths[, 2],  #>     group = groups[paths$pathID]) #>  #> [[10]] #> paths$index <- rep(seq(0, 1, length.out = n), length(nControls)) #>  #> [[11]] #> dataIndex <- rep(match(unique(data$group), data$group), each = n) #>  #> [[12]] #> cbind(paths, data[dataIndex, !names(data) %in% c(\"x\", \"y\", \"group\"),  #>     drop = FALSE]) #>   # `inherit = TRUE` will return the method from the closest parent  ## ERRORS: ## get_method(StatBoxplot$compute_panel) ## ggbody(StatBoxplot$compute_panel) ## ggformals(StatBoxplot$compute_panel) ggbody(StatBoxplot$compute_panel, inherit = TRUE) #> Method inherited from `Stat$compute_panel` #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(new_data_frame()) #>  #> [[3]] #> groups <- split(data, data$group) #>  #> [[4]] #> stats <- lapply(groups, function(group) { #>     self$compute_group(data = group, scales = scales, ...) #> }) #>  #> [[5]] #> stats <- mapply(function(new, old) { #>     if (empty(new))  #>         return(new_data_frame()) #>     unique <- uniquecols(old) #>     missing <- !(names(unique) %in% names(new)) #>     cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #> }, stats, groups, SIMPLIFY = FALSE) #>  #> [[6]] #> rbind_dfs(stats) #>  ggbody(Stat$compute_panel) #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(new_data_frame()) #>  #> [[3]] #> groups <- split(data, data$group) #>  #> [[4]] #> stats <- lapply(groups, function(group) { #>     self$compute_group(data = group, scales = scales, ...) #> }) #>  #> [[5]] #> stats <- mapply(function(new, old) { #>     if (empty(new))  #>         return(new_data_frame()) #>     unique <- uniquecols(old) #>     missing <- !(names(unique) %in% names(new)) #>     cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #> }, stats, groups, SIMPLIFY = FALSE) #>  #> [[6]] #> rbind_dfs(stats) #>   # Navigating complex inheritance class(GeomArcBar) #> [1] \"GeomArcBar\"  \"GeomShape\"   \"GeomPolygon\" \"Geom\"        \"ggproto\"     #> [6] \"gg\"          invisible(ggbody(GeomArcBar$default_aes, inherit = TRUE)) # self #> Method 'default_aes' is defined for `GeomArcBar`, not inherited. invisible(ggbody(GeomArcBar$draw_panel, inherit = TRUE))  # parent #> Method inherited from `GeomShape$draw_panel` invisible(ggbody(GeomArcBar$draw_key, inherit = TRUE))    # grandparent #> Method inherited from `GeomPolygon$draw_key` invisible(ggbody(GeomArcBar$draw_group, inherit = TRUE))  # top-level #> Method inherited from `Geom$draw_group`  # Getting information about method inheritance all at once # - default `trim_overriden = TRUE` hides redundant methods defined in parent get_method_inheritance(GeomArcBar, trim_overriden = TRUE) #> $Geom #>  [1] \"aesthetics\"      \"draw_group\"      \"draw_layer\"      \"draw_panel\"      #>  [5] \"extra_params\"    \"non_missing_aes\" \"optional_aes\"    \"parameters\"      #>  [9] \"setup_data\"      \"setup_params\"    \"use_defaults\"    #>  #> $GeomPolygon #> [1] \"default_aes\"  \"draw_key\"     \"handle_na\"    \"required_aes\" #>  #> $GeomShape #> [1] \"draw_panel\"   \"extra_params\" #>  #> $GeomArcBar #> [1] \"default_aes\" #>   # Works for custom ggproto # - Example from {ggplot2} \"Extending ggplot2\" vignette StatDensityCommon <- ggproto(\"StatDensityCommon\", Stat,   required_aes = \"x\",    setup_params = function(data, params) {     if (!is.null(params$bandwidth))       return(params)      xs <- split(data$x, data$group)     bws <- vapply(xs, bw.nrd0, numeric(1))     bw <- mean(bws)     message(\"Picking bandwidth of \", signif(bw, 3))      params$bandwidth <- bw     params   },    compute_group = function(data, scales, bandwidth = 1) {     d <- density(data$x, bw = bandwidth)     data.frame(x = d$x, y = d$y)   } )  as.list(body(get(\"compute_group\", StatDensityCommon))) #> [[1]] #> `{` #>  #> [[2]] #> d <- density(data$x, bw = bandwidth) #>  #> [[3]] #> data.frame(x = d$x, y = d$y) #>   ggbody(StatDensityCommon$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> d <- density(data$x, bw = bandwidth) #>  #> [[3]] #> data.frame(x = d$x, y = d$y) #>   # As of v.0.4.0, ggbody works for functions as well ggbody(sample) #> [[1]] #> `{` #>  #> [[2]] #> if (length(x) == 1L && is.numeric(x) && is.finite(x) && x >=  #>     1) { #>     if (missing(size))  #>         size <- x #>     sample.int(x, size, replace, prob) #> } else { #>     if (missing(size))  #>         size <- length(x) #>     x[sample.int(length(x), size, replace, prob)] #> } #>  ggtrace(sample, 1) #> `sample` now being traced. invisible(ggbody(sample)) #> Warning: `sample` is currently being traced is_traced(sample) #> [1] TRUE gguntrace(sample) #> `sample` no longer being traced."},{"path":"/reference/ggbody.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the body of a function or a method as a list — ggbody","title":"Retrieve the body of a function or a method as a list — ggbody","text":"Retrieve body function method list","code":""},{"path":"/reference/ggbody.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the body of a function or a method as a list — ggbody","text":"","code":"ggbody(method, inherit = FALSE)"},{"path":"/reference/ggbody.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the body of a function or a method as a list — ggbody","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method inherit Whether method searched closest parent. Defaults FALSE. TRUE, returns parent's method corresponding ggbody() code message.","code":""},{"path":"/reference/ggbody.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the body of a function or a method as a list — ggbody","text":"list","code":""},{"path":"/reference/ggbody.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Retrieve the body of a function or a method as a list — ggbody","text":"ggbody() calls .list(body(get(\"method\", ggproto))) hood. get(\"method\", ggproto) syntax long form ggproto$method retrieves actual function body. subtle important difference inspecting ggproto methods. example, works: debugonce(get(\"compute_group\", StatCount)) fails insert break point: debugonce(StatCount$compute_group) ggbody() designed worry distinction.","code":""},{"path":"/reference/ggbody.html","id":"gotchas","dir":"Reference","previous_headings":"","what":"Gotchas","title":"Retrieve the body of a function or a method as a list — ggbody","text":"method traced via ggtrace() ggedit(), ggbody() return current modified state method. v0.3.5, calling ggbody() method trace return warning emphasize fact. using inherit = TRUE, make sure ggproto objects class(ggproto) available (loading packages defined, example). hood, ggbody() loops parents search method, needs able evaluate element class(ggproto) object.","code":""},{"path":"/reference/ggbody.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the body of a function or a method as a list — ggbody","text":"","code":"library(ggplot2)  ggbody(StatCount$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> data <- flip_data(data, flipped_aes) #>  #> [[3]] #> x <- data$x #>  #> [[4]] #> weight <- data$weight %||% rep(1, length(x)) #>  #> [[5]] #> count <- as.numeric(tapply(weight, x, sum, na.rm = TRUE)) #>  #> [[6]] #> count[is.na(count)] <- 0 #>  #> [[7]] #> bars <- new_data_frame(list(count = count, prop = count/sum(abs(count)),  #>     x = sort(unique(x)), width = width, flipped_aes = flipped_aes),  #>     n = length(count)) #>  #> [[8]] #> flip_data(bars, flipped_aes) #>   # Works for ggproto in extension packages  ggbody(ggforce::StatDelaunaySegment$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> if (any(duplicated(data[, c(\"x\", \"y\")]))) { #>     warning(\"stat_delaunay_segment: dropping duplicated points\",  #>         call. = FALSE) #> } #>  #> [[3]] #> if (normalize) { #>     x_range <- range(data$x, na.rm = TRUE, finite = TRUE) #>     y_range <- range(data$y, na.rm = TRUE, finite = TRUE) #>     data$x <- rescale(data$x, from = x_range) * asp.ratio #>     data$y <- rescale(data$y, from = y_range) #>     if (!is.null(bound)) { #>         bound[1:2] <- rescale(bound[1:2], from = x_range) * asp.ratio #>         bound[3:4] <- rescale(bound[3:4], from = x_range) #>     } #> } #>  #> [[4]] #> vor <- deldir::deldir(data$x, data$y, rw = bound, eps = eps,  #>     suppressMsge = TRUE) #>  #> [[5]] #> segments <- vor$delsgs[, 1:5] #>  #> [[6]] #> names(segments) <- c(\"x\", \"y\", \"xend\", \"yend\", \"group\") #>  #> [[7]] #> segments$group <- vor$ind.orig[segments$group] #>  #> [[8]] #> data <- cbind(segments[, 1:4], data[segments$group, !names(data) %in%  #>     c(\"x\", \"y\"), drop = FALSE]) #>  #> [[9]] #> if (normalize) { #>     data$x <- rescale(data$x/asp.ratio, to = x_range, from = c(0,  #>         1)) #>     data$xend <- rescale(data$xend/asp.ratio, to = x_range, from = c(0,  #>         1)) #>     data$y <- rescale(data$y, to = y_range, from = c(0, 1)) #>     data$yend <- rescale(data$yend, to = y_range, from = c(0,  #>         1)) #> } #>  #> [[10]] #> data #>   library(ggforce) ggbody(StatBezier$compute_panel) #> [[1]] #> `{` #>  #> [[2]] #> if (is.null(data)) return(data) #>  #> [[3]] #> nControls <- table(data$group) #>  #> [[4]] #> controlRange <- range(nControls) #>  #> [[5]] #> if (min(controlRange) < 3 || max(controlRange) > 4) { #>     stop(\"Only support for quadratic and cubic beziers\") #> } #>  #> [[6]] #> data <- data[order(data$group), ] #>  #> [[7]] #> groups <- unique(data$group) #>  #> [[8]] #> paths <- getBeziers(data$x, data$y, match(data$group, groups),  #>     n) #>  #> [[9]] #> paths <- data.frame(x = paths$paths[, 1], y = paths$paths[, 2],  #>     group = groups[paths$pathID]) #>  #> [[10]] #> paths$index <- rep(seq(0, 1, length.out = n), length(nControls)) #>  #> [[11]] #> dataIndex <- rep(match(unique(data$group), data$group), each = n) #>  #> [[12]] #> cbind(paths, data[dataIndex, !names(data) %in% c(\"x\", \"y\", \"group\"),  #>     drop = FALSE]) #>   # `inherit = TRUE` will return the method from the closest parent  ## ERRORS: ## ggbody(StatBoxplot$compute_panel) ggbody(StatBoxplot$compute_panel, inherit = TRUE) #> Returning `ggbody(Stat$compute_panel)` #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(new_data_frame()) #>  #> [[3]] #> groups <- split(data, data$group) #>  #> [[4]] #> stats <- lapply(groups, function(group) { #>     self$compute_group(data = group, scales = scales, ...) #> }) #>  #> [[5]] #> stats <- mapply(function(new, old) { #>     if (empty(new))  #>         return(new_data_frame()) #>     unique <- uniquecols(old) #>     missing <- !(names(unique) %in% names(new)) #>     cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #> }, stats, groups, SIMPLIFY = FALSE) #>  #> [[6]] #> rbind_dfs(stats) #>  ggbody(Stat$compute_panel) #> [[1]] #> `{` #>  #> [[2]] #> if (empty(data)) return(new_data_frame()) #>  #> [[3]] #> groups <- split(data, data$group) #>  #> [[4]] #> stats <- lapply(groups, function(group) { #>     self$compute_group(data = group, scales = scales, ...) #> }) #>  #> [[5]] #> stats <- mapply(function(new, old) { #>     if (empty(new))  #>         return(new_data_frame()) #>     unique <- uniquecols(old) #>     missing <- !(names(unique) %in% names(new)) #>     cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #> }, stats, groups, SIMPLIFY = FALSE) #>  #> [[6]] #> rbind_dfs(stats) #>   # Navigating complex inheritance class(GeomArcBar) #> [1] \"GeomArcBar\"  \"GeomShape\"   \"GeomPolygon\" \"Geom\"        \"ggproto\"     #> [6] \"gg\"          invisible(ggbody(GeomArcBar$default_aes, inherit = TRUE)) # self #> Method 'default_aes' is defined for `GeomArcBar`, not inherited. invisible(ggbody(GeomArcBar$draw_panel, inherit = TRUE))  # parent #> Returning `ggbody(GeomShape$draw_panel)` invisible(ggbody(GeomArcBar$draw_key, inherit = TRUE))    # grandparent #> Returning `ggbody(GeomPolygon$draw_key)` invisible(ggbody(GeomArcBar$draw_group, inherit = TRUE))  # top-level #> Returning `ggbody(Geom$draw_group)`  # Works for custom ggproto # - Example from {ggplot2} \"Extending ggplot2\" vignette StatDensityCommon <- ggproto(\"StatDensityCommon\", Stat,   required_aes = \"x\",    setup_params = function(data, params) {     if (!is.null(params$bandwidth))       return(params)      xs <- split(data$x, data$group)     bws <- vapply(xs, bw.nrd0, numeric(1))     bw <- mean(bws)     message(\"Picking bandwidth of \", signif(bw, 3))      params$bandwidth <- bw     params   },    compute_group = function(data, scales, bandwidth = 1) {     d <- density(data$x, bw = bandwidth)     data.frame(x = d$x, y = d$y)   } )  as.list(body(get(\"compute_group\", StatDensityCommon))) #> [[1]] #> `{` #>  #> [[2]] #> d <- density(data$x, bw = bandwidth) #>  #> [[3]] #> data.frame(x = d$x, y = d$y) #>   ggbody(StatDensityCommon$compute_group) #> [[1]] #> `{` #>  #> [[2]] #> d <- density(data$x, bw = bandwidth) #>  #> [[3]] #> data.frame(x = d$x, y = d$y) #>   # As of v.0.4.0, ggbody works for functions as well ggbody(sample) #> [[1]] #> `{` #>  #> [[2]] #> if (length(x) == 1L && is.numeric(x) && is.finite(x) && x >=  #>     1) { #>     if (missing(size))  #>         size <- x #>     sample.int(x, size, replace, prob) #> } else { #>     if (missing(size))  #>         size <- length(x) #>     x[sample.int(length(x), size, replace, prob)] #> } #>  ggtrace(sample, 1) #> `sample` now being traced. invisible(ggbody(sample)) #> Warning: `sample` is currently being traced is_traced(sample) #> [1] TRUE gguntrace(sample) #> `sample` no longer being traced."},{"path":"/reference/ggdebug.html","id":null,"dir":"Reference","previous_headings":"","what":"Debug a ggproto method — ggdebug","title":"Debug a ggproto method — ggdebug","text":"Debug ggproto method","code":""},{"path":"/reference/ggdebug.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Debug a ggproto method — ggdebug","text":"","code":"ggdebug(method, ...)  ggdebugonce(method, ...)  ggundebug(method, ...)"},{"path":"/reference/ggdebug.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Debug a ggproto method — ggdebug","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Ignored. Designed ease calling function modifying call earlier {ggtrace} function interactive contexts.","code":""},{"path":"/reference/ggdebugonce.html","id":null,"dir":"Reference","previous_headings":"","what":"Debugonce a ggproto method — ggdebugonce","title":"Debugonce a ggproto method — ggdebugonce","text":"Debugonce ggproto method","code":""},{"path":"/reference/ggdebugonce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Debugonce a ggproto method — ggdebugonce","text":"","code":"ggdebugonce(method, ...)"},{"path":"/reference/ggdebugonce.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Debugonce a ggproto method — ggdebugonce","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Ignored. Designed ease calling function modifying call earlier {ggtrace} function interactive contexts.","code":""},{"path":"/reference/ggedit.html","id":null,"dir":"Reference","previous_headings":"","what":"Interactively edit a masking copy of the source code — ggedit","title":"Interactively edit a masking copy of the source code — ggedit","text":"Interactively edit masking copy source code","code":""},{"path":"/reference/ggedit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interactively edit a masking copy of the source code — ggedit","text":"","code":"ggedit(method, remove_trace = FALSE, ...)"},{"path":"/reference/ggedit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interactively edit a masking copy of the source code — ggedit","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method remove_trace Whether edit clean slate. Defaults FALSE. ... Unused, extensibility.","code":""},{"path":"/reference/ggedit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interactively edit a masking copy of the source code — ggedit","text":"Like base::trace(), edit effect gguntrace() called. Changes ggedit() cumulative, ggedit() inform via warning making edit top existing edit. Call gguntrace() object first like edit method's original unaltered source code. works interactive contexts.","code":""},{"path":"/reference/ggedit.html","id":"gotchas","dir":"Reference","previous_headings":"","what":"Gotchas","title":"Interactively edit a masking copy of the source code — ggedit","text":"Calling ggtrace() method changes ggedit() remove changes ggedit(). possible combine features, disabled package keep API consistent. philosophy {ggtrace} mix programmatic interactive workflows.","code":""},{"path":[]},{"path":"/reference/ggedit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interactively edit a masking copy of the source code — ggedit","text":"","code":"if (FALSE) {  jitter_plot <- ggplot(diamonds[1:1000,], aes(cut, depth)) +   geom_point(position = position_jitter(width = 0.2, seed = 2021))  # Interactively modify the method's source code in text editor ggedit(PositionJitter$compute_layer)  # Check the edited code ggbody(PositionJitter$compute_layer)  # Execute method with edit jitter_plot  # Untrace gguntrace(PositionJitter$compute_layer)  # Edit is removed in the next call jitter_plot  }"},{"path":"/reference/ggeval_silent.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple evaluation and printing of a ggplot object — ggeval_silent","title":"Simple evaluation and printing of a ggplot object — ggeval_silent","text":"ggeval_silent() evaluates ggplot object <gtable> grob ggdraw_silent() renders grob {grid}. Combined, two functions simulate ggplot2:::print.ggplot without overriding last_plot().","code":""},{"path":"/reference/ggeval_silent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple evaluation and printing of a ggplot object — ggeval_silent","text":"","code":"ggeval_silent(x)  ggdraw_silent(x)"},{"path":"/reference/ggeval_silent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple evaluation and printing of a ggplot object — ggeval_silent","text":"x ggplot","code":""},{"path":"/reference/ggeval_silent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple evaluation and printing of a ggplot object — ggeval_silent","text":"gtable","code":""},{"path":"/reference/ggtrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Insert traces for delayed evaluation — ggtrace","title":"Insert traces for delayed evaluation — ggtrace","text":"Insert traces delayed evaluation","code":""},{"path":"/reference/ggtrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Insert traces for delayed evaluation — ggtrace","text":"","code":"ggtrace(   method,   trace_steps,   trace_exprs,   once = TRUE,   use_names = TRUE,   ...,   print_output = TRUE,   verbose = FALSE )"},{"path":"/reference/ggtrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Insert traces for delayed evaluation — ggtrace","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method trace_steps sorted numeric vector positions method's body trace. Negative indices reference steps last, -1 references last step body. trace_exprs list expressions evaluate position specified trace_steps. single expression provided, recycled match length trace_steps. simply run step return output, can use ~step keyword. step assign expression, value assigned variable returned. trace_exprs provided, ggtrace() called ~step default. Whether untrace() method exit. FALSE, creates persistent trace active gguntrace() called method. Defaults TRUE. use_names Whether trace dump use names trace_exprs. Defaults TRUE. ... Unused, extensibility. print_output Whether print() output expression console. Defaults TRUE. verbose Whether logs printed trace triggered. Encompasses print_output, meaning verbose = FALSE also triggers effect print_output = FALSE consequence. Defaults FALSE.","code":""},{"path":"/reference/ggtrace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Insert traces for delayed evaluation — ggtrace","text":"ggtrace() wrapper around base::trace() called ggproto method. calls base::untrace() exit default, make effect ephemeral like base::debugonce(). major feature ability pass multiple positions expressions trace_steps trace_exprs inspect, capture, modify run time environment ggproto methods. recommended consult output ggbody() deciding expressions evaluate steps. output expressions passed trace_exprs printed tracing takes place. list outputs ggtrace() (\"trace dumps\") can returned inspection last_ggtrace() global_ggtrace().","code":""},{"path":"/reference/ggtrace.html","id":"workflows","dir":"Reference","previous_headings":"","what":"Workflows","title":"Insert traces for delayed evaluation — ggtrace","text":"Broadly, four flavors working {ggtrace} package, listed order increasing complexity: Inspect: canonical use ggtrace() make queries, expressions passed evaluated output returned, potentially inspection. Capture: strategy returning method's runtime environment complex explorations outside debugging context. method's environment contextualizes self object addition making inherited params local variables available. reference method's runtime environment can returned environment(), trace_exprs = quote(environment()). Note environments mutable, meaning environment() returned first last steps reference environment. get snapshot environment particular step, can return deep copy rlang::env_clone(environment()). Inject: strategy modifying behavior method runs passing expressions make assignments. example, trace_steps = c(1, 10) trace_exprs = rlang::exprs(<- 5, ) first assign new variable step 1, return value 5 step 10. can also used modify important variables like quote(data$x <- data$x * 10). like inject object global environment, can make use !! (bang-bang) operator {rlang}, like : rlang::expr(data <- !!modified_data). Note execution environment created anew time method ran, modifying environment previous execution affect future calls method. like capture modified plot output assign variable, can ggplotGrob(). can render modified plot print(). Edit: also possible make arbitrary modifications method's source code, stays effect method untraced. also handled base::trace(), workflow fundamentally interactive. Therefore, refactored function ggedit(). See ?ggedit details.","code":""},{"path":"/reference/ggtrace.html","id":"gotchas","dir":"Reference","previous_headings":"","what":"Gotchas","title":"Insert traces for delayed evaluation — ggtrace","text":"wrap ggplot invisible() silence ggtrace(), plot build, also means tracing triggered. print/plot method ggplot triggers evaluation plot code. recommended allow ggtrace() print information, really like silence , can wrapping plot function forces evaluation first, like ggplotGrob, invisible(ggplotGrob(<plot>)). reason ggtrace(= TRUE) fails untrace exit, may accidentally trigger trace . check method traced, call is_traced(). can also always call gguntrace() since unlike base::untrace(), error trace exist method. Instead, gguntrace() nothing case simply inform trace remove. base::trace() wraps method body special environment, possible inspect method/function called , even something like rlang::caller_env(). traverse wrapping environments created base::trace() eventually ends looping around.","code":""},{"path":"/reference/ggtrace.html","id":"messages","dir":"Reference","previous_headings":"","what":"Messages","title":"Insert traces for delayed evaluation — ggtrace","text":"Various information sent console whenever trace triggered. can control gets displayed print_output verbose, TRUE default. print_output simply calls print() evaluated expressions, turning may desirable expressions trace_exprs evaluates long dataframe vector. verbose controls information printed console including print(), setting verbose = FALSE mean message()s displayed. Lastly, can suppress message() ggtrace() options(ggtrace.suppressMessages = TRUE), though suppressing messages generally recommended.","code":""},{"path":[]},{"path":"/reference/ggtrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Insert traces for delayed evaluation — ggtrace","text":"","code":"# One example of an Inspect workflow ----  library(ggplot2)  jitter_plot <- ggplot(diamonds[1:1000,], aes(cut, depth)) +   geom_point(position = position_jitter(width = 0.2, seed = 2021))  jitter_plot   ggbody(PositionJitter$compute_layer) #> [[1]] #> `{` #>  #> [[2]] #> trans_x <- if (params$width > 0) function(x) jitter(x, amount = params$width) #>  #> [[3]] #> trans_y <- if (params$height > 0) function(x) jitter(x, amount = params$height) #>  #> [[4]] #> x_aes <- intersect(ggplot_global$x_aes, names(data)) #>  #> [[5]] #> x <- if (length(x_aes) == 0) 0 else data[[x_aes[1]]] #>  #> [[6]] #> y_aes <- intersect(ggplot_global$y_aes, names(data)) #>  #> [[7]] #> y <- if (length(y_aes) == 0) 0 else data[[y_aes[1]]] #>  #> [[8]] #> dummy_data <- new_data_frame(list(x = x, y = y), nrow(data)) #>  #> [[9]] #> fixed_jitter <- with_seed_null(params$seed, transform_position(dummy_data,  #>     trans_x, trans_y)) #>  #> [[10]] #> x_jit <- fixed_jitter$x - x #>  #> [[11]] #> y_jit <- fixed_jitter$y - y #>  #> [[12]] #> transform_position(data, function(x) x + x_jit, function(x) x +  #>     y_jit) #>   ## Step 1 ==== ## Inspect what `data` look like at the start of the function ggtrace(PositionJitter$compute_layer, trace_steps = 1, trace_exprs = quote(head(data))) #> `PositionJitter$compute_layer` now being traced.  jitter_plot #> Triggering trace on `PositionJitter$compute_layer` #> Untracing `PositionJitter$compute_layer` on exit.   ## Step 2 ==== ## What does `data` look like at the end of the method? Unfortunately, `trace()` only lets us enter ## at the beginning of a step, so we can't inspect what happens after the last step is evaluated. To ## address this, `ggtrace()` offers a `~step` keyword which gets substituted for the current line. ## We also set `print_output = FALSE` to disable printing of the output ggtrace(   PositionJitter$compute_layer,   trace_steps = 12,   trace_exprs = quote(~step), # This is the default if `trace_exprs` is not provided   print_output = FALSE ) #> `PositionJitter$compute_layer` now being traced.  # We wrap the plot in `ggplotGrob()` and `invisible()` to force # its evaluation while suppressing its rendering invisible(ggplotGrob(jitter_plot)) #> Triggering trace on `PositionJitter$compute_layer` #> Untracing `PositionJitter$compute_layer` on exit.  # The output of the evaluated expressions can be inspected with `last_ggtrace()` head(last_ggtrace()[[1]]) #>          x        y PANEL group #> 1 4.980507 61.50684     1     5 #> 2 4.113512 59.77872     1     4 #> 3 2.083873 56.86655     1     2 #> 4 3.952698 62.42703     1     4 #> 5 2.054530 63.29763     1     2 #> 6 3.080538 62.77536     1     3  ## Step 3 ==== ## If we want both to be returned at the same time for an easier comparison, we can pass in a ## (named) list of expressions. ggtrace(   PositionJitter$compute_layer,   trace_steps = c(1, 12),   trace_exprs = rlang::exprs(     before_jitter = data,     after_jitter = ~step   ),   verbose = FALSE ) #> `PositionJitter$compute_layer` now being traced.  invisible(ggplotGrob(jitter_plot)) #> Triggering trace on `PositionJitter$compute_layer` #> Untracing `PositionJitter$compute_layer` on exit.  ## Step 4 ==== ## The output of the evaluated expressions can be inspected with `last_ggtrace()` jitter_tracedump <- last_ggtrace()  lapply(jitter_tracedump, head, 3) #> $before_jitter #>   x    y PANEL group #> 1 5 61.5     1     5 #> 2 4 59.8     1     4 #> 3 2 56.9     1     2 #>  #> $after_jitter #>          x        y PANEL group #> 1 4.980507 61.50684     1     5 #> 2 4.113512 59.77872     1     4 #> 3 2.083873 56.86655     1     2 #>   jitter_distances <- jitter_tracedump[[\"before_jitter\"]]$x -   jitter_tracedump[[\"after_jitter\"]]$x  range(jitter_distances) #> [1] -0.1994971  0.1995346 jitter_plot$layers[[1]]$position$width #> [1] 0.2"},{"path":"/reference/ggtraceback.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect the call stack on enter — ggtraceback","title":"Inspect the call stack on enter — ggtraceback","text":"Inspect call stack enter","code":""},{"path":"/reference/ggtraceback.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect the call stack on enter — ggtraceback","text":"","code":"ggtraceback(method, ...)"},{"path":"/reference/ggtraceback.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect the call stack on enter — ggtraceback","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Arguments passed rlang::trace_back top first frame environment included backtrace. becomes top backtrace tree represents oldest call backtrace. needed particular call trace_back() indirectly larger context, example tests inside RMarkdown document want knitr evaluation mechanisms appear backtrace. supplied, rlang_trace_top_env global option consulted. makes possible trim embedding context backtraces created option set. knitr progress, default value option knitr::knit_global() knitr context trimmed backtraces. bottom last frame environment included backtrace. becomes rightmost leaf backtrace tree represents youngest call backtrace. Set like capture backtrace without capture context. Can also integer passed caller_env().","code":""},{"path":"/reference/ggtraceback.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Inspect the call stack on enter — ggtraceback","text":"Calls rlang::trace_back() upon first entering function method. Note ggtraceback() ever prints back trace calls gguntrace() first time triggered. complex inspections call stack, ggedit() recommended.","code":""},{"path":"/reference/ggtraceback.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Inspect the call stack on enter — ggtraceback","text":"output rlang::trace_back() logged tracedumps (last_ggtrace() global_ggtrace())","code":""},{"path":"/reference/ggtrace_capture.html","id":null,"dir":"Reference","previous_headings":"","what":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"Returns ggproto method function arguments pre-filled values first called","code":""},{"path":"/reference/ggtrace_capture.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"","code":"ggtrace_capture(x, ...)"},{"path":"/reference/ggtrace_capture.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"x ggplot object ... Passed ggtrace(). method capture specified .","code":""},{"path":"/reference/ggtrace_capture.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"function","code":""},{"path":"/reference/ggtrace_capture.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"methods take ..., arguments passed ... runtime, captured stored .dots_captured argument returned function, accessible via formals(x)$.dots_captured. returned function also expose ..., defaults .dots_captured passed captured method unless also provided ...","code":""},{"path":"/reference/ggtrace_capture.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capture a snapshot of a ggproto method as a pre-filled function — ggtrace_capture","text":"","code":"library(ggplot2)  set.seed(47) df <- as.data.frame(matrix(sample(5, 50, TRUE), ncol = 2)) df #>    V1 V2 #> 1   3  5 #> 2   1  5 #> 3   2  4 #> 4   4  1 #> 5   1  5 #> 6   2  5 #> 7   5  1 #> 8   1  5 #> 9   5  2 #> 10  4  1 #> 11  5  3 #> 12  5  5 #> 13  4  3 #> 14  3  3 #> 15  3  5 #> 16  4  3 #> 17  1  1 #> 18  5  2 #> 19  2  5 #> 20  5  2 #> 21  2  2 #> 22  5  3 #> 23  3  5 #> 24  3  2 #> 25  1  3  base <- ggplot(df, aes(x = V1, y = V2))  p1 <- base + stat_summary(orientation = \"x\") p1 #> No summary function supplied, defaulting to `mean_se()`   p1_compute_panel <- ggtrace_capture(p1, method = StatSummary$compute_panel)  # `p1_compute_panel` is a copy of the ggproto method body(p1_compute_panel) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> } ggbody(StatSummary$compute_panel, as.list = FALSE) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> }  # Its arguments are pre-filled (captured at runtime) formals(p1_compute_panel) #> $data #>    x y PANEL group #> 1  3 5     1    -1 #> 2  1 5     1    -1 #> 3  2 4     1    -1 #> 4  4 1     1    -1 #> 5  1 5     1    -1 #> 6  2 5     1    -1 #> 7  5 1     1    -1 #> 8  1 5     1    -1 #> 9  5 2     1    -1 #> 10 4 1     1    -1 #> 11 5 3     1    -1 #> 12 5 5     1    -1 #> 13 4 3     1    -1 #> 14 3 3     1    -1 #> 15 3 5     1    -1 #> 16 4 3     1    -1 #> 17 1 1     1    -1 #> 18 5 2     1    -1 #> 19 2 5     1    -1 #> 20 5 2     1    -1 #> 21 2 2     1    -1 #> 22 5 3     1    -1 #> 23 3 5     1    -1 #> 24 3 2     1    -1 #> 25 1 3     1    -1 #>  #> $scales #> $scales$x #> <ScaleContinuousPosition> #>  Range:     1 --    5 #>  Limits:    1 --    5 #>  #> $scales$y #> <ScaleContinuousPosition> #>  Range:  1.42 -- 4.71 #>  Limits: 1.42 -- 4.71 #>  #>  #> $fun.data #> NULL #>  #> $fun #> NULL #>  #> $fun.max #> NULL #>  #> $fun.min #> NULL #>  #> $fun.args #> list() #>  #> $na.rm #> [1] FALSE #>  #> $flipped_aes #> [1] FALSE #>   # Runs as it should p1_compute_panel() #> No summary function supplied, defaulting to `mean_se()` #>   x group        y     ymin     ymax PANEL flipped_aes #> 1 1    -1 3.800000 3.000000 4.600000     1       FALSE #> 2 2    -1 4.000000 3.292893 4.707107     1       FALSE #> 3 3    -1 4.000000 3.367544 4.632456     1       FALSE #> 4 4    -1 2.000000 1.422650 2.577350     1       FALSE #> 5 5    -1 2.571429 2.090500 3.052357     1       FALSE  # You can inspect changes to its behavior outisde of ggplot # For example, see what happens when aes is flipped via `orientation = \"y\"` p1_compute_panel(flipped_aes = TRUE) #> No summary function supplied, defaulting to `mean_se()` #>   y group        x     xmin     xmax PANEL flipped_aes #> 1 1    -1 3.500000 2.633975 4.366025     1        TRUE #> 2 2    -1 4.000000 3.367544 4.632456     1        TRUE #> 3 3    -1 3.666667 3.052030 4.281303     1        TRUE #> 4 4    -1 2.000000       NA       NA     1        TRUE #> 5 5    -1 2.333333 1.892375 2.774292     1        TRUE  # We confirm this output to be true when `orientation = \"y\"` p2 <- base + stat_summary(orientation = \"y\") p2_compute_panel <- ggtrace_capture(p2, method = StatSummary$compute_panel) #> Warning: Removed 1 rows containing missing values (geom_segment).  identical(p1_compute_panel(flipped_aes = TRUE), p2_compute_panel()) #> No summary function supplied, defaulting to `mean_se()` #> No summary function supplied, defaulting to `mean_se()` #> [1] TRUE  # You can interactively explore with `debugonce(p2_compute_panel)`   # Note that the captured method looks slightly different if the method takes `...` p3 <- base + stat_smooth() + geom_jitter() p3 #> `geom_smooth()` using method = 'loess' and formula 'y ~ x'   p3_compute_panel <- ggtrace_capture(p3, method = Stat$compute_panel)  # For one, the body is different body(p3_compute_panel) #> { #>     cur_args <- mget(names(formals(rlang::current_fn()))) #>     specs <- names(cur_args) %in% names(formals(inner)) #>     do.call(inner, c(cur_args[specs], cur_args[!specs])) #> }  # The captured method is called internally, stored in the `\"inner\"` attribute attr(p3_compute_panel, \"inner\") #> function (self, data, scales, ...)  #> { #>     if (empty(data))  #>         return(new_data_frame()) #>     groups <- split(data, data$group) #>     stats <- lapply(groups, function(group) { #>         self$compute_group(data = group, scales = scales, ...) #>     }) #>     stats <- mapply(function(new, old) { #>         if (empty(new))  #>             return(new_data_frame()) #>         unique <- uniquecols(old) #>         missing <- !(names(unique) %in% names(new)) #>         cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #>     }, stats, groups, SIMPLIFY = FALSE) #>     rbind_dfs(stats) #> } #> <environment: 0x0000000039c61430>  # Captured argument defaults are again available for inspection via `formals()` # Note that arguments passed to the `...` are promoted to function arguments names(ggformals(Stat$compute_panel)) #> [1] \"self\"   \"data\"   \"scales\" \"...\"    names(formals(p3_compute_panel)) #>  [1] \"self\"        \"data\"        \"scales\"      \"method\"      \"formula\"     #>  [6] \"se\"          \"n\"           \"fullrange\"   \"level\"       \"na.rm\"       #> [11] \"method.args\" \"span\"        \"flipped_aes\"  # It works the same otherwise - plus you get the benefit of autocomplete head(p3_compute_panel()) #>          x        y     ymin     ymax        se flipped_aes PANEL group #> 1 1.000000 3.800000 2.456618 5.143382 0.6437060       FALSE     1    -1 #> 2 1.050633 3.814934 2.562634 5.067233 0.6000623       FALSE     1    -1 #> 3 1.101266 3.829354 2.645742 5.012967 0.5671495       FALSE     1    -1 #> 4 1.151899 3.843262 2.705881 4.980643 0.5449968       FALSE     1    -1 #> 5 1.202532 3.856658 2.744115 4.969200 0.5330951       FALSE     1    -1 #> 6 1.253165 3.869540 2.762657 4.976424 0.5303834       FALSE     1    -1 head(p3_compute_panel(level = .99)[, c(\"ymin\", \"ymax\")]) #>       ymin     ymax #> 1 1.967038 5.632962 #> 2 2.106247 5.523620 #> 3 2.214388 5.444321 #> 4 2.291376 5.395149 #> 5 2.338661 5.374654 #> 6 2.359266 5.379815 head(p3_compute_panel(flipped_aes = TRUE)) #>          y        x     xmin     xmax        se flipped_aes PANEL group #> 1 1.000000 3.486913 1.996579 4.977247 0.7148639        TRUE     1    -1 #> 2 1.050633 3.537510 2.136220 4.938801 0.6721527        TRUE     1    -1 #> 3 1.101266 3.585828 2.263181 4.908476 0.6344304        TRUE     1    -1 #> 4 1.151899 3.631850 2.377468 4.886232 0.6016854        TRUE     1    -1 #> 5 1.202532 3.675558 2.479204 4.871912 0.5738514        TRUE     1    -1 #> 6 1.253165 3.716935 2.568654 4.865215 0.5507921        TRUE     1    -1  # Interactively explore with `debugonce(attr(p3_compute_panel, \"inner\"))`"},{"path":"/reference/ggtrace_capture_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Capture a snapshot of a method's execution environment — ggtrace_capture_env","title":"Capture a snapshot of a method's execution environment — ggtrace_capture_env","text":"Capture snapshot method's execution environment","code":""},{"path":"/reference/ggtrace_capture_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capture a snapshot of a method's execution environment — ggtrace_capture_env","text":"","code":"ggtrace_capture_env(x, method, cond = quote(._counter_ == 1), at = -1L)"},{"path":"/reference/ggtrace_capture_env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capture a snapshot of a method's execution environment — ggtrace_capture_env","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond method environment captured. Defaults quote(._counter_ == 1L). step method body environment captured. See ggbody() list expressions/steps method body.","code":""},{"path":"/reference/ggtrace_capture_env.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capture a snapshot of a method's execution environment — ggtrace_capture_env","text":"environment","code":""},{"path":"/reference/ggtrace_capture_env.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Capture a snapshot of a method's execution environment — ggtrace_capture_env","text":"quoted expressions passed cond value argument workflow functions (form ggtrace_{action}_{value}()), evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ (.data$._counter_) tracks many times function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1) evaluated TRUE method called first time, default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/ggtrace_capture_env.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capture a snapshot of a method's execution environment — ggtrace_capture_env","text":"","code":"library(ggplot2)  # Example from https://ggplot2.tidyverse.org/reference/aes_eval.html after_scale_plot <- ggplot(mpg, aes(class, hwy)) +   geom_boxplot(aes(colour = class, fill = after_scale(alpha(colour, 0.4)))) after_scale_plot   # `after_scale()` is resolved by `Geom$use_defaults` (at Step 6)  before_applying <- ggtrace_capture_env(   x = after_scale_plot,   method = Geom$use_defaults,   at = 1  # To be more specific, do `at = 6` ) after_applying <- ggtrace_capture_env(   x = after_scale_plot,   method = Geom$use_defaults,   at = -1  # To be more specific, do `at = 7` )  colnames(before_applying$data) #>  [1] \"colour\"      \"ymin\"        \"lower\"       \"middle\"      \"upper\"       #>  [6] \"ymax\"        \"outliers\"    \"notchupper\"  \"notchlower\"  \"x\"           #> [11] \"flipped_aes\" \"PANEL\"       \"group\"       \"ymin_final\"  \"ymax_final\"  #> [16] \"xmin\"        \"xmax\"        \"xid\"         \"newx\"        \"new_width\"   colnames(after_applying$data) #>  [1] \"fill\"        \"colour\"      \"ymin\"        \"lower\"       \"middle\"      #>  [6] \"upper\"       \"ymax\"        \"outliers\"    \"notchupper\"  \"notchlower\"  #> [11] \"x\"           \"flipped_aes\" \"PANEL\"       \"group\"       \"ymin_final\"  #> [16] \"ymax_final\"  \"xmin\"        \"xmax\"        \"xid\"         \"newx\"        #> [21] \"new_width\"   \"weight\"      \"size\"        \"alpha\"       \"shape\"       #> [26] \"linetype\"     library(dplyr) #> Warning: package 'dplyr' was built under R version 4.1.2 #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union  before_applying$data %>%   select(any_of(c(\"colour\", \"fill\"))) #>    colour #> 1 #F8766D #> 2 #C49A00 #> 3 #53B400 #> 4 #00C094 #> 5 #00B6EB #> 6 #A58AFF #> 7 #FB61D7 after_applying$data %>%   select(any_of(c(\"colour\", \"fill\"))) #>    colour      fill #> 1 #F8766D #F8766D66 #> 2 #C49A00 #C49A0066 #> 3 #53B400 #53B40066 #> 4 #00C094 #00C09466 #> 5 #00B6EB #00B6EB66 #> 6 #A58AFF #A58AFF66 #> 7 #FB61D7 #FB61D766  identical(   before_applying$data %>%     select(any_of(c(\"colour\", \"fill\"))) %>%     mutate(fill = alpha(colour, 0.4)),       #< after_scale() logic here   after_applying$data %>%     select(any_of(c(\"colour\", \"fill\"))) ) #> [1] TRUE   # Using the captured environment for further evaluation ggbody(Geom$draw_panel) #> [[1]] #> `{` #>  #> [[2]] #> groups <- split(data, factor(data$group)) #>  #> [[3]] #> grobs <- lapply(groups, function(group) { #>     self$draw_group(group, panel_params, coord, ...) #> }) #>  #> [[4]] #> ggname(snake_class(self), gTree(children = do.call(\"gList\", grobs))) #>   by_group_drawing_code <- rlang::call_args(ggbody(Geom$draw_panel)[[3]])[[2]] by_group_drawing_code #> lapply(groups, function(group) { #>     self$draw_group(group, panel_params, coord, ...) #> })  draw_panel_env <- ggtrace_capture_env(   x = after_scale_plot,   method = Geom$draw_panel ) draw_panel_env #> <environment: 0x00000000463c11c0>  boxes <- eval(by_group_drawing_code, draw_panel_env)  library(grid) grid.newpage() grid.draw(editGrob(boxes[[1]], vp = viewport()))"},{"path":"/reference/ggtrace_capture_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","title":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","text":"Returns ggproto method function arguments pre-filled values first called","code":""},{"path":"/reference/ggtrace_capture_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","text":"","code":"ggtrace_capture_fn(x, method, cond = quote(._counter_ == 1L))"},{"path":"/reference/ggtrace_capture_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond method function captured. Defaults quote(._counter_ == 1L).","code":""},{"path":"/reference/ggtrace_capture_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","text":"function","code":""},{"path":"/reference/ggtrace_capture_fn.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","text":"functions methods take ..., arguments passed ... captured promoted function arguments. captured values available inspection via formals().","code":""},{"path":"/reference/ggtrace_capture_fn.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","text":"quoted expressions passed cond value argument workflow functions (form ggtrace_{action}_{value}()), evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ (.data$._counter_) tracks many times function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1) evaluated TRUE method called first time, default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/ggtrace_capture_fn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capture a snapshot of a method as a pre-filled function — ggtrace_capture_fn","text":"","code":"library(ggplot2)  set.seed(47) df <- as.data.frame(matrix(sample(5, 1000, TRUE), ncol = 2)) table(df) #>    V2 #> V1   1  2  3  4  5 #>   1 28 16 15 23 21 #>   2 19 16 19 15 15 #>   3 23 22 18 21 20 #>   4 15 21 17 26 18 #>   5 20 27 26 18 21  base <- ggplot(df, aes(x = V1, y = V2))  p1 <- base + stat_summary(orientation = \"x\") p1 #> No summary function supplied, defaulting to `mean_se()`   p1_compute_panel <- ggtrace_capture_fn(p1, method = StatSummary$compute_panel) #> No summary function supplied, defaulting to `mean_se()`  # `p1_compute_panel` is a copy of the ggproto method body(p1_compute_panel) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> } ggbody(StatSummary$compute_panel, as.list = FALSE) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> }  # Its arguments are pre-filled (captured at runtime) sapply(formals(p1_compute_panel), class) #>         data       scales     fun.data          fun      fun.max      fun.min  #> \"data.frame\"       \"list\"       \"NULL\"       \"NULL\"       \"NULL\"       \"NULL\"  #>     fun.args        na.rm  flipped_aes  #>       \"list\"    \"logical\"    \"logical\"   # Runs as it should p1_compute_panel() #> No summary function supplied, defaulting to `mean_se()` #>   x group        y     ymin     ymax PANEL flipped_aes #> 1 1    -1 2.932039 2.782630 3.081447     1       FALSE #> 2 2    -1 2.892857 2.738537 3.047177     1       FALSE #> 3 3    -1 2.932692 2.791176 3.074209     1       FALSE #> 4 4    -1 3.113402 2.975241 3.251563     1       FALSE #> 5 5    -1 2.937500 2.807977 3.067023     1       FALSE  # You can inspect changes to its behavior outisde of ggplot # For example, see what happens when aes is flipped via `orientation = \"y\"` p1_compute_panel(flipped_aes = TRUE) #> No summary function supplied, defaulting to `mean_se()` #>   y group        x     xmin     xmax PANEL flipped_aes #> 1 1    -1 2.809524 2.666881 2.952167     1        TRUE #> 2 2    -1 3.264706 3.124729 3.404683     1        TRUE #> 3 3    -1 3.210526 3.062456 3.358597     1        TRUE #> 4 4    -1 3.009709 2.870024 3.149393     1        TRUE #> 5 5    -1 3.031579 2.881586 3.181572     1        TRUE  # We confirm this output to be true when `orientation = \"y\"` in `stat_summary()` p2 <- base + stat_summary(orientation = \"y\") p2_compute_panel <- ggtrace_capture_fn(p2, method = StatSummary$compute_panel) #> No summary function supplied, defaulting to `mean_se()`  identical(p1_compute_panel(flipped_aes = TRUE), p2_compute_panel()) #> No summary function supplied, defaulting to `mean_se()` #> No summary function supplied, defaulting to `mean_se()` #> [1] TRUE  # You can interactively explore with `debugonce(p2_compute_panel)`   # Note that the captured method looks slightly different if the method takes `...` p3 <- base + stat_smooth() + geom_jitter() p3 #> `geom_smooth()` using method = 'loess' and formula 'y ~ x'   p3_compute_panel <- ggtrace_capture_fn(p3, method = Stat$compute_panel) #> `geom_smooth()` using method = 'loess' and formula 'y ~ x'  # For one, the body is different - it's a \"wrapper\" around the captured method body(p3_compute_panel) #> { #>     cur_args <- mget(names(formals(rlang::current_fn()))) #>     specs <- names(cur_args) %in% names(formals(inner)) #>     do.call(inner, c(cur_args[specs], cur_args[!specs])) #> }  # The captured method is stored in the `\"inner\"` attribute attr(p3_compute_panel, \"inner\") #> function (self, data, scales, ...)  #> { #>     if (empty(data))  #>         return(new_data_frame()) #>     groups <- split(data, data$group) #>     stats <- lapply(groups, function(group) { #>         self$compute_group(data = group, scales = scales, ...) #>     }) #>     stats <- mapply(function(new, old) { #>         if (empty(new))  #>             return(new_data_frame()) #>         unique <- uniquecols(old) #>         missing <- !(names(unique) %in% names(new)) #>         cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #>     }, stats, groups, SIMPLIFY = FALSE) #>     rbind_dfs(stats) #> } #> <environment: 0x000000004f101fe0>  # Captured argument defaults are again available for inspection via `formals()` # Note that arguments passed to the `...` are promoted to function arguments names(ggformals(Stat$compute_panel)) #> [1] \"self\"   \"data\"   \"scales\" \"...\"    names(formals(p3_compute_panel)) #>  [1] \"self\"        \"data\"        \"scales\"      \"method\"      \"formula\"     #>  [6] \"se\"          \"n\"           \"fullrange\"   \"level\"       \"na.rm\"       #> [11] \"method.args\" \"span\"        \"flipped_aes\"  # It works the same otherwise - plus you get the benefit of autocomplete head(p3_compute_panel()) #>          x        y     ymin     ymax        se flipped_aes PANEL group #> 1 1.000000 2.932039 2.656568 3.207510 0.1402053       FALSE     1    -1 #> 2 1.050633 2.928156 2.671397 3.184915 0.1306815       FALSE     1    -1 #> 3 1.101266 2.924475 2.681907 3.167044 0.1234590       FALSE     1    -1 #> 4 1.151899 2.920997 2.688081 3.153914 0.1185468       FALSE     1    -1 #> 5 1.202532 2.917722 2.690122 3.145322 0.1158405       FALSE     1    -1 #> 6 1.253165 2.914649 2.688468 3.140830 0.1151184       FALSE     1    -1 head(p3_compute_panel(level = .99)[, c(\"ymin\", \"ymax\")]) #>       ymin     ymax #> 1 2.569496 3.294582 #> 2 2.590240 3.266072 #> 3 2.605235 3.243716 #> 4 2.614459 3.227536 #> 5 2.618182 3.217263 #> 6 2.616976 3.212323 head(p3_compute_panel(flipped_aes = TRUE)) #>          y        x     xmin     xmax        se flipped_aes PANEL group #> 1 1.000000 2.809524 2.533395 3.085653 0.1405400        TRUE     1    -1 #> 2 1.050633 2.844813 2.587716 3.101911 0.1308538        TRUE     1    -1 #> 3 1.101266 2.878797 2.636755 3.120838 0.1231908        TRUE     1    -1 #> 4 1.151899 2.911475 2.680469 3.142480 0.1175739        TRUE     1    -1 #> 5 1.202532 2.942847 2.718976 3.166717 0.1139424        TRUE     1    -1 #> 6 1.253165 2.972913 2.752581 3.193245 0.1121416        TRUE     1    -1  # Interactively explore with `debugonce(attr(p3_compute_panel, \"inner\"))`"},{"path":"/reference/ggtrace_capture_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"Returns ggproto method function arguments pre-filled values upon entering function.","code":""},{"path":"/reference/ggtrace_capture_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"","code":"ggtrace_capture_method(x, ...)"},{"path":"/reference/ggtrace_capture_method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"x ggplot object ... Passed ggtrace(). usecases, suffices just provide ggproto method method argument.","code":""},{"path":"/reference/ggtrace_capture_method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"function","code":""},{"path":"/reference/ggtrace_capture_method.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"methods take ..., arguments passed ... runtime, captured stored .dots_captured argument returned function, accessible via formals(x)$.dots_captured. returned function also expose ..., defaults .dots_captured passed captured method unless also provided ...","code":""},{"path":"/reference/ggtrace_capture_method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capture a ggproto method as a function at run-time — ggtrace_capture_method","text":"","code":"library(ggplot2)  set.seed(47) df <- as.data.frame(matrix(sample(5, 50, TRUE), ncol = 2)) df #>    V1 V2 #> 1   3  5 #> 2   1  5 #> 3   2  4 #> 4   4  1 #> 5   1  5 #> 6   2  5 #> 7   5  1 #> 8   1  5 #> 9   5  2 #> 10  4  1 #> 11  5  3 #> 12  5  5 #> 13  4  3 #> 14  3  3 #> 15  3  5 #> 16  4  3 #> 17  1  1 #> 18  5  2 #> 19  2  5 #> 20  5  2 #> 21  2  2 #> 22  5  3 #> 23  3  5 #> 24  3  2 #> 25  1  3  p1 <- ggplot(df, aes(x = V1, y = V2)) + stat_summary(orientation = \"x\") p1 #> No summary function supplied, defaulting to `mean_se()`   p1_compute_panel <- ggtrace_capture_method(p1, method = StatSummary$compute_panel)  # `p1_compute_panel` is a copy of the ggproto method body(p1_compute_panel) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> } ggbody(StatSummary$compute_panel, as.list = FALSE) #> { #>     data <- flip_data(data, flipped_aes) #>     fun <- make_summary_fun(fun.data, fun, fun.max, fun.min,  #>         fun.args) #>     summarised <- summarise_by_x(data, fun) #>     summarised$flipped_aes <- flipped_aes #>     flip_data(summarised, flipped_aes) #> }  # Its arguments are pre-filled (captured at runtime) formals(p1_compute_panel) #> $data #>    x y PANEL group #> 1  3 5     1    -1 #> 2  1 5     1    -1 #> 3  2 4     1    -1 #> 4  4 1     1    -1 #> 5  1 5     1    -1 #> 6  2 5     1    -1 #> 7  5 1     1    -1 #> 8  1 5     1    -1 #> 9  5 2     1    -1 #> 10 4 1     1    -1 #> 11 5 3     1    -1 #> 12 5 5     1    -1 #> 13 4 3     1    -1 #> 14 3 3     1    -1 #> 15 3 5     1    -1 #> 16 4 3     1    -1 #> 17 1 1     1    -1 #> 18 5 2     1    -1 #> 19 2 5     1    -1 #> 20 5 2     1    -1 #> 21 2 2     1    -1 #> 22 5 3     1    -1 #> 23 3 5     1    -1 #> 24 3 2     1    -1 #> 25 1 3     1    -1 #>  #> $scales #> $scales$x #> <ScaleContinuousPosition> #>  Range:     1 --    5 #>  Limits:    1 --    5 #>  #> $scales$y #> <ScaleContinuousPosition> #>  Range:  1.42 -- 4.71 #>  Limits: 1.42 -- 4.71 #>  #>  #> $fun.data #> NULL #>  #> $fun #> NULL #>  #> $fun.max #> NULL #>  #> $fun.min #> NULL #>  #> $fun.args #> list() #>  #> $na.rm #> [1] FALSE #>  #> $flipped_aes #> [1] FALSE #>   # Runs as it should p1_compute_panel() #> No summary function supplied, defaulting to `mean_se()` #>   x group        y     ymin     ymax PANEL flipped_aes #> 1 1    -1 3.800000 3.000000 4.600000     1       FALSE #> 2 2    -1 4.000000 3.292893 4.707107     1       FALSE #> 3 3    -1 4.000000 3.367544 4.632456     1       FALSE #> 4 4    -1 2.000000 1.422650 2.577350     1       FALSE #> 5 5    -1 2.571429 2.090500 3.052357     1       FALSE  # You can inspect changes to its behavior outisde of ggplot # For example, see what happens when aes is flipped via `orientation = \"y\"` p1_compute_panel(flipped_aes = TRUE) #> No summary function supplied, defaulting to `mean_se()` #>   y group        x     xmin     xmax PANEL flipped_aes #> 1 1    -1 3.500000 2.633975 4.366025     1        TRUE #> 2 2    -1 4.000000 3.367544 4.632456     1        TRUE #> 3 3    -1 3.666667 3.052030 4.281303     1        TRUE #> 4 4    -1 2.000000       NA       NA     1        TRUE #> 5 5    -1 2.333333 1.892375 2.774292     1        TRUE  # We confirm this output to be true when `orientation = \"y\"` p2 <- ggplot(df, aes(x = V1, y = V2)) + stat_summary(orientation = \"y\") p2_compute_panel <- ggtrace_capture_method(p2, method = StatSummary$compute_panel) #> Warning: Removed 1 rows containing missing values (geom_segment).  identical(p1_compute_panel(flipped_aes = TRUE), p2_compute_panel()) #> No summary function supplied, defaulting to `mean_se()` #> No summary function supplied, defaulting to `mean_se()` #> [1] TRUE   # Note that the captured method looks slightly different if the method takes `...` p3 <- ggplot(df, aes(x = V1, y = V2)) + stat_smooth() + geom_jitter() p3 #> `geom_smooth()` using method = 'loess' and formula 'y ~ x'   p3_compute_panel <- ggtrace_capture_method(p3, method = Stat$compute_panel)  # For one, the body is different body(p3_compute_panel) #> { #>     cur_args <- mget(names(formals(rlang::current_fn()))) #>     specs <- names(cur_args) %in% names(formals(inner)) #>     do.call(inner, c(cur_args[specs], cur_args[!specs])) #> }  # The captured method is called internally, stored in the `\"inner\"` attribute attr(p3_compute_panel, \"inner\") #> function (self, data, scales, ...)  #> { #>     if (empty(data))  #>         return(new_data_frame()) #>     groups <- split(data, data$group) #>     stats <- lapply(groups, function(group) { #>         self$compute_group(data = group, scales = scales, ...) #>     }) #>     stats <- mapply(function(new, old) { #>         if (empty(new))  #>             return(new_data_frame()) #>         unique <- uniquecols(old) #>         missing <- !(names(unique) %in% names(new)) #>         cbind(new, unique[rep(1, nrow(new)), missing, drop = FALSE]) #>     }, stats, groups, SIMPLIFY = FALSE) #>     rbind_dfs(stats) #> } #> <environment: 0x00000000395196f0>  # Captured arguments are again stored in the formals of the function # Note that arguments passed to the `...` are promoted to function arguments names(formals(p3_compute_panel)) #>  [1] \"self\"        \"data\"        \"scales\"      \"method\"      \"formula\"     #>  [6] \"se\"          \"n\"           \"fullrange\"   \"level\"       \"na.rm\"       #> [11] \"method.args\" \"span\"        \"flipped_aes\" names(ggformals(Stat$compute_panel)) #> [1] \"self\"   \"data\"   \"scales\" \"...\"     # It works the same otherwise - plus you get the benefit of autocomplete head(p3_compute_panel()) #>          x        y     ymin     ymax        se flipped_aes PANEL group #> 1 1.000000 3.800000 2.456618 5.143382 0.6437060       FALSE     1    -1 #> 2 1.050633 3.814934 2.562634 5.067233 0.6000623       FALSE     1    -1 #> 3 1.101266 3.829354 2.645742 5.012967 0.5671495       FALSE     1    -1 #> 4 1.151899 3.843262 2.705881 4.980643 0.5449968       FALSE     1    -1 #> 5 1.202532 3.856658 2.744115 4.969200 0.5330951       FALSE     1    -1 #> 6 1.253165 3.869540 2.762657 4.976424 0.5303834       FALSE     1    -1 head(p3_compute_panel(level = .99)[, c(\"ymin\", \"ymax\")]) #>       ymin     ymax #> 1 1.967038 5.632962 #> 2 2.106247 5.523620 #> 3 2.214388 5.444321 #> 4 2.291376 5.395149 #> 5 2.338661 5.374654 #> 6 2.359266 5.379815 head(p3_compute_panel(flipped_aes = TRUE)) #>          y        x     xmin     xmax        se flipped_aes PANEL group #> 1 1.000000 3.486913 1.996579 4.977247 0.7148639        TRUE     1    -1 #> 2 1.050633 3.537510 2.136220 4.938801 0.6721527        TRUE     1    -1 #> 3 1.101266 3.585828 2.263181 4.908476 0.6344304        TRUE     1    -1 #> 4 1.151899 3.631850 2.377468 4.886232 0.6016854        TRUE     1    -1 #> 5 1.202532 3.675558 2.479204 4.871912 0.5738514        TRUE     1    -1 #> 6 1.253165 3.716935 2.568654 4.865215 0.5507921        TRUE     1    -1"},{"path":"/reference/ggtrace_highjack_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Highjack a method's execution and modify its argument values — ggtrace_highjack_args","title":"Highjack a method's execution and modify its argument values — ggtrace_highjack_args","text":"Highjack method's execution modify argument values","code":""},{"path":"/reference/ggtrace_highjack_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Highjack a method's execution and modify its argument values — ggtrace_highjack_args","text":"","code":"ggtrace_highjack_args(   x,   method,   cond = quote(._counter_ == 1L),   values,   draw = TRUE )"},{"path":"/reference/ggtrace_highjack_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Highjack a method's execution and modify its argument values — ggtrace_highjack_args","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond return value replaced. Defaults quote(._counter_ == 1L). values named list variable-value pairings. values expressions, evaluated formals. draw Whether draw modified graphical output evaluating x. Defaults TRUE.","code":""},{"path":"/reference/ggtrace_highjack_args.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Highjack a method's execution and modify its argument values — ggtrace_highjack_args","text":"gtable object class <ggtrace_highjacked>","code":""},{"path":"/reference/ggtrace_highjack_args.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Highjack a method's execution and modify its argument values — ggtrace_highjack_args","text":"quoted expressions passed cond value argument workflow functions (form ggtrace_{action}_{value}()), evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ (.data$._counter_) tracks many times function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1) evaluated TRUE method called first time, default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/ggtrace_highjack_args.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Highjack a method's execution and modify its argument values — ggtrace_highjack_args","text":"","code":"set.seed(1116) library(ggplot2) library(dplyr)   p <- ggplot(mtcars, aes(mpg, hp, color = factor(cyl))) +   geom_point() +   geom_smooth(method = \"lm\") p #> `geom_smooth()` using formula 'y ~ x'   # Fit predictions from loess regression just for second group ggtrace_highjack_args(   x = p,   method = StatSmooth$compute_group,   cond = quote(data$group[1] == 2),   values = list(method = \"loess\") ) #> `geom_smooth()` using formula 'y ~ x'   # If value is an expression, it's evaluated in the Tracing Context ggtrace_highjack_args(   x = p,   method = StatSmooth$compute_group,   cond = TRUE,   values = rlang::exprs(      # Every time the method is called, call it with a bigger CI     level = ._counter_ * 0.3,      # Fit models to just a random sample of the data     data = data %>%       slice_sample(prop = .8)    ) ) #> `geom_smooth()` using formula 'y ~ x'"},{"path":"/reference/ggtrace_highjack_return.html","id":null,"dir":"Reference","previous_headings":"","what":"Highjack a method's execution and make it return a user-supplied value — ggtrace_highjack_return","title":"Highjack a method's execution and make it return a user-supplied value — ggtrace_highjack_return","text":"Highjack method's execution make return user-supplied value","code":""},{"path":"/reference/ggtrace_highjack_return.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Highjack a method's execution and make it return a user-supplied value — ggtrace_highjack_return","text":"","code":"ggtrace_highjack_return(   x,   method,   cond = quote(._counter_ == 1L),   value = quote(returnValue()),   draw = TRUE )"},{"path":"/reference/ggtrace_highjack_return.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Highjack a method's execution and make it return a user-supplied value — ggtrace_highjack_return","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond return value replaced. Defaults quote(._counter_ == 1L). value method return instead. Defaults quote(returnValue()). draw Whether draw modified graphical output evaluating x. Defaults TRUE.","code":""},{"path":"/reference/ggtrace_highjack_return.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Highjack a method's execution and make it return a user-supplied value — ggtrace_highjack_return","text":"gtable object class <ggtrace_highjacked>","code":""},{"path":"/reference/ggtrace_highjack_return.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Highjack a method's execution and make it return a user-supplied value — ggtrace_highjack_return","text":"quoted expressions passed cond value argument workflow functions (form ggtrace_{action}_{value}()), evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ (.data$._counter_) tracks many times function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1) evaluated TRUE method called first time, default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/ggtrace_highjack_return.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Highjack a method's execution and make it return a user-supplied value — ggtrace_highjack_return","text":"","code":"set.seed(1116) library(ggplot2) library(dplyr)   p1 <- ggplot(diamonds, aes(cut)) +   geom_bar(aes(fill = cut)) +   facet_wrap(~ clarity)  p1   # Highjack `Stat$compute_panel` at the first panel `cond = quote(._counter_ == 1L)` # to return higher values for `count` ggtrace_highjack_return(   x = p1, method = Stat$compute_panel,   value = quote({     returnValue() %>%       mutate(count = count * 100)   }) )   # Highjack `Stat$compute_panel` at the fourth panel # to shuffle bars in the x-axis ggtrace_highjack_return(   x = p1, method = Stat$compute_panel,   cond = quote(data$PANEL[1] == 4),   value = quote({     returnValue() %>%       mutate(x = sample(x))   }) )   # Bars get a black outline and get darker from left-to-right, but only for second panel ggtrace_highjack_return(   x = p1, method = GeomBar$draw_panel,   cond = quote(data$PANEL[1] == 2),   value = quote({     editGrob(returnValue(), gp = gpar(       col = \"black\", alpha = seq(0.2, 1, length.out = nrow(data)     )))   }) )"},{"path":"/reference/ggtrace_inspect_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect how many times a method was called — ggtrace_inspect_n","title":"Inspect how many times a method was called — ggtrace_inspect_n","text":"Inspect many times method called","code":""},{"path":"/reference/ggtrace_inspect_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect how many times a method was called — ggtrace_inspect_n","text":"","code":"ggtrace_inspect_n(x, method)"},{"path":"/reference/ggtrace_inspect_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect how many times a method was called — ggtrace_inspect_n","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method","code":""},{"path":"/reference/ggtrace_inspect_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inspect how many times a method was called — ggtrace_inspect_n","text":"number times method called evaluation x","code":""},{"path":"/reference/ggtrace_inspect_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inspect how many times a method was called — ggtrace_inspect_n","text":"","code":"library(ggplot2)  p1 <- ggplot(diamonds, aes(cut)) +   geom_bar(aes(fill = cut)) +   facet_wrap(~ clarity)  p1   # 1 call to Stat$compute_layer ggtrace_inspect_n(p1, Stat$compute_layer) #> [1] 1  # 8 calls to Stat$compute_panel ggtrace_inspect_n(p1, Stat$compute_panel) #> [1] 8  # Note that there are 0 calls to Stat$compute_group ... ggtrace_inspect_n(p1, Stat$compute_group) #> [1] 0  # because StatCount has its own \"compute_group\" method defined ggtrace_inspect_n(p1, StatCount$compute_group) #> [1] 40  # How about if we add a second layer that uses StatCount? p2 <- p1 + geom_text(   aes(label = after_stat(count)),   stat = StatCount, position = position_nudge(y = 500) )  p2   # Now there are double the calls to Stat/StatCount methods ggtrace_inspect_n(p2, Stat$compute_layer) #> [1] 2 ggtrace_inspect_n(p2, Stat$compute_panel) #> [1] 16 ggtrace_inspect_n(p2, StatCount$compute_group) #> [1] 80  # But separate calls to each layer's respective Geoms ggtrace_inspect_n(p2, GeomBar$draw_panel) #> [1] 8 ggtrace_inspect_n(p2, GeomText$draw_panel) #> [1] 8"},{"path":"/reference/ggtrace_inspect_return.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect the return value of a method — ggtrace_inspect_return","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"Inspect return value method","code":""},{"path":"/reference/ggtrace_inspect_return.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"","code":"ggtrace_inspect_return(x, method, cond = quote(._counter_ == 1L))"},{"path":"/reference/ggtrace_inspect_return.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond return value inspected. Defaults quote(._counter_ == 1L).","code":""},{"path":"/reference/ggtrace_inspect_return.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"return value method first called.","code":""},{"path":"/reference/ggtrace_inspect_return.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"quoted expressions passed cond value argument workflow functions (form ggtrace_{action}_{value}()), evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ (.data$._counter_) tracks many times function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1) evaluated TRUE method called first time, default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/ggtrace_inspect_return.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inspect the return value of a method — ggtrace_inspect_return","text":"","code":"library(ggplot2)  p1 <- ggplot(diamonds, aes(cut)) +   geom_bar(aes(fill = cut)) +   facet_wrap(~ clarity)  p1   # Return value of `Stat$compute_panel` for the # first panel `cond = quote(._counter_ == 1L)` ggtrace_inspect_return(x = p1, method = Stat$compute_panel) #>   count prop x width flipped_aes      fill PANEL group #> 1   210    1 1   0.9       FALSE      Fair     1     1 #> 2    96    1 2   0.9       FALSE      Good     1     2 #> 3    84    1 3   0.9       FALSE Very Good     1     3 #> 4   205    1 4   0.9       FALSE   Premium     1     4 #> 5   146    1 5   0.9       FALSE     Ideal     1     5  # Return value for 4th panel ggtrace_inspect_return(x = p1, method = Stat$compute_panel,                        cond = quote(._counter_ == 4L)) #>   count prop x width flipped_aes      fill PANEL group #> 1   261    1 1   0.9       FALSE      Fair     4     1 #> 2   978    1 2   0.9       FALSE      Good     4     2 #> 3  2591    1 3   0.9       FALSE Very Good     4     3 #> 4  3357    1 4   0.9       FALSE   Premium     4     4 #> 5  5071    1 5   0.9       FALSE     Ideal     4     5  # Return value for 4th panel, 2nd group (bar) ggtrace_inspect_return(   x = p1, method = StatCount$compute_group,   cond = quote(data$PANEL[1] == 4 && data$group == 2) ) #>   count prop x width flipped_aes #> 1   978    1 2   0.9       FALSE"},{"path":"/reference/ggtrace_inspect_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect the value of variables from a method — ggtrace_inspect_vars","title":"Inspect the value of variables from a method — ggtrace_inspect_vars","text":"Inspect value variables method","code":""},{"path":"/reference/ggtrace_inspect_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect the value of variables from a method — ggtrace_inspect_vars","text":"","code":"ggtrace_inspect_vars(   x,   method,   cond = quote(._counter_ == 1L),   at = \"all\",   vars,   by_var = TRUE )"},{"path":"/reference/ggtrace_inspect_vars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect the value of variables from a method — ggtrace_inspect_vars","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond return value inspected. Defaults quote(._counter_ == 1L). steps method body values vars retrieved. Defaults special value evaluated steps method body. vars character vector variable names by_var Boolean controls format output: TRUE (default): returns list variables, values step. also drops steps within variable variable value changed previous step specified . FALSE: returns list steps, element holds value vars step . Unchanged variable values dropped.","code":""},{"path":"/reference/ggtrace_inspect_vars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inspect the value of variables from a method — ggtrace_inspect_vars","text":"list","code":""},{"path":"/reference/ggtrace_inspect_vars.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Inspect the value of variables from a method — ggtrace_inspect_vars","text":"quoted expressions passed cond value argument workflow functions (form ggtrace_{action}_{value}()), evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ (.data$._counter_) tracks many times function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1) evaluated TRUE method called first time, default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/ggtrace_inspect_vars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inspect the value of variables from a method — ggtrace_inspect_vars","text":"","code":"library(ggplot2)  p1 <- ggplot(mtcars[1:10,], aes(mpg, hp)) +   geom_smooth() p1 #> `geom_smooth()` using method = 'loess' and formula 'y ~ x'   # The `data` variable is bound to two unique values in `compute_group` method: ggtrace_inspect_vars(p1, StatSmooth$compute_group, vars = \"data\") #> `geom_smooth()` using method = 'loess' and formula 'y ~ x' #> $Step1 #>       x   y PANEL group #> 1  21.0 110     1    -1 #> 2  21.0 110     1    -1 #> 3  22.8  93     1    -1 #> 4  21.4 110     1    -1 #> 5  18.7 175     1    -1 #> 6  18.1 105     1    -1 #> 7  14.3 245     1    -1 #> 8  24.4  62     1    -1 #> 9  22.8  95     1    -1 #> 10 19.2 123     1    -1 #>  #> $Step5 #>       x   y PANEL group weight #> 1  21.0 110     1    -1      1 #> 2  21.0 110     1    -1      1 #> 3  22.8  93     1    -1      1 #> 4  21.4 110     1    -1      1 #> 5  18.7 175     1    -1      1 #> 6  18.1 105     1    -1      1 #> 7  14.3 245     1    -1      1 #> 8  24.4  62     1    -1      1 #> 9  22.8  95     1    -1      1 #> 10 19.2 123     1    -1      1 #>   # Note that elements of this list capture the method's state upon entering a step, # so \"Step1\" and \"Step5\" should be interpreted as the value of `data` at the start # the method's execution (before \"Step1\") and its value as a result of running Step4 # (before \"Step5\"). Indeed, we see that the `weight` column is defined in Step4, so # the data is flagged as changed at the start of Step5 ggbody(StatSmooth$compute_group)[[4]] #> if (is.null(data$weight)) data$weight <- 1   # Comparing the \"Steps\" themselves can be useful p2 <- p1 +   scale_x_continuous(trans = \"log\") +   scale_y_continuous(trans = \"log\") p2 #> `geom_smooth()` using method = 'loess' and formula 'y ~ x'   # Comparing the original plot to one with log-transformed scales reveals a change # in data detected at the beginning of Step 14 names(ggtrace_inspect_vars(p1, ggplot2:::ggplot_build.ggplot, vars = \"data\")) #> `geom_smooth()` using method = 'loess' and formula 'y ~ x' #> [1] \"Step9\"  \"Step12\" \"Step13\" \"Step19\" \"Step30\" names(ggtrace_inspect_vars(p2, ggplot2:::ggplot_build.ggplot, vars = \"data\")) #> `geom_smooth()` using method = 'loess' and formula 'y ~ x' #> [1] \"Step9\"  \"Step12\" \"Step13\" \"Step14\" \"Step19\" \"Step30\"  # We can pinpoint the calculation of scale transformations to Step 13: ggbody(ggplot2:::ggplot_build.ggplot)[[13]] #> data <- lapply(data, scales_transform_df, scales = scales)   # With `by_vars = FALSE`, elements of the returned list are steps instead of values. # Note that this does not drop unchanged values: ggtrace_inspect_vars(p1, StatSmooth$compute_group, vars = \"data\", at = 1:6, by_var = FALSE) #> `geom_smooth()` using method = 'loess' and formula 'y ~ x' #> $Step1 #> $Step1$data #>       x   y PANEL group #> 1  21.0 110     1    -1 #> 2  21.0 110     1    -1 #> 3  22.8  93     1    -1 #> 4  21.4 110     1    -1 #> 5  18.7 175     1    -1 #> 6  18.1 105     1    -1 #> 7  14.3 245     1    -1 #> 8  24.4  62     1    -1 #> 9  22.8  95     1    -1 #> 10 19.2 123     1    -1 #>  #>  #> $Step2 #> $Step2$data #>       x   y PANEL group #> 1  21.0 110     1    -1 #> 2  21.0 110     1    -1 #> 3  22.8  93     1    -1 #> 4  21.4 110     1    -1 #> 5  18.7 175     1    -1 #> 6  18.1 105     1    -1 #> 7  14.3 245     1    -1 #> 8  24.4  62     1    -1 #> 9  22.8  95     1    -1 #> 10 19.2 123     1    -1 #>  #>  #> $Step3 #> $Step3$data #>       x   y PANEL group #> 1  21.0 110     1    -1 #> 2  21.0 110     1    -1 #> 3  22.8  93     1    -1 #> 4  21.4 110     1    -1 #> 5  18.7 175     1    -1 #> 6  18.1 105     1    -1 #> 7  14.3 245     1    -1 #> 8  24.4  62     1    -1 #> 9  22.8  95     1    -1 #> 10 19.2 123     1    -1 #>  #>  #> $Step4 #> $Step4$data #>       x   y PANEL group #> 1  21.0 110     1    -1 #> 2  21.0 110     1    -1 #> 3  22.8  93     1    -1 #> 4  21.4 110     1    -1 #> 5  18.7 175     1    -1 #> 6  18.1 105     1    -1 #> 7  14.3 245     1    -1 #> 8  24.4  62     1    -1 #> 9  22.8  95     1    -1 #> 10 19.2 123     1    -1 #>  #>  #> $Step5 #> $Step5$data #>       x   y PANEL group weight #> 1  21.0 110     1    -1      1 #> 2  21.0 110     1    -1      1 #> 3  22.8  93     1    -1      1 #> 4  21.4 110     1    -1      1 #> 5  18.7 175     1    -1      1 #> 6  18.1 105     1    -1      1 #> 7  14.3 245     1    -1      1 #> 8  24.4  62     1    -1      1 #> 9  22.8  95     1    -1      1 #> 10 19.2 123     1    -1      1 #>  #>  #> $Step6 #> $Step6$data #>       x   y PANEL group weight #> 1  21.0 110     1    -1      1 #> 2  21.0 110     1    -1      1 #> 3  22.8  93     1    -1      1 #> 4  21.4 110     1    -1      1 #> 5  18.7 175     1    -1      1 #> 6  18.1 105     1    -1      1 #> 7  14.3 245     1    -1      1 #> 8  24.4  62     1    -1      1 #> 9  22.8  95     1    -1      1 #> 10 19.2 123     1    -1      1 #>  #>"},{"path":"/reference/ggtrace_inspect_which.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect which calls to a ggproto method met a particular condition — ggtrace_inspect_which","title":"Inspect which calls to a ggproto method met a particular condition — ggtrace_inspect_which","text":"Inspect calls ggproto method met particular condition","code":""},{"path":"/reference/ggtrace_inspect_which.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect which calls to a ggproto method met a particular condition — ggtrace_inspect_which","text":"","code":"ggtrace_inspect_which(x, method, cond)"},{"path":"/reference/ggtrace_inspect_which.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect which calls to a ggproto method met a particular condition — ggtrace_inspect_which","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method cond Expression evaluating logical inside method x evaluated.","code":""},{"path":"/reference/ggtrace_inspect_which.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inspect which calls to a ggproto method met a particular condition — ggtrace_inspect_which","text":"values tracing context variable ._counter_ cond evaluated TRUE.","code":""},{"path":"/reference/ggtrace_inspect_which.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Inspect which calls to a ggproto method met a particular condition — ggtrace_inspect_which","text":"quoted expressions passed cond value argument workflow functions (form ggtrace_{action}_{value}()), evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ (.data$._counter_) tracks many times function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1) evaluated TRUE method called first time, default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/ggtrace_inspect_which.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inspect which calls to a ggproto method met a particular condition — ggtrace_inspect_which","text":"","code":"library(ggplot2)  p1 <- ggplot(diamonds, aes(cut)) +   geom_bar(aes(fill = cut)) +   facet_wrap(~ clarity) p1    # Values of `._counter_` when `compute_group` is called for groups in the second panel: ggtrace_inspect_which(p1, StatCount$compute_group, quote(data$PANEL[1] == 2)) #> [1]  6  7  8  9 10   # How about if we add a second layer that uses StatCount? p2 <- p1 + geom_text(   aes(label = after_stat(count)),   stat = StatCount, position = position_nudge(y = 500) ) p2   ggtrace_inspect_which(p2, StatCount$compute_group, quote(data$PANEL[1] == 2)) #>  [1]  6  7  8  9 10 46 47 48 49 50   # Behaves like `base::which()` and returns `integer(0)` when no matches are found ggtrace_inspect_which(p2, StatBoxplot$compute_group, quote(data$PANEL[1] == 2)) #> integer(0)"},{"path":"/reference/ggtrace_modify_return.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify the return value of a method — ggtrace_modify_return","title":"Modify the return value of a method — ggtrace_modify_return","text":"Modify return value method","code":""},{"path":"/reference/ggtrace_modify_return.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify the return value of a method — ggtrace_modify_return","text":"","code":"ggtrace_modify_return(x, method, value, cond = TRUE, draw = TRUE)"},{"path":"/reference/ggtrace_modify_return.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify the return value of a method — ggtrace_modify_return","text":"x ggplot object method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method value Value method return called cond return value replaced draw Whether draw modified plot","code":""},{"path":"/reference/ggtrace_modify_return.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modify the return value of a method — ggtrace_modify_return","text":"gtable object class <ggtrace_modified>","code":""},{"path":"/reference/gguntrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove any existing traces — gguntrace","title":"Remove any existing traces — gguntrace","text":"Used explicitly calling untrace() ggproto object.","code":""},{"path":"/reference/gguntrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove any existing traces — gguntrace","text":"","code":"gguntrace(method, ...)"},{"path":"/reference/gguntrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove any existing traces — gguntrace","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Ignored. Designed ease calling function modifying call earlier {ggtrace} function interactive contexts.","code":""},{"path":"/reference/gguntrace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove any existing traces — gguntrace","text":"Unlike base::untrace(), adverse side effect repeatedly calling gguntrace() ggproto method. gguntrace() throw error method found. method valid, gguntrace() one two things: Inform successfully removed trace (untracing) Inform existing trace (nothing)","code":""},{"path":[]},{"path":"/reference/gguntrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove any existing traces — gguntrace","text":"","code":"library(ggplot2)  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` not currently being traced.  is_traced(Stat$compute_layer) #> [1] FALSE  ggtrace(Stat$compute_layer, 1) #> `Stat$compute_layer` now being traced.  is_traced(Stat$compute_layer) #> [1] TRUE  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` no longer being traced.  is_traced(Stat$compute_layer) #> [1] FALSE  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` not currently being traced."},{"path":"/reference/global_ggtrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"global_ggtrace() list trace dumps collected across multiple traces, recommended use ggtrace(= FALSE) expect trace independently triggered multiple times (example, tracing (compute/draw)_group method multiple groups, plot multiple layers call method traced).","code":""},{"path":"/reference/global_ggtrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"","code":"global_ggtrace()  set_global_ggtrace(value)  clear_global_ggtrace()  global_ggtrace_state(state)  global_ggtrace_on()  global_ggtrace_off()"},{"path":"/reference/global_ggtrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"state missing, returns whether global tracedump currently active. global tracedump inactive default (state FALSE). activated, every time trace created ggtrace() triggered tracedump added global tracedump storage, can inspected global_ggtrace(). global tracedump can turned /setting state TRUE/FALSE.","code":""},{"path":"/reference/global_ggtrace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"List logical indicating current state global trace dump. state provided, changes state first, returns state invisibly.","code":""},{"path":"/reference/global_ggtrace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"clear_global_ggtrace() sets value global_ggtrace() NULL returns NULL. can inspect state global trace dump global_ggtrace_state() activate deactivate global_ggtrace_on() global_ggtrace_off(), aliases global_ggtrace_state(TRUE) global_ggtrace_state(FALSE), respectively.","code":""},{"path":"/reference/global_ggtrace.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"trace dump pushed global_ggtrace(), gets named ggproto method hex code identifying method's runtime environment, e.g. \"Stat$compute_layer-00000267437FD3D8\".","code":""},{"path":[]},{"path":"/reference/global_ggtrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve all tracedumps created by ggtrace() — global_ggtrace","text":"","code":"library(ggplot2)  global_ggtrace_state() # global tracedump is inactive by default since v0.4.3 #> [1] FALSE global_ggtrace_on()    # alias for global_ggtrace_state(TRUE) #> Global tracedump activated. clear_global_ggtrace() #> Global tracedump cleared.  ggtrace(   GeomBoxplot$draw_group,   trace_steps = -1,   once = FALSE,   verbose = FALSE ) #> `GeomBoxplot$draw_group` now being traced. #> Creating a persistent trace. Remember to `gguntrace(GeomBoxplot$draw_group)`!  ggplot(mpg, aes(class, hwy)) + geom_boxplot() #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group` #> Triggering persistent trace on `GeomBoxplot$draw_group`   gguntrace(GeomBoxplot$draw_group) #> `GeomBoxplot$draw_group` no longer being traced.  boxplot_group_tracedump <- global_ggtrace()  length(boxplot_group_tracedump) #> [1] 7  boxplot_group_tracedump <- unlist(   boxplot_group_tracedump,   recursive = FALSE,   use.names = FALSE )  patchwork::wrap_plots(boxplot_group_tracedump, nrow = 1)   clear_global_ggtrace() #> Global tracedump cleared. global_ggtrace() #> NULL  global_ggtrace_off() # alias for global_ggtrace_state(FALSE) #> Global tracedump deactivated."},{"path":"/reference/is_traced.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a method is being traced — is_traced","title":"Check if a method is being traced — is_traced","text":"Check method traced","code":""},{"path":"/reference/is_traced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a method is being traced — is_traced","text":"","code":"is_traced(method)"},{"path":"/reference/is_traced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a method is being traced — is_traced","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method","code":""},{"path":"/reference/is_traced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if a method is being traced — is_traced","text":"logical","code":""},{"path":"/reference/is_traced.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if a method is being traced — is_traced","text":"","code":"library(ggplot2)  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` not currently being traced.  is_traced(Stat$compute_layer) #> [1] FALSE  ggtrace(Stat$compute_layer, 1) #> `Stat$compute_layer` now being traced.  is_traced(Stat$compute_layer) #> [1] TRUE  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` no longer being traced.  is_traced(Stat$compute_layer) #> [1] FALSE  gguntrace(Stat$compute_layer) #> `Stat$compute_layer` not currently being traced."},{"path":"/reference/last_ggtrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","title":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","text":"last_ggtrace() retrieves last trace dump created ggtrace() - .e., last time trace triggered.","code":""},{"path":"/reference/last_ggtrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","text":"","code":"last_ggtrace()  set_last_ggtrace(value)  clear_last_ggtrace()"},{"path":"/reference/last_ggtrace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","text":"List","code":""},{"path":"/reference/last_ggtrace.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","text":"tracedump refers output expression evaluated inside traced function trace triggered. context ggtrace(), tracedump list long number step-expression pairs, element output expression (trace_exprs) evaluated step (trace_steps) inside execution environment function ggproto method. clear_last_ggtrace() sets value last_ggtrace() NULL returns NULL.","code":""},{"path":[]},{"path":"/reference/last_ggtrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the last tracedump created by ggtrace() — last_ggtrace","text":"","code":"library(ggplot2)  ggtrace(StatSmooth$compute_group, trace_steps = -1, trace_exprs = quote(head(prediction))) #> `StatSmooth$compute_group` now being traced.  ggplot(mtcars, aes(mpg, hp)) + geom_point() + geom_smooth(method = 'lm') #> `geom_smooth()` using formula 'y ~ x' #> Triggering trace on `StatSmooth$compute_group` #> Untracing `StatSmooth$compute_group` on exit.   last_ggtrace() #> [[1]] #>          x        y     ymin     ymax       se flipped_aes #> 1 10.40000 232.2531 201.8649 262.6414 14.87963       FALSE #> 2 10.69747 229.6265 199.9139 259.3392 14.54880       FALSE #> 3 10.99494 227.0000 197.9569 256.0430 14.22094       FALSE #> 4 11.29241 224.3734 195.9934 252.7534 13.89627       FALSE #> 5 11.58987 221.7468 194.0230 249.4707 13.57502       FALSE #> 6 11.88734 219.1203 192.0450 246.1956 13.25743       FALSE #>   ggtrace(   StatSmooth$compute_group,   trace_steps = -1,   trace_exprs = quote(prediction),   verbose = FALSE ) #> `StatSmooth$compute_group` now being traced.  ggplot(mtcars, aes(mpg, hp)) + geom_point() + geom_smooth(method = 'lm') #> `geom_smooth()` using formula 'y ~ x' #> Triggering trace on `StatSmooth$compute_group` #> Untracing `StatSmooth$compute_group` on exit.   head(last_ggtrace()[[1]]) #>          x        y     ymin     ymax       se flipped_aes #> 1 10.40000 232.2531 201.8649 262.6414 14.87963       FALSE #> 2 10.69747 229.6265 199.9139 259.3392 14.54880       FALSE #> 3 10.99494 227.0000 197.9569 256.0430 14.22094       FALSE #> 4 11.29241 224.3734 195.9934 252.7534 13.89627       FALSE #> 5 11.58987 221.7468 194.0230 249.4707 13.57502       FALSE #> 6 11.88734 219.1203 192.0450 246.1956 13.25743       FALSE"},{"path":"/reference/one-offs.html","id":null,"dir":"Reference","previous_headings":"","what":"Debugonce a ggproto method — one-offs","title":"Debugonce a ggproto method — one-offs","text":"Debugonce ggproto method Inspect call stack","code":""},{"path":"/reference/one-offs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Debugonce a ggproto method — one-offs","text":"","code":"ggdebugonce(method, ...)  ggtraceback(method, ...)"},{"path":"/reference/one-offs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Debugonce a ggproto method — one-offs","text":"method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Arguments passed rlang::trace_back top first frame environment included backtrace. becomes top backtrace tree represents oldest call backtrace. needed particular call trace_back() indirectly larger context, example tests inside RMarkdown document want knitr evaluation mechanisms appear backtrace. bottom last frame environment included backtrace. becomes rightmost leaf backtrace tree represents youngest call backtrace. Set like capture backtrace without capture context. Can also integer passed caller_env().","code":""},{"path":"/reference/one-offs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Debugonce a ggproto method — one-offs","text":"Calls rlang::trace_back() upon first entering function method. Note ggtraceback() ever prints back trace calls gguntrace() first time triggered. complex inspections call stack, ggedit() recommended.","code":""},{"path":"/reference/one-offs.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Debugonce a ggproto method — one-offs","text":"output rlang::trace_back() logged tracedumps (last_ggtrace() global_ggtrace())","code":""},{"path":"/reference/topic-tracing-context.html","id":null,"dir":"Reference","previous_headings":"","what":"Context-dependent workflow expressions in the tracing context — topic-tracing-context","title":"Context-dependent workflow expressions in the tracing context — topic-tracing-context","text":"Context-dependent workflow expressions tracing context","code":""},{"path":"/reference/topic-tracing-context.html","id":"tracing-context","dir":"Reference","previous_headings":"","what":"Tracing context","title":"Context-dependent workflow expressions in the tracing context — topic-tracing-context","text":"quoted expressions passed cond value argument workflow functions (form ggtrace_{action}_{value}()), evaluated special environment call \"tracing context\". tracing context \"data-masked\" (see rlang::eval_tidy()), exposes internal variable called ._counter_ (.data$._counter_) tracks many times function/method called ggplot object supplied x argument workflow functions. example, cond = quote(._counter_ == 1) evaluated TRUE method called first time, default value cond workflow functions return one value (e.g., ggtrace_capture_fn()). highjack functions like ggtrace_highjack_return(), value returned function/method can accessed returnValue() value argument. default, value set quote(returnValue()) simply evaluates return value, directly computing returnValue() derive different return value function/method also possible.","code":""},{"path":"/reference/with_ggtrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic workflow function which localizes a ggtrace call to a single ggplot object — with_ggtrace","title":"Generic workflow function which localizes a ggtrace call to a single ggplot object — with_ggtrace","text":"with_ggtrace() provides functional interface ggtrace(). takes ggplot object parameters passed ggtrace() returns immediate tracedump /graphical output without side effects.","code":""},{"path":"/reference/with_ggtrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic workflow function which localizes a ggtrace call to a single ggplot object — with_ggtrace","text":"","code":"with_ggtrace(x, method, ..., out = c(\"tracedump\", \"gtable\", \"both\"))"},{"path":"/reference/with_ggtrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic workflow function which localizes a ggtrace call to a single ggplot object — with_ggtrace","text":"x ggplot object whose evaluation triggers trace specified ... method function ggproto method. ggproto method may specified using following forms: ggproto$method namespace::ggproto$method namespace:::ggproto$method ... Arguments passed ggtrace trace_steps sorted numeric vector positions method's body trace. Negative indices reference steps last, -1 references last step body. trace_exprs list expressions evaluate position specified trace_steps. single expression provided, recycled match length trace_steps. simply run step return output, can use ~step keyword. step assign expression, value assigned variable returned. trace_exprs provided, ggtrace() called ~step default. Whether untrace() method exit. FALSE, creates persistent trace active gguntrace() called method. Defaults TRUE. use_names Whether trace dump use names trace_exprs. Defaults TRUE. print_output Whether print() output expression console. Defaults TRUE. verbose Whether logs printed trace triggered. Encompasses print_output, meaning verbose = FALSE also triggers effect print_output = FALSE consequence. Defaults FALSE. Whether function return output triggered traces (\"tracedump\"), resulting graphical object evaluating ggplot (\"gtable\"), \"\", returns tracedump also renders resulting plot side effect. Partial matching supported, options also specified \"t\", \"g\", \"b\". Defaults \"tracedump\".","code":""},{"path":"/reference/with_ggtrace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic workflow function which localizes a ggtrace call to a single ggplot object — with_ggtrace","text":"list gtable object class <ggtrace_highjacked>","code":""},{"path":"/reference/with_ggtrace.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generic workflow function which localizes a ggtrace call to a single ggplot object — with_ggtrace","text":"trigger evaluation x, function ggeval_silent(x) called internally.","code":""},{"path":[]},{"path":"/reference/with_ggtrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generic workflow function which localizes a ggtrace call to a single ggplot object — with_ggtrace","text":"","code":"library(ggplot2)  # Long-form `ggtrace()` method: boxplot_plot <- ggplot(diamonds[1:500,], aes(cut, depth)) + geom_boxplot() ggtrace(  method = StatBoxplot$compute_group,  trace_steps = -1, trace_exprs = quote(~step) ) #> `StatBoxplot$compute_group` now being traced. boxplot_plot #> Triggering trace on `StatBoxplot$compute_group` #> Untracing `StatBoxplot$compute_group` on exit.  first_tracedump <- last_ggtrace()  # Short-form functional `with_ggtrace()` method: second_tracedump <- with_ggtrace(   x = boxplot_plot,   method = StatBoxplot$compute_group,   trace_steps = -1, trace_exprs = quote(~step) )  identical(first_tracedump, second_tracedump) #> [1] TRUE   # An example with `out = \"gtable\"` (or `\"g\"`) grid_plot <- ggplot(mtcars, aes(mpg, hp)) +   geom_point() +   facet_grid(am ~ cyl) grid_plot   outline <- grid::rectGrob(   x = 0.5, y = 0.5, width = 1, height = 1,   gp = grid::gpar(col = \"red\", lwd = 5, fill = NA) )  with_ggtrace(   x = grid_plot,   method = Layout$render,   trace_steps = 5,   trace_exprs = rlang::expr({     panels[c(3, 5)] <- lapply(panels[c(3, 5)], function(panel) {       gTree(children = gList(panel, !!outline))     })   }),   out = \"gtable\" # or \"g\" )    # With `once = FALSE` for persistent tracing (still cleaned up after) lm_plot <- ggplot(mpg, aes(displ, hwy, color = drv)) +   geom_point() +   geom_smooth(method = \"lm\") lm_plot #> `geom_smooth()` using formula 'y ~ x'   with_ggtrace(   x = lm_plot,   method = StatSmooth$compute_group,   trace_steps = c(1, 11),   trace_exprs = list(     group = quote(data$group[1]),     coef = quote(model$coef)   ) ) #> $group #> [1] 1 #>  #> $coef #> (Intercept)           x  #>   30.683113   -2.878486  #>   with_ggtrace(   x = lm_plot,   method = StatSmooth$compute_group,   trace_steps = 1,   trace_exprs = quote(method <- c(\"loess\", \"lm\", \"loess\")[data$group[1]]),   out = \"g\" # or \"gtable\" )    # `with_ggtrace()` is useful for making calculations that are parasitic # on a plot's execution environment.  library(grid)  square_plot <- ggplot(mtcars, aes(mpg, hp, color = factor(cyl))) +   geom_point() +   theme(aspect.ratio = 1) square_plot   rotation_vp <- viewport(width = .7, height = .7, angle = 45)  parasitic_evaluations <- with_ggtrace(   x = square_plot,   method = ggplot2:::ggplot_gtable.ggplot_built,   trace_steps = c(9, 13, -1),   trace_exprs = rlang::exprs(     plot_tbl = .plot_table <- editGrob(plot_table, vp = !!rotation_vp),     legend   = .legend <- editGrob(legend_box, vp = viewport(x = 0.15, y = 0.8)),     modified = gTree(children = gList(.plot_table, .legend))   ) )  grid.newpage() grid.draw(parasitic_evaluations$modified) #> Warning: cannot clip to rotated viewport"},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"new-features-development-version","dir":"Changelog","previous_headings":"ggtrace 0.5.0","what":"New Features","title":"ggtrace (development version)","text":"Added complements base::debug() family functions compatible ggproto methods - ggdebug(), ggdebugonce(), ggundebug() get_method_inheritance get list methods self parent ggprotos ggtrace_inspect_n() get number times method called evaluation ggplot ggtrace_inspect_vars() get value variables specified steps method’s execution ggtrace_highjack_args() modify formals method execution ggtrace_highjack_return() exposes ._counter_ value argument with_ggtrace() gets argument can take 1 three options: “t” “tracedump” (default): returns local tracedump triggering traces method ggplot x evaluated “g” “gtable”: Invisibly returns <gtable> grob evaluating x injected expressions method. “b” “”: returns tracedump rendering gtable (grid::grid.draw()) side effect. Low-level functions ggtrace()/gguntrace() wrapper with_ggtrace() can now take quosures method argument, allows used programmatically.","code":""},{"path":"/news/index.html","id":"breaking-changes-development-version","dir":"Changelog","previous_headings":"ggtrace 0.5.0","what":"Breaking Changes","title":"ggtrace (development version)","text":"ggtrace_capture_env() default value changed -1L, captures snapshot runtime environment right method returns. first element used length > 1 “modify” workflows renamed “highjack” reflect fact always return graphical output (gtable grob) (#78)","code":""},{"path":"/news/index.html","id":"bug-fixes-development-version","dir":"Changelog","previous_headings":"ggtrace 0.5.0","what":"Bug Fixes","title":"ggtrace (development version)","text":"Fixed issue trace fail remove ggtrace(= TRUE) triggered copy traced function (#59)","code":""},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"new-features-0-4","dir":"Changelog","previous_headings":"ggtrace 0.4.8","what":"New Features","title":"ggtrace 0.4.x","text":"Added with_ggtrace() functional interface ggtrace() Added ggtrace_capture_fn() ggtrace_capture_env(), return snapshot function/environment ggproto method execution time Added ggtrace_inspect_return() ggtrace_modify_return() grab swap return values method’s execution","code":""},{"path":"/news/index.html","id":"miscellaneous-0-4","dir":"Changelog","previous_headings":"ggtrace 0.4.8","what":"Miscellaneous","title":"ggtrace 0.4.x","text":"Added workflows section docs/references","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-4-1","dir":"Changelog","previous_headings":"ggtrace 0.4.7","what":"New Features","title":"ggtrace 0.4.x","text":"Added ggformals() returns formals() functions ggproto methods ggbody() gains .list argument control whether output body() turned list Exported set_last_ggtrace() set_global_ggtrace() tracedumps","code":""},{"path":"/news/index.html","id":"bug-fix-0-4","dir":"Changelog","previous_headings":"ggtrace 0.4.7","what":"Bug Fix","title":"ggtrace 0.4.x","text":"Fixed compatibility issues {rlang} v1.0.0 new changes call expression API","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-4-2","dir":"Changelog","previous_headings":"ggtrace 0.4.6","what":"New Features","title":"ggtrace 0.4.x","text":"Added get_method() returns ggproto methods functions Added wrappers one-workflows ggdebugonce() ggtraceback()","code":""},{"path":"/news/index.html","id":"improvements-0-4","dir":"Changelog","previous_headings":"ggtrace 0.4.6","what":"Improvements","title":"ggtrace 0.4.x","text":"default value verbose argument ggtrace() changed FALSE.","code":""},{"path":[]},{"path":"/news/index.html","id":"improvements-0-4-1","dir":"Changelog","previous_headings":"ggtrace 0.4.5","what":"Improvements","title":"ggtrace 0.4.x","text":"Deparsed expressions printed messages now wrapped backticks (#57) ggedit() now works isTRUE(interactive()) (#62)","code":""},{"path":"/news/index.html","id":"new-features-0-4-3","dir":"Changelog","previous_headings":"ggtrace 0.4.5","what":"New Features","title":"ggtrace 0.4.x","text":"Added global_ggtrace_on/() aliases global_ggtrace_state(TRUE/FALSE) (#63)","code":""},{"path":"/news/index.html","id":"miscellaneous-0-4-1","dir":"Changelog","previous_headings":"ggtrace 0.4.5","what":"Miscellaneous","title":"ggtrace 0.4.x","text":"Added exploratory debugging case study vignette","code":""},{"path":[]},{"path":"/news/index.html","id":"improvements-0-4-2","dir":"Changelog","previous_headings":"ggtrace 0.4.4","what":"Improvements","title":"ggtrace 0.4.x","text":"clear_(last|global)_ggtrace() functions now print message saying trace dump cleared. Better error handling closures aren’t searchable environments","code":""},{"path":"/news/index.html","id":"bug-fix-0-4-1","dir":"Changelog","previous_headings":"ggtrace 0.4.4","what":"Bug Fix","title":"ggtrace 0.4.x","text":"Fixed methods class  treated bare functions. Now closures methods outside ggproto objects (e.g., R6 classes) can traced .","code":""},{"path":"/news/index.html","id":"miscellaneous-0-4-2","dir":"Changelog","previous_headings":"ggtrace 0.4.4","what":"Miscellaneous","title":"ggtrace 0.4.x","text":"Added FAQ vignette","code":""},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-4","dir":"Changelog","previous_headings":"ggtrace 0.4.3","what":"Breaking changes","title":"ggtrace 0.4.x","text":"Global tracedump turned default (global_ggtrace_state() FALSE load) must explicitly activated global_ggtrace_state(TRUE).","code":""},{"path":"/news/index.html","id":"improvements-0-4-3","dir":"Changelog","previous_headings":"ggtrace 0.4.3","what":"Improvements","title":"ggtrace 0.4.x","text":"Improved messages global_ggtrace_state()","code":""},{"path":[]},{"path":"/news/index.html","id":"bug-fixes-0-4","dir":"Changelog","previous_headings":"ggtrace 0.4.2","what":"Bug Fixes","title":"ggtrace 0.4.x","text":"Fixed bug print_output = TRUE evaluate expression twice (problematic Inject workflows causing general slowdowns)","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-4-4","dir":"Changelog","previous_headings":"ggtrace 0.4.1","what":"New Features","title":"ggtrace 0.4.x","text":"Global collection tracedumps can turned /global_ggtrace_state(). still active default memory become concern, can turned global_ggtrace_state(state = FALSE).","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-4-5","dir":"Changelog","previous_headings":"ggtrace 0.4.0","what":"New Features","title":"ggtrace 0.4.x","text":"functions package now support tracing/untracing arbitrary functions (exported, unexported, user-defined, etc.). also includes S3/S4 methods like ggplo2:::ggplot_build.ggplot ggplot2:::ggplot_add.Layer. examples ’s now possible.","code":""},{"path":"/news/index.html","id":"improvements-0-4-4","dir":"Changelog","previous_headings":"ggtrace 0.4.0","what":"Improvements","title":"ggtrace 0.4.x","text":"ggtrace() gains ... extensibility future updates. ggedit() gains remove_trace argument. TRUE, untraces first editing. Improved error messages invalid expressions passed method argument ggbody()","code":""},{"path":"/news/index.html","id":"bug-fixes-0-4-1","dir":"Changelog","previous_headings":"ggtrace 0.4.0","what":"Bug Fixes","title":"ggtrace 0.4.x","text":"Fix bug ggtrace() fails evaluate first line ’s reachable line (#44)","code":""},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"bug-fixes-0-3","dir":"Changelog","previous_headings":"ggtrace 0.3.7","what":"Bug Fixes","title":"ggtrace 0.3.x","text":"Fixed bug incomplete traces due early returns logged without special warning. ggtrace() now throws warning actual number traced steps match expected number traced steps (.e., length trace_steps) logs incomplete tracedumps (#44)","code":""},{"path":[]},{"path":"/news/index.html","id":"improvements-0-3","dir":"Changelog","previous_headings":"ggtrace 0.3.6","what":"Improvements","title":"ggtrace 0.3.x","text":"ggtrace(..., = TRUE) less noisy persistent trace. now sends line message saying persistent trace created. ’s triggered, ’ll tell persistent trace methodbut remind untrace later print corresponding gguntrace() code .","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-1","dir":"Changelog","previous_headings":"ggtrace 0.3.6","what":"Bug Fixes","title":"ggtrace 0.3.x","text":"Fixed bug trace_exprs evaluating NULL removed tracedump (#38)","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-3","dir":"Changelog","previous_headings":"ggtrace 0.3.5","what":"New features","title":"ggtrace 0.3.x","text":"New function is_traced() checks whether method currently traced","code":""},{"path":"/news/index.html","id":"improvements-0-3-1","dir":"Changelog","previous_headings":"ggtrace 0.3.5","what":"Improvements","title":"ggtrace 0.3.x","text":"ggtrace() now breaks early informative message method function (ex: Stat$extra_params, 1-length character vector \"na.rm\") ggbody() now warns ’s returning body method ’s currently traced (#35) ggedit() now informs ’re editing top existing trace/edit.","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-2","dir":"Changelog","previous_headings":"ggtrace 0.3.5","what":"Bug Fixes","title":"ggtrace 0.3.x","text":"Fixed bug trace_exprs fail recycled list length-1. Now 1-length list expression well expression get recycled match number steps passed trace_steps. Fixed bug ggtrace() wouldn’t loop trace_exprs first time ’s triggered persistent tracing (= TRUE). Issue due failing reset internal counter time trace triggered.","code":""},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-3","dir":"Changelog","previous_headings":"ggtrace 0.3.4","what":"Breaking changes","title":"ggtrace 0.3.x","text":".print argument ggtrace() renamed print_output make functionality transparent.","code":""},{"path":"/news/index.html","id":"new-features-0-3-1","dir":"Changelog","previous_headings":"ggtrace 0.3.4","what":"New features","title":"ggtrace 0.3.x","text":"Several options finer control printing formatting output ggtrace(), addition existing .print argument: ggtrace() gets use_names argument. TRUE, uses names list expressions passed trace_exprs names tracedump set last_ggtrace() added global_ggtrace(). ggtrace() gets verbose argument. FALSE, suppresses display non-message() information, including information expression evaluated , well output expressions evaluated (can selectively suppressed .print finer control). verbose TRUE default. Setting options(ggtrace.suppressMessages = TRUE) also suppress messages()s method traced, whether trace triggered method, whether exists persistent trace, etc. information important using option recommended, made available. option set FALSE package load. Setting options(ggtrace.as_tibble = TRUE) return evaluated expressions tibbles output data frame. Using option may convenient interactive inspections recommended testing debugging (see related {ggplot2} Github issue). option set FALSE package load.","code":""},{"path":"/news/index.html","id":"improvements-0-3-2","dir":"Changelog","previous_headings":"ggtrace 0.3.4","what":"Improvements","title":"ggtrace 0.3.x","text":"Tracedumps accumulated global_ggtrace() named method (+ hexadecimal ID) ease searching. (#31) Triggering trace now informed via message() instead cat() (#29)","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-3","dir":"Changelog","previous_headings":"ggtrace 0.3.4","what":"Bug Fixes","title":"ggtrace 0.3.x","text":"ggtrace() correctly throws error trace_steps ordered. checked negative index conversion, something like trace_steps = c(1, -1) still works fine).","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-3-2","dir":"Changelog","previous_headings":"ggtrace 0.3.3","what":"New features","title":"ggtrace 0.3.x","text":"New function global_ggtrace() returns accumulated tracedumps ggtrace(). useful conjunction ggtrace(= FALSE) tracing method expect called multiple times (ex: Stat$compute_group gets triggered number times number groups panel). New function clear_global_ggtrace() clears global_ggtrace() setting NULL.","code":""},{"path":"/news/index.html","id":"improvements-0-3-3","dir":"Changelog","previous_headings":"ggtrace 0.3.3","what":"Improvements","title":"ggtrace 0.3.x","text":"Functions now pass around quosures instead expressions (#29) Testing setup (#28)","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-4","dir":"Changelog","previous_headings":"ggtrace 0.3.3","what":"Bug Fixes","title":"ggtrace 0.3.x","text":"Fixed bug number expressions passed trace_exprs allowed different number trace_steps, causing ggtrace() silently fail. now throws error.","code":""},{"path":[]},{"path":"/news/index.html","id":"improvements-0-3-4","dir":"Changelog","previous_headings":"ggtrace 0.3.2","what":"Improvements","title":"ggtrace 0.3.x","text":"trace_exprs argument can now take named list expressions (#21) Improved documentation ggbody() informative messages ggtrace() gguntrace()","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-5","dir":"Changelog","previous_headings":"ggtrace 0.3.2","what":"Bug fixes","title":"ggtrace 0.3.x","text":"longer errors exit creating persistence trace = FALSE","code":""},{"path":[]},{"path":"/news/index.html","id":"improvements-0-3-5","dir":"Changelog","previous_headings":"ggtrace 0.3.1","what":"Improvements","title":"ggtrace 0.3.x","text":"unary functions ggedit() gguntrace() gain dynamic dots ... second argument, gets ignored. now makes easy call function modifying call earlierggtrace function console interactive contexts. Significant re-write ggbody() better error handling (#23) Aborts method call accepted form, specific error messages . method doesn’t exist parent, directs users call ggbody(, inherit = TRUE) recursive search inherit = TRUE fails, directs users load relevant packages Notifies inherit = TRUE method defined object, inherited Better error handling gguntrace() method longer traced (#24) Uses re-written ggbody() validate method Unlike base::untrace(), longer errors given method currently traced. now prints message saying instead Standardization messages printed ggtrace functions. Messages now informative refer ggproto method callable format ggproto$method.","code":""},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-3-1","dir":"Changelog","previous_headings":"ggtrace 0.3.0","what":"Breaking changes","title":"ggtrace 0.3.x","text":"obj argument completely removed functions package. constraint supplying methods expressions forces users intentional tracing ggproto methods provide code. also allows functions return informative messages, main motivation breaking change. obj argument designed compatibility get(\"method\", ggproto) syntax retrieving function body ggproto methods, affect interactive workflows. fact, shortform method = ggproto$method convenient always recommended passing ggproto method ggtrace functions. reminder, functions take ggproto method method argument expects expression following forms (part hasn’t changed): ggproto$method namespace::ggproto$method namespace:::ggproto$method","code":""},{"path":"/news/index.html","id":"improvements-0-3-6","dir":"Changelog","previous_headings":"ggtrace 0.3.0","what":"Improvements","title":"ggtrace 0.3.x","text":"Accurate string conversion ggproto objects (#9), made possible breaking change. trace_steps argument can now take negative indices (#22) better error handling range indices. Better deparsing split_ggproto_method() internal. Added Tips & Tricks section documentation ggtrace().","code":""},{"path":"/news/index.html","id":"bug-fixes-0-3-6","dir":"Changelog","previous_headings":"ggtrace 0.3.0","what":"Bug fixes","title":"ggtrace 0.3.x","text":"Internal variable .store renamed .ggtrace_storage prevent overriding ggplot2::.store (#18)","code":""},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-2","dir":"Changelog","previous_headings":"ggtrace 0.2.0","what":"Breaking changes","title":"ggtrace 0.2.x","text":"~line keyword ggtrace() renamed ~step consistency argument name trace_steps (#14) safety reasons, ~step keyword now substituted expression current step ~step (.e., exact match) (#16, #11). example, ~step substituted quote(head(~step)) passed trace_exprs. Users encouraged return method’s environment quote(environment()) interactively debug ggedit() want manipulate expression. position obj argument ggtrace() moved second fourth, allow shortcuts like ggtrace(method = ..., 2:3, quote(data)), evaluate store output data variable second third steps method body. (#15)","code":""},{"path":"/news/index.html","id":"new-features-0-2","dir":"Changelog","previous_headings":"ggtrace 0.2.0","what":"New features","title":"ggtrace 0.2.x","text":"trace_exprs argument ggtrace() now optional. provided, defaults ~step (#13) can now tell ggbody() (recursively) search method parents inherit = TRUE (#12)","code":""},{"path":"/news/index.html","id":"improvements-0-2","dir":"Changelog","previous_headings":"ggtrace 0.2.0","what":"Improvements","title":"ggtrace 0.2.x","text":"Documentation functions now contain Gotchas section explanations / solutions common problems (#10)","code":""},{"path":[]},{"path":[]},{"path":"/news/index.html","id":"new-features-0-1","dir":"Changelog","previous_headings":"ggtrace 0.1.2","what":"New features","title":"ggtrace 0.1.x","text":"New function gguntrace() syntax specifying ggproto method. ggtrace() gains = TRUE argument, can set FALSE persistent tracing","code":""},{"path":"/news/index.html","id":"bug-fixes-0-1","dir":"Changelog","previous_headings":"ggtrace 0.1.2","what":"Bug fixes","title":"ggtrace 0.1.x","text":"Fix bug ggtrace() step_deparsed returned multi-length vector","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-1-1","dir":"Changelog","previous_headings":"ggtrace 0.1.1","what":"New features","title":"ggtrace 0.1.x","text":"New function ggedit() interactive debugging via directly editing source code.","code":""},{"path":"/news/index.html","id":"improvements-0-1","dir":"Changelog","previous_headings":"ggtrace 0.1.1","what":"Improvements","title":"ggtrace 0.1.x","text":"Refactored ggtrace(). package now depends rlang. Significant re-write readme / documentation","code":""},{"path":[]},{"path":"/news/index.html","id":"initial-release-0-1","dir":"Changelog","previous_headings":"ggtrace 0.1.0","what":"Initial release","title":"ggtrace 0.1.x","text":"pkgdown site: https://yjunechoe.github.io/ggtrace Functions: ggtrace() ggbody() last_ggtrace()","code":""}]
